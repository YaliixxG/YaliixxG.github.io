<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>挖坑埋神经病</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yaliixxg.github.io/"/>
  <updated>2018-11-30T07:31:39.908Z</updated>
  <id>http://yaliixxg.github.io/</id>
  
  <author>
    <name>YaliixxG</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>关于微信和QRcode二维码分享那些踩过的坑</title>
    <link href="http://yaliixxg.github.io/2018/11/30/WXQRcode/"/>
    <id>http://yaliixxg.github.io/2018/11/30/WXQRcode/</id>
    <published>2018-11-30T07:30:54.000Z</published>
    <updated>2018-11-30T07:31:39.908Z</updated>
    
    <content type="html"><![CDATA[<h2 id="关于-微信分享-和-QRcode二维码分享那些踩过的坑"><a href="#关于-微信分享-和-QRcode二维码分享那些踩过的坑" class="headerlink" title="关于 微信分享 和 QRcode二维码分享那些踩过的坑"></a>关于 <code>微信分享</code> 和 <code>QRcode二维码分享</code>那些踩过的坑</h2><h2 id="微信分享"><a href="#微信分享" class="headerlink" title="微信分享"></a>微信分享</h2><h3 id="进行微信分享时，前提在项目中安装-SDK"><a href="#进行微信分享时，前提在项目中安装-SDK" class="headerlink" title="进行微信分享时，前提在项目中安装 SDK"></a>进行微信分享时，前提在项目中安装 SDK</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install weixin-js-sdk</span><br></pre></td></tr></table></figure><h3 id="分享的略缩图链接地址"><a href="#分享的略缩图链接地址" class="headerlink" title="分享的略缩图链接地址"></a>分享的略缩图链接地址</h3><ol><li>通过 import 引入图片</li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">"../assets/img/shareImg.png"</span></span><br></pre></td></tr></table></figure><ol start="2"><li>进行 build 打包并提交至线上地址</li><li>在线上地址中找到此图片链接</li><li>再将 dist 目录下的打包后的图片名引入</li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">imgUrl: <span class="string">"https://tmarketing.inuol.com/static/img/shareImg.dd45f95.png"</span></span><br></pre></td></tr></table></figure><a id="more"></a><h3 id="在微信公众号分享，报错-invalid-url"><a href="#在微信公众号分享，报错-invalid-url" class="headerlink" title="在微信公众号分享，报错 invalid url"></a>在微信公众号分享，报错 invalid url</h3><ol><li>导致这个错误，一般是由于此域名被微信判定为安全域名，需在后台将这个域名配置进去</li><li>appid，appsecret 这两个也必须是配置对应的准确的才可以</li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">this</span>.axios(&#123;</span><br><span class="line">  method: <span class="string">"get"</span>,</span><br><span class="line">  url: <span class="string">"https://tsoap.ftoul.com.cn/jssdk.php"</span>, <span class="comment">//此为后端配置的微信SDK分享的接口</span></span><br><span class="line">  params: &#123;</span><br><span class="line">    url: location.href.split(<span class="string">"#"</span>)[<span class="number">0</span>],</span><br><span class="line">    <span class="comment">//测试</span></span><br><span class="line">    appid: <span class="string">"wxf2d124530158a621"</span>,</span><br><span class="line">    appsecret: <span class="string">"11f0e5dabc0b83bd447fc455f10dc05a"</span></span><br><span class="line">    <span class="comment">//正式</span></span><br><span class="line">    <span class="comment">// appid: "wx54b08c17a2231b5c",</span></span><br><span class="line">    <span class="comment">// appsecret: "7254b1aab8e71625f5cc0e26893e7eb7"</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;).then(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">this</span>.wxShare(res.data, shareData)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h3 id="分享的链接地址需带-uid-类似得参数时，安卓机的问题"><a href="#分享的链接地址需带-uid-类似得参数时，安卓机的问题" class="headerlink" title="分享的链接地址需带 uid 类似得参数时，安卓机的问题"></a>分享的链接地址需带 uid 类似得参数时，安卓机的问题</h3><p>正常分享时带参数写法：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">linkUrl: <span class="string">"分享的链接"</span> + <span class="string">"?uid="</span> + <span class="built_in">window</span>.localStorage.getItem(<span class="string">"uid"</span>)</span><br></pre></td></tr></table></figure><p>上述写法在 ios 端可以正常携带参数，但是安卓端会出现截取参数的行为！！</p><p>解决方法：</p><ol><li>新建一个中转页，例如 share.html，注意放在 dist 文件夹中，与 index.html 同级</li></ol><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE html&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">"en"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"UTF-8"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">"viewport"</span> <span class="attr">content</span>=<span class="string">"width=device-width, initial-scale=1.0"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">"X-UA-Compatible"</span> <span class="attr">content</span>=<span class="string">"ie=edge"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Document<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="javascript">      <span class="comment">//获取地址栏参数</span></span></span><br><span class="line"><span class="javascript">      <span class="keyword">let</span> uid = location.href.split(<span class="string">"="</span>)[<span class="number">1</span>]</span></span><br><span class="line"><span class="javascript">      <span class="comment">//重定向至你原本需要分享的页面</span></span></span><br><span class="line"><span class="javascript">      location.href = <span class="string">"https://tmarketing.inuol.com/#/share?uid="</span> + uid</span></span><br><span class="line"><span class="undefined">    </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><ol start="2"><li>将微信分享里面的链接改成如下，也就是说先去中转页，再有中转页专向你需要分享的页面</li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">linkUrl:</span><br><span class="line">         <span class="string">"https://tmarketing.inuol.com/share.html"</span> +</span><br><span class="line">         <span class="string">"?uid="</span> +</span><br><span class="line">         <span class="built_in">window</span>.localStorage.getItem(<span class="string">"uid"</span>),</span><br></pre></td></tr></table></figure><ol start="3"><li>这样，安卓端也可以携带参数了。但是值得注意的是，安卓端携带参数后的链接与 ios 的链接是不一样的，<br>再进行地址栏取参数值时，请务必看清楚链接差异，再进行取值。</li></ol><h3 id="完整-demo"><a href="#完整-demo" class="headerlink" title="完整 demo:"></a>完整 demo:</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">"../assets/img/shareImg.png"</span>;</span><br><span class="line"><span class="comment">//微信分享</span></span><br><span class="line">    shareWX() &#123;</span><br><span class="line">      <span class="keyword">var</span> shareData = &#123;</span><br><span class="line">        title: <span class="string">"签约壹诺代理人"</span>,</span><br><span class="line">        linkUrl:</span><br><span class="line">          <span class="string">"https://tmarketing.inuol.com/share.html"</span> +</span><br><span class="line">          <span class="string">"?uid="</span> +</span><br><span class="line">          <span class="built_in">window</span>.localStorage.getItem(<span class="string">"uid"</span>),</span><br><span class="line">        imgUrl: <span class="string">"https://tmarketing.inuol.com/static/img/shareImg.dd45f95.png"</span>,</span><br><span class="line">        desc: <span class="string">"壹诺代理人 ，给您的收入加加油"</span></span><br><span class="line">      &#125;;</span><br><span class="line">      <span class="keyword">this</span>.axios(&#123;</span><br><span class="line">        method: <span class="string">"get"</span>,</span><br><span class="line">        url: signPackage,</span><br><span class="line">        params: &#123;</span><br><span class="line">          url: location.href.split(<span class="string">"#"</span>)[<span class="number">0</span>],</span><br><span class="line">          <span class="comment">//测试</span></span><br><span class="line">          appid: <span class="string">"wxf2d124530158a621"</span>,</span><br><span class="line">          appsecret: <span class="string">"11f0e5dabc0b83bd447fc455f10dc05a"</span></span><br><span class="line">          <span class="comment">//正式</span></span><br><span class="line">          <span class="comment">// appid: "wx54b08c17a2231b5c",</span></span><br><span class="line">          <span class="comment">// appsecret: "7254b1aab8e71625f5cc0e26893e7eb7"</span></span><br><span class="line">        &#125;</span><br><span class="line">      &#125;).then(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">this</span>.wxShare(res.data, shareData);</span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;,</span><br><span class="line">    wxShare(a, b) &#123;</span><br><span class="line">      wx.config(&#123;</span><br><span class="line">        debug: <span class="literal">false</span>, <span class="comment">//</span></span><br><span class="line">        appId: a.appId, <span class="comment">// 必填，公众号的唯一标识</span></span><br><span class="line">        timestamp: a.timestamp, <span class="comment">// 必填，生成签名的时间戳</span></span><br><span class="line">        nonceStr: a.nonceStr, <span class="comment">// 必填，生成签名的随机串</span></span><br><span class="line">        signature: a.signature, <span class="comment">// 必填，签名</span></span><br><span class="line">        jsApiList: [</span><br><span class="line">          <span class="string">"onMenuShareTimeline"</span>,</span><br><span class="line">          <span class="string">"onMenuShareAppMessage"</span>,</span><br><span class="line">          <span class="string">"onMenuShareQQ"</span>,</span><br><span class="line">          <span class="string">"onMenuShareQZone"</span></span><br><span class="line">        ]</span><br><span class="line">      &#125;);</span><br><span class="line"></span><br><span class="line">      wx.ready(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        wx.onMenuShareTimeline(&#123;</span><br><span class="line">          title: b.title,</span><br><span class="line">          link: b.linkUrl,</span><br><span class="line">          desc: b.desc,</span><br><span class="line">          imgUrl: b.imgUrl,</span><br><span class="line">          success: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        wx.onMenuShareAppMessage(&#123;</span><br><span class="line">          title: b.title,</span><br><span class="line">          desc: b.desc,</span><br><span class="line">          link: b.linkUrl,</span><br><span class="line">          imgUrl: b.imgUrl,</span><br><span class="line">          type: <span class="string">""</span>, <span class="comment">// 分享类型,music、video或link，不填默认为link</span></span><br><span class="line">          dataUrl: <span class="string">""</span>, <span class="comment">// 如果type是music或video，则要提供数据链接，默认为空</span></span><br><span class="line">          success: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;&#125;,</span><br><span class="line">          cancel: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        wx.onMenuShareQQ(&#123;</span><br><span class="line">          title: b.title,</span><br><span class="line">          desc: b.desc,</span><br><span class="line">          link: b.linkUrl,</span><br><span class="line">          imgUrl: b.imgUrl,</span><br><span class="line">          success: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;&#125;,</span><br><span class="line">          cancel: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        wx.onMenuShareQZone(&#123;</span><br><span class="line">          title: b.title,</span><br><span class="line">          desc: b.desc,</span><br><span class="line">          link: b.linkUrl,</span><br><span class="line">          imgUrl: b.imgUrl,</span><br><span class="line">          success: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;&#125;,</span><br><span class="line">          cancel: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line">        &#125;);</span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h2 id="QRcode-二维码分享"><a href="#QRcode-二维码分享" class="headerlink" title="QRcode 二维码分享"></a>QRcode 二维码分享</h2><h3 id="如何生成带参数的动态二维码"><a href="#如何生成带参数的动态二维码" class="headerlink" title="如何生成带参数的动态二维码"></a>如何生成带参数的动态二维码</h3><ol><li>先下载 <code>qrcode.js</code>，然后将其引入 main.js</li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">"./utils/qrcode.js"</span></span><br></pre></td></tr></table></figure><ol start="2"><li>在 DOM 结构中，建立一个 div,取名 qrcode，再在你需要展示二维码的地方建立个 img</li></ol><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"qrcode"</span> <span class="attr">v-show</span>=<span class="string">"false"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">img</span> <span class="attr">id</span>=<span class="string">"code"</span> <span class="attr">src</span> /&gt;</span></span><br></pre></td></tr></table></figure><ol start="3"><li>建立两个方法：不需要 DOM 是父子结构，但是写法；其实就是讲 qrcode 这个结构中的 img 的 src，赋值在你需要展示的 img 的 src 中。</li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//动态二维码</span></span><br><span class="line">    showQr() &#123;</span><br><span class="line">      <span class="keyword">var</span> Img = <span class="built_in">document</span>.querySelector(<span class="string">"#qrcode img"</span>).src; <span class="comment">//不需要DOM是父子结构，但是写法是如此</span></span><br><span class="line">      <span class="built_in">document</span>.querySelector(<span class="string">"#code"</span>).src = Img;</span><br><span class="line">      <span class="comment">//其实就是讲qrcode这个结构中的img的src，赋值在你需要展示的img的src中</span></span><br><span class="line">    &#125;,</span><br><span class="line">    qrCode() &#123;</span><br><span class="line">      <span class="keyword">let</span> url = <span class="string">"https://tmarketing.inuol.com/share.html"</span> + <span class="string">"?uid="</span> + <span class="keyword">this</span>.uid;</span><br><span class="line">      <span class="keyword">var</span> qrcode = <span class="keyword">new</span> QRCode(<span class="string">"qrcode"</span>, &#123;</span><br><span class="line">        text: url,</span><br><span class="line">        width: <span class="number">200</span>,</span><br><span class="line">        height: <span class="number">200</span>,</span><br><span class="line">        colorDark: <span class="string">"#000000"</span>,</span><br><span class="line">        colorLight: <span class="string">"#ffffff"</span>,</span><br><span class="line">        correctLevel: QRCode.CorrectLevel.H</span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;,</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;关于-微信分享-和-QRcode二维码分享那些踩过的坑&quot;&gt;&lt;a href=&quot;#关于-微信分享-和-QRcode二维码分享那些踩过的坑&quot; class=&quot;headerlink&quot; title=&quot;关于 微信分享 和 QRcode二维码分享那些踩过的坑&quot;&gt;&lt;/a&gt;关于 &lt;code&gt;微信分享&lt;/code&gt; 和 &lt;code&gt;QRcode二维码分享&lt;/code&gt;那些踩过的坑&lt;/h2&gt;&lt;h2 id=&quot;微信分享&quot;&gt;&lt;a href=&quot;#微信分享&quot; class=&quot;headerlink&quot; title=&quot;微信分享&quot;&gt;&lt;/a&gt;微信分享&lt;/h2&gt;&lt;h3 id=&quot;进行微信分享时，前提在项目中安装-SDK&quot;&gt;&lt;a href=&quot;#进行微信分享时，前提在项目中安装-SDK&quot; class=&quot;headerlink&quot; title=&quot;进行微信分享时，前提在项目中安装 SDK&quot;&gt;&lt;/a&gt;进行微信分享时，前提在项目中安装 SDK&lt;/h3&gt;&lt;figure class=&quot;highlight js&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;npm install weixin-js-sdk&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h3 id=&quot;分享的略缩图链接地址&quot;&gt;&lt;a href=&quot;#分享的略缩图链接地址&quot; class=&quot;headerlink&quot; title=&quot;分享的略缩图链接地址&quot;&gt;&lt;/a&gt;分享的略缩图链接地址&lt;/h3&gt;&lt;ol&gt;
&lt;li&gt;通过 import 引入图片&lt;/li&gt;
&lt;/ol&gt;
&lt;figure class=&quot;highlight js&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;import&lt;/span&gt; &lt;span class=&quot;string&quot;&gt;&quot;../assets/img/shareImg.png&quot;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;ol start=&quot;2&quot;&gt;
&lt;li&gt;进行 build 打包并提交至线上地址&lt;/li&gt;
&lt;li&gt;在线上地址中找到此图片链接&lt;/li&gt;
&lt;li&gt;再将 dist 目录下的打包后的图片名引入&lt;/li&gt;
&lt;/ol&gt;
&lt;figure class=&quot;highlight js&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;imgUrl: &lt;span class=&quot;string&quot;&gt;&quot;https://tmarketing.inuol.com/static/img/shareImg.dd45f95.png&quot;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
      <category term="web" scheme="http://yaliixxg.github.io/categories/web/"/>
    
    
      <category term="微信SDK 动态二维码分享" scheme="http://yaliixxg.github.io/tags/%E5%BE%AE%E4%BF%A1SDK-%E5%8A%A8%E6%80%81%E4%BA%8C%E7%BB%B4%E7%A0%81%E5%88%86%E4%BA%AB/"/>
    
  </entry>
  
  <entry>
    <title>WX</title>
    <link href="http://yaliixxg.github.io/2018/11/30/WX/"/>
    <id>http://yaliixxg.github.io/2018/11/30/WX/</id>
    <published>2018-11-30T07:30:40.000Z</published>
    <updated>2018-11-30T07:30:40.130Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Python 基础</title>
    <link href="http://yaliixxg.github.io/2018/09/20/aboutPy/"/>
    <id>http://yaliixxg.github.io/2018/09/20/aboutPy/</id>
    <published>2018-09-20T02:37:49.000Z</published>
    <updated>2018-09-29T09:42:52.652Z</updated>
    
    <content type="html"><![CDATA[<ol><li>Python 允许用<code>r&#39;&#39;</code>表示’’内部的字符串默认不转义。</li><li>Python 允许用<code>&#39;&#39;&#39;...&#39;&#39;&#39;</code>的格式表示多行内容。</li><li><code>and</code>代表“并且”，<code>or</code>代表“或”，<code>not</code>代表“非”</li><li>空值：用<code>None</code>表示。<code>None</code>不能理解为<code>0</code>，因为<code>0</code>是有意义的，而<code>None</code>是一个特殊的空值。</li><li>除法：<ul><li><code>/</code>除法计算结果是浮点数，即使两个整数恰好整除，结果也是浮点数。</li><li><code>\\</code>除法称为‘地板除’，无论是否除得尽，都得到整数。</li><li><code>%</code>是余数运算，可以得到两个整数相除的余数。<a id="more"></a></li></ul></li><li>占位符：<ul><li><code>%d</code> 整数</li><li><code>%f</code> 浮点数</li><li><code>%s</code> 字符串</li><li><code>%x</code> 十六进制整数</li></ul></li><li><code>input()</code>返回的数据类型是<code>str</code>,<code>str</code>不能直接和整数比较，必须先把<code>str</code>转换成整数，<code>int()</code>可以将其转换成整数类型。</li><li><p>如果想定义一个什么事也不做的空函数，可以用 <code>pass</code> 语句,<code>pass</code> 语句什么都不做，那有什么用？实际上 <code>pass</code> 可以用来作为占位符，比如现在还没想好怎么写函数的代码，就可以先放一个 <code>pass</code>，让代码能运行起来。</p><pre><code>def nop():    pass</code></pre></li><li><p>程序异常处理：当程序出现错误，python 会自动引发异常，也可以通过 raise 显示地引发异常。一旦执行了 raise 语句，raise 后面的语句将不能执行。</p></li><li><p>isinstance() 函数来判断一个对象是否是一个已知的类型。</p><pre><code>isinstance(object, classinfo)isinstance (a,str)isinstance (a,(str,int,list)) # 是元组中的一个返回 True</code></pre></li><li><p>函数参数：</p><ul><li><p>可变参数</p><pre><code>def calc(*numbers):sum = 0for n in numbers:    sum = sum + n * nreturn sumcalc(1,2)calc(1,2，5,0,3) //可以传入任意个参数</code></pre></li></ul></li><li><p>zeros(shape,dtype = float, order =’C’) 函数：</p><ul><li>返回来一个给定形状和类型的用 0 填充的数组</li><li>参数：<ul><li>shape：形状</li><li>dtype：数据类型，可选参数，默认 numpy.float64</li><li>order:可选参数，c 代表与 c 语言类似，行优先；F 代表列优先</li></ul></li></ul></li><li><p>zip():</p><ul><li><p>zip 函数接受任意多个可迭代对象作为参数,将对象中对应的元素打包成一个 tuple,然后返回一个可迭代的 zip 对象.</p></li><li><p>这个可迭代对象可以使用循环的方式列出其元素</p></li><li><p>若多个可迭代对象的长度不一致,则所返回的列表与长度最短的可迭代对象相同.</p></li></ul></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;ol&gt;
&lt;li&gt;Python 允许用&lt;code&gt;r&amp;#39;&amp;#39;&lt;/code&gt;表示’’内部的字符串默认不转义。&lt;/li&gt;
&lt;li&gt;Python 允许用&lt;code&gt;&amp;#39;&amp;#39;&amp;#39;...&amp;#39;&amp;#39;&amp;#39;&lt;/code&gt;的格式表示多行内容。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;and&lt;/code&gt;代表“并且”，&lt;code&gt;or&lt;/code&gt;代表“或”，&lt;code&gt;not&lt;/code&gt;代表“非”&lt;/li&gt;
&lt;li&gt;空值：用&lt;code&gt;None&lt;/code&gt;表示。&lt;code&gt;None&lt;/code&gt;不能理解为&lt;code&gt;0&lt;/code&gt;，因为&lt;code&gt;0&lt;/code&gt;是有意义的，而&lt;code&gt;None&lt;/code&gt;是一个特殊的空值。&lt;/li&gt;
&lt;li&gt;除法：&lt;ul&gt;
&lt;li&gt;&lt;code&gt;/&lt;/code&gt;除法计算结果是浮点数，即使两个整数恰好整除，结果也是浮点数。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;\\&lt;/code&gt;除法称为‘地板除’，无论是否除得尽，都得到整数。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;%&lt;/code&gt;是余数运算，可以得到两个整数相除的余数。&lt;/li&gt;&lt;/ul&gt;&lt;/li&gt;&lt;/ol&gt;
    
    </summary>
    
      <category term="web" scheme="http://yaliixxg.github.io/categories/web/"/>
    
    
      <category term="python" scheme="http://yaliixxg.github.io/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>TypeScript</title>
    <link href="http://yaliixxg.github.io/2018/09/19/typescript/"/>
    <id>http://yaliixxg.github.io/2018/09/19/typescript/</id>
    <published>2018-09-19T07:11:26.000Z</published>
    <updated>2018-09-19T07:13:13.923Z</updated>
    
    <content type="html"><![CDATA[<h1 id="TypeScript"><a href="#TypeScript" class="headerlink" title="TypeScript"></a>TypeScript</h1>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;TypeScript&quot;&gt;&lt;a href=&quot;#TypeScript&quot; class=&quot;headerlink&quot; title=&quot;TypeScript&quot;&gt;&lt;/a&gt;TypeScript&lt;/h1&gt;
      
    
    </summary>
    
      <category term="web" scheme="http://yaliixxg.github.io/categories/web/"/>
    
    
      <category term="typescript" scheme="http://yaliixxg.github.io/tags/typescript/"/>
    
  </entry>
  
  <entry>
    <title>胃痛的不行，必须养胃了</title>
    <link href="http://yaliixxg.github.io/2018/09/03/healthy/"/>
    <id>http://yaliixxg.github.io/2018/09/03/healthy/</id>
    <published>2018-09-03T06:43:59.000Z</published>
    <updated>2018-09-03T07:16:19.033Z</updated>
    
    <content type="html"><![CDATA[<p>因为时常的胃痛，让我感觉自己身体已经快承受不起这些疼痛了。现在之所以能想起要开始养胃，也是因为一上午直到刚刚，我的胃都处于非常痛的状态。<br>胃部以及下方的腹部都处于胀气，绞痛的感觉。<br>25 岁以后真的能明显感觉到自己的健康越来越重要，但是自己自律性不够，导致于一直在拖垮自己的身体。在地铁三番两次的晕倒，跑两步就不停地喘气，这些都是我的身体发出的危险讯号。我必须自律健康起来！</p><a id="more"></a><h2 id="忌口"><a href="#忌口" class="headerlink" title="忌口"></a>忌口</h2><ol><li>不喝碳酸饮料，多喝温热的白开水</li><li>切忌 酸 辣 冷的实物</li><li>产酸过多的食物：甜品、地瓜、香蕉、韭菜、蜂蜜、山楂、豆腐乳</li><li>辛辣刺激的食物：生葱、生蒜、辣椒、酒、咖啡、浓茶</li><li>易胀气的食物：豆制品（豆腐、豆浆、马铃薯）、肉类、牛奶、油炸食品、薯类（地瓜、马铃薯）及碳酸饮料</li><li>避免吃东西时狼吞虎咽、边吃东西边说话，少嚼口香糖</li></ol><h2 id="多吃"><a href="#多吃" class="headerlink" title="多吃"></a>多吃</h2><ol><li>苏打饼干</li><li>含纤维素多的蔬菜、水果、多吃杂粮：小麦粉、糙米、玉米、芋头、燕麦片</li><li>酸奶</li><li>温开水</li><li>面食，面条、馒头、花卷、饺子等面食</li><li>小米粥，多吃小米粥，清淡易消化</li><li>大枣、山药、白菜、胡萝卜、菠菜</li></ol><h2 id="避免胃结石"><a href="#避免胃结石" class="headerlink" title="避免胃结石"></a>避免胃结石</h2><ol><li>不要空腹或者饮酒喝茶的时候吃柿子、软枣（黑枣）、山楂、香蕉。</li></ol><h2 id="锻炼"><a href="#锻炼" class="headerlink" title="锻炼"></a>锻炼</h2><ol><li>多运动，睡前、晨起用力按摩小腹 200 次。</li><li>养成定时排便习惯。</li></ol><h2 id="最重要的一点：一定要吃早饭！！不论吃什么，水果也好，一块小面包也好，总之一定得吃早饭。一天中，早饭是最重要的。这是常识。"><a href="#最重要的一点：一定要吃早饭！！不论吃什么，水果也好，一块小面包也好，总之一定得吃早饭。一天中，早饭是最重要的。这是常识。" class="headerlink" title="最重要的一点：一定要吃早饭！！不论吃什么，水果也好，一块小面包也好，总之一定得吃早饭。一天中，早饭是最重要的。这是常识。"></a>最重要的一点：一定要吃早饭！！不论吃什么，水果也好，一块小面包也好，总之一定得吃早饭。一天中，早饭是最重要的。这是常识。</h2>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;因为时常的胃痛，让我感觉自己身体已经快承受不起这些疼痛了。现在之所以能想起要开始养胃，也是因为一上午直到刚刚，我的胃都处于非常痛的状态。&lt;br&gt;胃部以及下方的腹部都处于胀气，绞痛的感觉。&lt;br&gt;25 岁以后真的能明显感觉到自己的健康越来越重要，但是自己自律性不够，导致于一直在拖垮自己的身体。在地铁三番两次的晕倒，跑两步就不停地喘气，这些都是我的身体发出的危险讯号。我必须自律健康起来！&lt;/p&gt;
    
    </summary>
    
      <category term="哔哔叨叨" scheme="http://yaliixxg.github.io/categories/%E5%93%94%E5%93%94%E5%8F%A8%E5%8F%A8/"/>
    
    
      <category term="胃痛 健康" scheme="http://yaliixxg.github.io/tags/%E8%83%83%E7%97%9B-%E5%81%A5%E5%BA%B7/"/>
    
  </entry>
  
  <entry>
    <title>SSO 单点登录</title>
    <link href="http://yaliixxg.github.io/2018/08/31/SSO/"/>
    <id>http://yaliixxg.github.io/2018/08/31/SSO/</id>
    <published>2018-08-31T03:19:09.000Z</published>
    <updated>2018-08-31T06:28:51.074Z</updated>
    
    <content type="html"><![CDATA[<h2 id="什么是单点登录"><a href="#什么是单点登录" class="headerlink" title="什么是单点登录"></a>什么是单点登录</h2><p><strong>单点登录（Single Sign On）</strong>，简称为 SSO，是目前比较流行的企业业务整合的解决方案之一。SSO 的定义是在多个应用系统中，用户只需要登录一次就可以访问所有相互信任的应用系统</p><p>SSO 一般都需要一个独立的认证中心（passport），子系统的登录均得通过 passport，子系统本身将不参与登录操作，当一个系统成功登录以后，passport 将会颁发一个令牌给各个子系统，子系统可以拿着令牌会获取各自的受保护资源，为了减少频繁认证，各个子系统在被 passport 授权以后，会建立一个局部会话，在一定时间内可以无需再次向 passport 发起认证。</p><a id="more"></a><blockquote><p>举个例子，比如淘宝、天猫都属于阿里旗下的产品，当用户登录淘宝后，再打开天猫，系统便自动帮用户登录了天猫，这种现象背后就是用单点登录实现的</p></blockquote><h3 id="单点登录流程"><a href="#单点登录流程" class="headerlink" title="单点登录流程"></a>单点登录流程</h3><h4 id="1-登录"><a href="#1-登录" class="headerlink" title="1.登录"></a>1.登录</h4><p><img src="https://user-gold-cdn.xitu.io/2018/8/15/1653c606dca33f74?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="alt"></p><ul><li>用户访问系统 1 的受保护资源，系统 1 发现用户未登录，跳转至 sso 认证中心，并将自己的地址作为参数<br>sso 认证中心发现用户未登录，将用户引导至登录页面</li><li>用户输入用户名密码提交登录申请</li><li>sso 认证中心校验用户信息，创建用户与 sso 认证中心之间的会话，称为全局会话，同时创建授权令牌</li><li>sso 认证中心带着令牌跳转会最初的请求地址（系统 1）</li><li>系统 1 拿到令牌，去 sso 认证中心校验令牌是否有效</li><li>sso 认证中心校验令牌，返回有效，注册系统 1</li><li>系统 1 使用该令牌创建与用户的会话，称为局部会话，返回受保护资源</li><li>用户访问系统 2 的受保护资源</li><li>系统 2 发现用户未登录，跳转至 sso 认证中心，并将自己的地址作为参数</li><li>sso 认证中心发现用户已登录，跳转回系统 2 的地址，并附上令牌</li><li>系统 2 拿到令牌，去 sso 认证中心校验令牌是否有效</li><li>sso 认证中心校验令牌，返回有效，注册系统 2</li><li>系统 2 使用该令牌创建与用户的局部会话，返回受保护资源</li></ul><p>用户登录成功之后，会与 sso 认证中心及各个子系统建立会话，用户与 sso 认证中心建立的会话称为全局会话，用户与各个子系统建立的会话称为局部会话，局部会话建立之后，用户访问子系统受保护资源将不再通过 sso 认证中心，全局会话与局部会话有如下约束关系</p><ul><li>局部会话存在，全局会话一定存在</li><li>全局会话存在，局部会话不一定存在</li><li>全局会话销毁，局部会话必须销毁</li></ul><h4 id="2-注销"><a href="#2-注销" class="headerlink" title="2.注销"></a>2.注销</h4><p><img src="https://user-gold-cdn.xitu.io/2018/8/15/1653c66a94ddeeb2?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="alt"></p><p>sso 认证中心一直监听全局会话的状态，一旦全局会话销毁，监听器将通知所有注册系统执行注销操作。</p><ul><li>用户向系统 1 发起注销请求</li><li>系统 1 根据用户与系统 1 建立的会话 id 拿到令牌，向 sso 认证中心发起注销请求</li><li>sso 认证中心校验令牌有效，销毁全局会话，同时取出所有用此令牌注册的系统地址</li><li>sso 认证中心向所有注册系统发起注销请求</li><li>各注册系统接收 sso 认证中心的注销请求，销毁局部会话</li><li>sso 认证中心引导用户至登录页面</li></ul><h3 id="单点登录关于前端的部分"><a href="#单点登录关于前端的部分" class="headerlink" title="单点登录关于前端的部分"></a>单点登录关于前端的部分</h3><p>此代码采用<code>OAuth2</code>。关于<code>token</code>存储问题，参考了网上许多教程，大部分都是将<code>token</code>存储在<code>cookie</code>中，然后将<code>cookie</code>设为顶级域来解决跨域问题，但我司业务需求是某些产品顶级域也各不相同。故实现思路是将<code>token</code>存储在<code>localStorage</code>中，然后通过 H5 的新属性<code>postMessage</code>来实现跨域共享</p><blockquote><p>OAuth（开放授权）是一个开放标准，允许用户让第三方应用访问该用户在某一网站上存储的私密的资源（如照片，视频，联系人列表），而无需将用户名和密码提供给第三方应用。</p></blockquote><blockquote><p>通俗说，OAuth 就是一种授权的协议，只要授权方和被授权方遵守这个协议去写代码提供服务，那双方就是实现了 OAuth 模式。</p></blockquote><blockquote><p>详细说就是，OAuth 在”客户端”与”服务提供商”之间，设置了一个授权层（authorization layer）。”客户端”不能直接登录”服务提供商”，只能登录授权层，以此将用户与客户端区分开来。”客户端”登录授权层所用的令牌（token），与用户的密码不同。用户可以在登录的时候，指定授权层令牌的权限范围和有效期。”客户端”登录授权层以后，”服务提供商”根据令牌的权限范围和有效期，向”客户端”开放用户储存的资料。</p></blockquote><blockquote><p>OAuth2 是 OAuth1.0 的下一个版本，OAuth2 关注客户端开发者的简易性，同时为 Web 应用，桌面应用和手机，和起居室设备提供专门的认证流程。原先的 OAuth，会发行一个 有效期非常长的 token(典型的是一年有效期或者无有效期限制)，在 OAuth 2.0 中，server 将发行一个短有效期的 access token 和长生命期的 refresh token。这将允许客户端无需用户再次操作而获取一个新的 access token，并且也限制了 access token 的有效期。</p></blockquote><p>实现思路：当用户访问公司某系统(如 product.html)时，在 product 中会首先加载一个 iframe，iframe 中可以获取存储在 localStorage 中的 token，如果没有取到或 token 过期，iframe 中内部将把用户将重定向到登录页，用户在此页面登录，仍将去认证系统取得 token 并保存在 iframe 页面的 localStorage</p><pre><code>&lt;!--product.html--&gt;&lt;head&gt;    &lt;script src=&quot;auth_1.0.0.js&quot;&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt;    &lt;h2&gt;产品页面&lt;/h2&gt;    &lt;a onClick=&quot;login()&quot; id=&quot;login&quot;&gt;登录&lt;/a&gt;    &lt;h3 id=&quot;txt&quot;&gt;&lt;/h3&gt;&lt;/body&gt;&lt;script&gt;var opts = {    origin: &apos;http://localhost:8080&apos;,    login_path: &apos;/login.html&apos;,    path: &apos;/cross_domain.html&apos;}// 加载iframe,将src值为cross_domain.html的iframe加载到本页var auth = new ssoAuth(opts);function getTokenCallback(data) {    //如果没有token则跳到登录页    if(!data.value){        auth.doWebLogin();    }    //如果有token,直接在页面显示，然后做其它操作    document.getElementById(&apos;txt&apos;).innerText = &apos;token=&apos; + data.value;}// 获取存储在名为cross_domain的iframe中的tokenauth.getToken(getTokenCallback);&lt;/script&gt;</code></pre><blockquote><p>讲解：在 product.html 中实例化了 ssoAuth 后，此页面便将 iframe 引入了当前页，名为 opts.path 的值，即 cross_domain.html。auth.getToken()是获取此 iframe 页面中的 localStorage 值。</p></blockquote><pre><code>//auth_1.0.0.jsfunction ssoAuth(opts) {    this._origin = opts.origin,    this._iframe_path = opts.path,    this._iframe = null,    this._iframe_ready = false,    this._queue = [],    this._auth = {},    this._access_token_msg = { type: &quot;get&quot;, key: &quot;access_token&quot; },    this._callback = undefined,    that = this;    //判断是否支持postMessage及localStoragevar supported = (function () {        try {            return window.postMessage &amp;&amp; window.JSON &amp;&amp; &apos;localStorage&apos; in window &amp;&amp; window[&apos;localStorage&apos;] !== null;        } catch (e) {            return false;        }    })();    _iframeLoaded = function () {        that._iframe_ready = true        if (that._queue.length) {            for (var i = 0, len = that._queue.length; i &lt; len; i++) {                _sendMessage(that._queue[i]);            }            that._queue = [];        }    }    _sendMessage = function (data) {        // 通过contentWindow属性，脚本可以访问iframe元素所包含的HTML页面的window对象。        that._iframe.contentWindow.postMessage(JSON.stringify(data), that._origin);    }    //获取token,但因为此时iframe还没有加载完成，先将消息存储在队列_queue中    this._auth.getToken = function (callback) {        that._callback = callback        if (that._access_token_msg &amp;&amp; that._iframe_ready) {            //当iframe加载完成，给iframe所在的页面发送消息            _sendMessage(that._access_token_msg);        } else {            that._queue.push(that._access_token_msg);        }    }    var _handleMessage = function (event) {        if (event.origin === that._origin) {            var data = JSON.parse(event.data);            if (data.error) {                console.error(event.data)                that._callback({ value: null });                return;            }            if (that._callback &amp;&amp; typeof that._callback === &apos;function&apos;) {                that._callback(data);            } else {                console.error(&quot;callback is null or not a function, please &quot;);            }        }    }    this._auth.doWebLogin = function () {        window.location.href = opts.origin + opts.login_path + &quot;?redirect_url=&quot; + window.location.href    }    //初始化了一个iframe,并追加到父页面的底部    if (!this._iframe &amp;&amp; supported) {        this._iframe = document.createElement(&quot;iframe&quot;);        this._iframe.style.cssText = &quot;position:absolute;width:1px;height:1px;left:-9999px;&quot;;        document.body.appendChild(this._iframe);        if (window.addEventListener) {            this._iframe.addEventListener(&quot;load&quot;, function () {                _iframeLoaded();            }, false);            window.addEventListener(&quot;message&quot;, function (event) {                _handleMessage(event)            }, false);        } else if (this._iframe.attachEvent) {            this._iframe.attachEvent(&quot;onload&quot;, function () {                _iframeLoaded();            }, false);            window.attachEvent(&quot;onmessage&quot;, function (event) {                _handleMessage(event)            });        }        this._iframe.src = this._origin + this._iframe_path;    }    return this._auth;}&lt;!--cross_domain.html--&gt;&lt;script type=&quot;text/javascript&quot;&gt;    (function () {        //白名单        var whitelist = [&quot;localhost&quot;, &quot;127.0.0.1&quot;, &quot;^.*\.domain\.com&quot;];        function verifyOrigin(origin) {            var domain = origin.replace(/^https?:\/\/|:\d{1,4}$/g, &quot;&quot;).toLowerCase(),                i = 0,                len = whitelist.length;            while (i &lt; len) {                if (domain.match(new RegExp(whitelist[i]))) {                    return true;                }                i++;            }            return false;        }        function handleRequest(event) {            // 白名单较验            if (verifyOrigin(event.origin)) {                var request = JSON.parse(event.data);                if (request.type == &apos;get&apos;) {                    var idi = sessionStorage.getItem(&quot;idi&quot;);                    if (!idi) {                        // source:对发送消息的窗口对象的引用                        event.source.postMessage(JSON.stringify({ key: request.key, value: null }), event.origin);                        return;                    }                    value = JSON.parse(idi)[request.key];                    event.source.postMessage(JSON.stringify({ key: request.key, value: value }), event.origin);                } else {                    event.source.postMessage(JSON.stringify({ error: &quot;Not supported&quot;, error_description: &quot;Not supported message type&quot; }), event.origin);                }            }        }        // 接收iframe传来的消息        if (window.addEventListener) {            window.addEventListener(&quot;message&quot;, handleRequest, false);        } else if (window.attachEvent) {            window.attachEvent(&quot;onmessage&quot;, handleRequest);        }    })();&lt;/script&gt;&lt;!--login.html--&gt;&lt;head&gt;    &lt;script src=&quot;auth_1.0.0.js&quot;&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt;    &lt;form&gt;        &lt;input type=&quot;text&quot; placeholder=&quot;用户名&quot; id=&quot;user&quot;&gt;        &lt;input type=&quot;password&quot; placeholder=&quot;密码&quot; id=&quot;pwd&quot;&gt;    &lt;/form&gt;    &lt;button onClick=&quot;login()&quot;&gt;登 录&lt;/button&gt;&lt;/body&gt;&lt;script&gt;    function login() {        var name = document.getElementById(&apos;user&apos;)        var pwd = document.getElementById(&apos;pwd&apos;)        var expires_in = 7200        //假如这是登录成功后，后台开发人员返回的json数据        var res = {            access_token: &quot;xxxxx.yyyyy.zzzzz&quot;,            expires_at: expires_in * 1000 + new Date().getTime(),            refresh_token: &quot;yyyyyyyyyyyyyyyyyyyyyyyyyyyy&quot;        };        localStorage.setItem(&quot;idi&quot;, JSON.stringify(res))        //登录成功后再返回原页面        window.location.href = getQueryString(&quot;redirect_url&quot;)    }    function getQueryString(name) {        var reg = new RegExp(&quot;(^|&amp;)&quot; + name + &quot;=([^&amp;]*)(&amp;|$)&quot;);        var r = window.location.search.substr(1).match(reg);        if (r != null) return unescape(r[2]); return null;    }&lt;/script&gt;</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;什么是单点登录&quot;&gt;&lt;a href=&quot;#什么是单点登录&quot; class=&quot;headerlink&quot; title=&quot;什么是单点登录&quot;&gt;&lt;/a&gt;什么是单点登录&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;单点登录（Single Sign On）&lt;/strong&gt;，简称为 SSO，是目前比较流行的企业业务整合的解决方案之一。SSO 的定义是在多个应用系统中，用户只需要登录一次就可以访问所有相互信任的应用系统&lt;/p&gt;
&lt;p&gt;SSO 一般都需要一个独立的认证中心（passport），子系统的登录均得通过 passport，子系统本身将不参与登录操作，当一个系统成功登录以后，passport 将会颁发一个令牌给各个子系统，子系统可以拿着令牌会获取各自的受保护资源，为了减少频繁认证，各个子系统在被 passport 授权以后，会建立一个局部会话，在一定时间内可以无需再次向 passport 发起认证。&lt;/p&gt;
    
    </summary>
    
      <category term="web" scheme="http://yaliixxg.github.io/categories/web/"/>
    
    
      <category term="单点登录 SSO 前端" scheme="http://yaliixxg.github.io/tags/%E5%8D%95%E7%82%B9%E7%99%BB%E5%BD%95-SSO-%E5%89%8D%E7%AB%AF/"/>
    
  </entry>
  
  <entry>
    <title>react-native Bug问题汇总</title>
    <link href="http://yaliixxg.github.io/2018/08/22/react-native-bug/"/>
    <id>http://yaliixxg.github.io/2018/08/22/react-native-bug/</id>
    <published>2018-08-22T08:20:57.000Z</published>
    <updated>2018-08-22T08:32:33.197Z</updated>
    
    <content type="html"><![CDATA[<h2 id="react-native-环境构建"><a href="#react-native-环境构建" class="headerlink" title="react-native 环境构建"></a>react-native 环境构建</h2><p><a href="https://reactnative.cn/docs/getting-started.html" target="_blank" rel="noopener">点击前往 react-native 环境构建</a></p><h2 id="react-native-bug"><a href="#react-native-bug" class="headerlink" title="react-native bug"></a>react-native bug</h2><ol><li>端口号 8081 被占用<br><code>修改端口号：react-native start --port 9999</code><br><code>修改模拟器地址： ip+9999，例如：192.165.1.1:9999</code></li><li>adb 版本不一致：adb server version (31) doesn’t match this client (36); killing…<br><code>复制sdk里面的adb.exe改名nox_adb.exe,将nox/bin里的nox_adb.ex替换</code></li><li>git 上拉去 react native,react-native start 运行报错<br><code>cd android</code><br><code>gradlew clean</code><pre><code>&lt;!--more--&gt;</code></pre></li><li>no connect devices(没有链接设备)<br><code>adb devices(这个命令是查看是否连接设备)</code><br><code>adb conncet 127.0.0.1:62001(手动连接设备)</code></li><li>INSTALL_PARSE_FAILED_INCONSISTENT_CERTIFICATES(模拟器上已经安装了此 APP)<br><code>卸载重装即可</code></li><li>unable to resolve module ‘ACCESSIBILITYINFO’ （react-native 版本问题）<br><code>切换版本 react-native@0.55.4 react-native-cli@1.2.0</code></li><li>plugin 0 specified in xxx （babel-preset-react-native 的包文件错误）<br><code>npm install --save -dev babel-preset-react-native@2.1.0</code></li><li>javascript 与 native 版本不一致报错<br><code>npm install react-native@要求的版本号</code> 然后卸载老版本即可</li><li>启动页白屏<br>关闭程序，再重新打开一次</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;react-native-环境构建&quot;&gt;&lt;a href=&quot;#react-native-环境构建&quot; class=&quot;headerlink&quot; title=&quot;react-native 环境构建&quot;&gt;&lt;/a&gt;react-native 环境构建&lt;/h2&gt;&lt;p&gt;&lt;a href=&quot;h
      
    
    </summary>
    
      <category term="web" scheme="http://yaliixxg.github.io/categories/web/"/>
    
    
      <category term="react-native bug 修复 问题" scheme="http://yaliixxg.github.io/tags/react-native-bug-%E4%BF%AE%E5%A4%8D-%E9%97%AE%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>React 学习笔记</title>
    <link href="http://yaliixxg.github.io/2018/08/13/react-study/"/>
    <id>http://yaliixxg.github.io/2018/08/13/react-study/</id>
    <published>2018-08-13T02:59:31.000Z</published>
    <updated>2018-08-21T09:08:02.504Z</updated>
    
    <content type="html"><![CDATA[<h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><pre><code>npm install -g create-react-appcreate-react-app my-appcd my-appnpm start</code></pre><a id="more"></a><h2 id="项目文件夹结构分析"><a href="#项目文件夹结构分析" class="headerlink" title="项目文件夹结构分析"></a>项目文件夹结构分析</h2><ul><li>package.json:这个文件是管理下载的依赖包,在项目中经常用到的是”react”库，“react-dom”（将 jsx 语法渲染到 dom 中）在项目中最重要的命令是“start”启动项目，”bulid”的作用就是将项目打包。</li><li>public 文件夹<ul><li>index.html:项目的入口文件，引用了第三方类库啊，还可以引入 cdn。<code>&lt;div id=&quot;root&quot;&gt;&lt;/div&gt;</code>是项目的总容器，所有的内容存储在这个容器中。这个容器有且只能有一个。</li><li>favicon.ico:是浏览器 tab 上图标，也是这个项目的一个标志，也可以说是代表一个公司的标志。可以替换。</li></ul></li><li>src 文件夹<ul><li>index.js:存放的是这个项目的核心内容，也就是我们的主要工作区域。其中，index.js 文件是和 index.html 进行关联的文件的唯一接口。 ReactDOM.render()的作用是将<app>的内容渲染到根“root”中去。document.getElementById(‘root’)中的”root”便是 index.html 中的”root”了，<app>便是引用页面内容了。在这里，<app>也可以写一些内容(结构,样式,逻辑)是整个项目的根组件，比如:<code>ReactDOM.render(&lt;p &gt;Hello World&lt;/p&gt;, document.getElementById(&#39;root&#39;))</code>;能够引用<app>的原因是文档内容的头部，有<code>import App from &#39;./App&#39;</code>;内容，就是为了将 App.js 的内容引入到 index.js 文件中。</app></app></app></app></li><li>App.js:该类是继承 react 提供的 component，<code>export default App;</code>是为了将 App 公开，index.js 才能够引用。App.js 继承了 component 的话，必须使用 render 进行渲染。return 的内容是类似于 html 结构的内容，就是<code>jsx</code>，jsx 语法是 react 的主要语法。内部的 div 的 className 是为了区分 html 语法的一个类名，这个是 div 的样式引用。在这个文件中，只能用一个 div 容器，如果在 div 的同级目录添加别的内容，便会报错。</li></ul></li></ul><h2 id="定义组件（函数、类）"><a href="#定义组件（函数、类）" class="headerlink" title="定义组件（函数、类）"></a>定义组件（函数、类）</h2><blockquote><p>组件从概念上看就像是函数，它可以接收任意的输入值（称之为“props”），并返回一个需要在页面上展示的 React 元素。</p></blockquote><ul><li>函数定义组件</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">function Welcome(props)&#123;</span><br><span class="line">      return &lt;h1&gt;Hello,&#123;props.name&#125;&lt;/h1&gt;;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>该函数是一个 React 组件，它接收一个”props”对象并返回了一个 React 元素。</p><ul><li><p>类定义组件</p><pre><code>class Welcome extends Component{  render(){    rturn return &lt;h1&gt;Hello,{this.props.name}&lt;/h1&gt;;  }}</code></pre></li></ul><ul><li>如何使用这个组件？<br>在需要这个组件的地方，必须定义或引入它。并且<welcome>，如果要用到上述组件定义的 name 属性，即<welcome name="Indge">来进行传值。<br>组件名称必须是以大写字母开头。</welcome></welcome></li></ul><blockquote><p>Props 的只读性:所有的 React 组件必须像纯函数那样使用它们的 props。</p></blockquote><h2 id="State-amp-生命周期"><a href="#State-amp-生命周期" class="headerlink" title="State &amp; 生命周期"></a>State &amp; 生命周期</h2><blockquote><p>这种只在使用类定义组件时可以使用其它特性。例如局部状态，生命周期钩子。</p></blockquote><h3 id="为一个类添加局部状态和生命周期-（利用局部状态，则不需要在组件引用时再写-date-…-）"><a href="#为一个类添加局部状态和生命周期-（利用局部状态，则不需要在组件引用时再写-date-…-）" class="headerlink" title="为一个类添加局部状态和生命周期 （利用局部状态，则不需要在组件引用时再写 date={…}）"></a>为一个类添加局部状态和生命周期 （利用局部状态，则不需要在组件引用时再写 date={…}）</h3><pre><code>class Demo extends Component{    constructor(props){  //第二步：添加一个类构造函数来初始化状态 this.state        super(props)     //注意：super(props)的目的，在constructor中可以使用this.props        this.state = {date:new Date()}    }    componentDidMount(){ //当组件输出到DOM后执行    this.timerID = setInterval(()=&gt;{        this.tick()    },1000)    }    componentWillUnmount(){ //当组件被移除出DOM时执行    clearInterval(this.timerID)    }    tick(){           //第三步：更新局部状态        this.setState({            date:new Date()        })    }    render(){        return(          &lt;div&gt;          &lt;h1&gt;挖坑埋神经病,{this.props.list}&lt;/h1&gt;          &lt;h2&gt;现在时间为{this.state.date.toLocaleTimeString()}&lt;/h2&gt;  //第一步：在 render() 方法中使用 this.state.date 替代 this.props.date          &lt;/div&gt;        )    }}</code></pre><h3 id="setState-的正确使用"><a href="#setState-的正确使用" class="headerlink" title="setState 的正确使用"></a>setState 的正确使用</h3><ol><li><p>不要直接更新状态。<code>this.state.comment = &#39;Hello&#39;;</code> 此代码不会重新渲染组件。应使用 setState()来更新组件，<code>this.setState({comment: &#39;Hello&#39;});</code>，构造函数是唯一能够初始化 this.state 的地方。</p></li><li><p>状态更新可能是异步的，this.props 和 this.state 是异步更新的，不能直接用来计算</p></li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// Wrong</span><br><span class="line">this.setState(&#123;</span><br><span class="line">  counter: this.state.counter + this.props.increment,</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>请使用第二种形式的 setState() 来接受一个函数而不是一个对象。 该函数将接收先前的状态作为第一个参数，将此次更新被应用时的 props 做为第二个参数。</p><pre><code>// Correctthis.setState((prevState, props) =&gt; ({  counter: prevState.counter + props.increment}));</code></pre><ol start="3"><li>状态更新合并</li></ol><p>你的状态可能包含一些独立的变量：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">constructor(props) &#123;</span><br><span class="line">  super(props);</span><br><span class="line">  this.state = &#123;</span><br><span class="line">    posts: [],</span><br><span class="line">    comments: []</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>你可以调用 setState() 独立地更新它们：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">componentDidMount() &#123;</span><br><span class="line">  fetchPosts().then(response =&gt; &#123;</span><br><span class="line">    this.setState(&#123;</span><br><span class="line">      posts: response.posts</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  fetchComments().then(response =&gt; &#123;</span><br><span class="line">    this.setState(&#123;</span><br><span class="line">      comments: response.comments</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="事件绑定"><a href="#事件绑定" class="headerlink" title="事件绑定"></a>事件绑定</h2><blockquote><p>由于类的方法默认不会绑定 this，因此在调用的时候如果忘记绑定，this 的值将会是 undefined。<br>通常如果不是直接调用，应该为方法绑定 this。绑定方式有以下几种：</p></blockquote><ol><li><p>在构造函数中使用 bind 绑定 this</p><pre><code>class Button extends React.Component {constructor(props) {    super(props);    this.handleClick = this.handleClick.bind(this);  }  handleClick(){    console.log(&apos;this is:&apos;, this);  }  render() {    return (      &lt;button onClick={this.handleClick}&gt;        Click me      &lt;/button&gt;    );  }}</code></pre></li><li><p>在调用的时候使用 bind 绑定 this</p><pre><code>class Button extends React.Component {  handleClick(){    console.log(&apos;this is:&apos;, this);  }  render() {    return (      &lt;button onClick={this.handleClick.bind(this)}&gt;        Click me      &lt;/button&gt;    );  }}</code></pre></li><li><p>在调用的时候使用箭头函数绑定 this</p><pre><code>class Button extends React.Component {  handleClick(){    console.log(&apos;this is:&apos;, this);  }  render() {    return (      &lt;button onClick={()=&gt;this.handleClick()}&gt;        Click me      &lt;/button&gt;    );  }}</code></pre></li><li><p>使用属性初始化器语法绑定 this(实验性)</p><pre><code>class Button extends React.Component {  handleClick=()=&gt;{    console.log(&apos;this is:&apos;, this);  }  render() {    return (      &lt;button onClick={this.handleClick}&gt;        Click me      &lt;/button&gt;    );  }}</code></pre></li></ol><h2 id="条件渲染"><a href="#条件渲染" class="headerlink" title="条件渲染"></a>条件渲染</h2><ol><li><p>包含三目运算符的条件渲染<br>例子：</p><pre><code>class HelloWord extends React.Component {    constructor(props) {        super(props);        this.state = {            show: false        }    }    // 渲染函数，this 指向实例本身    render() {        let display = this.display.bind(this)        return &lt;div&gt;            {/* 这种方法省略了 this 绑定的过程 */}            &lt;button onClick={display}&gt;{this.state.show ? &apos;点击隐藏&apos; : &apos;点击显示&apos;}&lt;/button&gt;            {                this.state.show                    ?                    &lt;p&gt;显示出来啦&lt;/p&gt;                    :                    null            }        &lt;/div&gt;    }    display() {        this.setState({            show: !this.state.show        })    }}</code></pre></li><li><p>与（&amp;&amp;）运算符的条件渲染</p><pre><code>function Mailbox(props) {  const unreadMessages = props.unreadMessages;  return (    &lt;div&gt;      &lt;h1&gt;Hello!&lt;/h1&gt;      {unreadMessages.length &gt; 0 &amp;&amp;        &lt;h2&gt;          You have {unreadMessages.length} unread messages.        &lt;/h2&gt;      }    &lt;/div&gt;  );}const messages = [&apos;React&apos;, &apos;Re: React&apos;, &apos;Re:Re: React&apos;];ReactDOM.render(  &lt;Mailbox unreadMessages={messages} /&gt;,  document.getElementById(&apos;root&apos;));</code></pre></li></ol><p>之所以能这样做，是因为在 JavaScript 中，<code>true &amp;&amp; expression</code> 总是返回 <code>expression</code>，而 <code>false &amp;&amp; expression</code> 总是返回 <code>false。</code></p><p>因此，如果条件是 true，&amp;&amp; 右侧的元素就会被渲染，如果是 false，React 会忽略并跳过它。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;安装&quot;&gt;&lt;a href=&quot;#安装&quot; class=&quot;headerlink&quot; title=&quot;安装&quot;&gt;&lt;/a&gt;安装&lt;/h2&gt;&lt;pre&gt;&lt;code&gt;npm install -g create-react-app
create-react-app my-app
cd my-app
npm start
&lt;/code&gt;&lt;/pre&gt;
    
    </summary>
    
      <category term="web" scheme="http://yaliixxg.github.io/categories/web/"/>
    
    
      <category term="react" scheme="http://yaliixxg.github.io/tags/react/"/>
    
  </entry>
  
  <entry>
    <title>前端性能优化</title>
    <link href="http://yaliixxg.github.io/2018/07/27/optimization/"/>
    <id>http://yaliixxg.github.io/2018/07/27/optimization/</id>
    <published>2018-07-27T03:27:34.000Z</published>
    <updated>2018-07-27T06:22:46.781Z</updated>
    
    <content type="html"><![CDATA[<h2 id="减少HTTP请求"><a href="#减少HTTP请求" class="headerlink" title="减少HTTP请求"></a>减少HTTP请求</h2><ul><li><p>图片地图  </p><ul><li>就是把页面上用到的多个图片合并成一张图片，利用map控制显示的位置，接着在这张图片上关联多个URL，加载的时候就只要发送一次HTTP请求获取这张图片就行了。（相关实例可以网上自行搜索）  </li><li>CSS Sprites合并图片，精灵图  </li><li>内联图片，浏览器不会缓存这种图像。dataurl节省了HTTP请求,但是如果这个图像在网页多个地方显示会加大网页的内容，延长下载时间。还有一点IE8以下都不支持这种图像,所以一般不用。</li><li>合并脚本和样式表，尽量减少js和css的请求数量   <a id="more"></a> </li></ul></li><li><p>使用内容发布网络（CDN）  </p><ul><li>CDN发布的内容主要是静态内容，如图片、脚本、样式表和Flash。主要是静态内容更容易存储且具有较少的依赖性。  </li></ul></li><li><p>添加Expires头  </p><ul><li><p>这个规则主要是针对缓存的，使用缓存来减少加载组件的数量，不是针对首次访问的优化，但是对于多次浏览的响应时间的优化还是巨大的。通过使用一个长久的Expires头，可以使需要缓存的组件被缓存，这会在后续的页面浏览中避免不必要的HTTP请求。  </p><pre><code>Expires: Mon, 15 Apr 2024 20:20:20 GMT </code></pre><p>这是一个有效期非常长久的Expires头，它告诉浏览器该响应的有效期持续到2024年4月15日为止。如果为页面中的一个图片返回了这个头，浏览器在后续的页面浏览中会使用缓存的图片。<br>Expires存在限制，要求服务器和客户端的时间严格同步，过期日期需要检查，并提供新日期，所以还有另外一种选择，cache-control使用max-age指令指定用户被缓存多久，达到的效果也是一样的  </p></li></ul></li><li><p>压缩组件  </p><ul><li>就是启用Gzip压缩，压缩文档、脚本、样式表，传输的大小变小了，响应时间自然就减少了。  </li></ul></li><li><p>将样式表放在顶部   </p></li><li><p>将脚本放在底部  </p><ul><li>在下载脚本时浏览器会阻塞并行下载，如果放在上面的话有可能要等到页面加载完成才能看到界面的整体效果，这对用户体验是很差的  </li></ul></li><li><p>避免CSS表达式   </p><ul><li>表达式的问题在于对其进行的求值，它们不只在页面呈现和大小改变时求值，当页面滚动、甚至用户鼠标在页面上移过时都要被求值。所以对页面的性能影响是很大的。<br>CSS3提供了calc()函数，可以用来实现css的一些求值运算。  </li></ul></li></ul><p>下面是表达式例子：</p><pre><code>#myDiv {position: absolute;width: 100px;height: 100px;background:#c00;left: expression(document.body.offsetWidth - 180   &quot;px&quot;);top: expression(document.body.offsetHeight - -80   &quot;px&quot;);text-align:center;line-height:90px;color:#fff;}  </code></pre><p>calc() 函数用于动态计算长度值。</p><p>calc() = calc(四则运算)  </p><p>需要注意的是，运算符前后都需要保留一个空格，例如：width: calc(100% - 10px)；  </p><p>任何长度值都可以使用calc()函数进行计算；  </p><p>calc()函数支持 “+”, “-“, “*”, “/“ 运算；  </p><p>calc()函数使用标准的数学运算优先级规则；  </p><ul><li>使用外部的JS和CSS  <ul><li>因为外部的JS和CSS是可以被缓存的，而如果是内联的话就要每次都要加载。  </li></ul></li><li><p>减少DNS查找  </p><ul><li>方法：通过使用Keep-Alive和较少的域名来减少DNS查找</li></ul></li><li><p>精简JS，相当于压缩，且会除去注释及空格</p></li><li>避免重定向。重定向会延迟整个HTML文档的传输</li><li>移除重复脚本</li><li>配置或移除Etag</li><li>使用Ajax可缓存。确保ajax请求遵守性能指导，尤其应具有长久的expires头</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;减少HTTP请求&quot;&gt;&lt;a href=&quot;#减少HTTP请求&quot; class=&quot;headerlink&quot; title=&quot;减少HTTP请求&quot;&gt;&lt;/a&gt;减少HTTP请求&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;图片地图  &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;就是把页面上用到的多个图片合并成一张图片，利用map控制显示的位置，接着在这张图片上关联多个URL，加载的时候就只要发送一次HTTP请求获取这张图片就行了。（相关实例可以网上自行搜索）  &lt;/li&gt;
&lt;li&gt;CSS Sprites合并图片，精灵图  &lt;/li&gt;
&lt;li&gt;内联图片，浏览器不会缓存这种图像。dataurl节省了HTTP请求,但是如果这个图像在网页多个地方显示会加大网页的内容，延长下载时间。还有一点IE8以下都不支持这种图像,所以一般不用。&lt;/li&gt;
&lt;li&gt;合并脚本和样式表，尽量减少js和css的请求数量&lt;/li&gt;&lt;/ul&gt;&lt;/li&gt;&lt;/ul&gt;
    
    </summary>
    
      <category term="web" scheme="http://yaliixxg.github.io/categories/web/"/>
    
    
      <category term="性能优化" scheme="http://yaliixxg.github.io/tags/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/"/>
    
  </entry>
  
  <entry>
    <title>最常见的前端面试题</title>
    <link href="http://yaliixxg.github.io/2018/07/27/caseInterview/"/>
    <id>http://yaliixxg.github.io/2018/07/27/caseInterview/</id>
    <published>2018-07-27T02:59:26.000Z</published>
    <updated>2018-07-27T03:25:06.586Z</updated>
    
    <content type="html"><![CDATA[<p>持续更新 (*❦ω❦)</p><h2 id="盒子模型"><a href="#盒子模型" class="headerlink" title="盒子模型"></a>盒子模型</h2><ul><li>在标准模式下，一个块的总宽度= width + margin(左右) + padding(左右) + border(左右)  </li><li>在怪异模式(IE)下，一个块的总宽度= width + margin(左右)（即width已经包含了padding和border值）<a id="more"></a>  </li></ul><h2 id="position包含几种属性？absolute和relative的区别？"><a href="#position包含几种属性？absolute和relative的区别？" class="headerlink" title="position包含几种属性？absolute和relative的区别？"></a>position包含几种属性？absolute和relative的区别？</h2><ul><li>static：默认状态、没有定位、正常流 </li><li>inherit：从父元素集成position属性的值</li><li>fixed：生成绝对定位的元素（相对于浏览器窗口进行定位）</li><li>absolute：生成绝对定位的元素（相位与static定位以外的第一个父元素定位）</li><li>relative：生成相对定位的元素（相对于其正常位置定位）<blockquote><p>absolute和relative区别：父元素的padding对relative的子元素布局有影响，absolute的子元素不受影响  </p></blockquote></li></ul><h2 id="前端性能优化"><a href="#前端性能优化" class="headerlink" title="前端性能优化"></a>前端性能优化</h2><blockquote><p>减少HTTP请求、使用内容发布网络、压缩组件、使用Expire头、JS放底部、CSS放顶部、避免CSS表达式等。（详情见web前端性能优化）</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;持续更新 (*❦ω❦)&lt;/p&gt;
&lt;h2 id=&quot;盒子模型&quot;&gt;&lt;a href=&quot;#盒子模型&quot; class=&quot;headerlink&quot; title=&quot;盒子模型&quot;&gt;&lt;/a&gt;盒子模型&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;在标准模式下，一个块的总宽度= width + margin(左右) + padding(左右) + border(左右)  &lt;/li&gt;
&lt;li&gt;在怪异模式(IE)下，一个块的总宽度= width + margin(左右)（即width已经包含了padding和border值）&lt;/li&gt;&lt;/ul&gt;
    
    </summary>
    
      <category term="web" scheme="http://yaliixxg.github.io/categories/web/"/>
    
    
      <category term="前端面试题" scheme="http://yaliixxg.github.io/tags/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title></title>
    <link href="http://yaliixxg.github.io/2018/07/23/eventLoop/"/>
    <id>http://yaliixxg.github.io/2018/07/23/eventLoop/</id>
    <published>2018-07-23T03:18:46.181Z</published>
    <updated>2018-07-23T03:33:27.927Z</updated>
    
    <content type="html"><![CDATA[<hr><p>title: eventLoop<br>date: 2018-07-23 11:18:46<br>tags: 事件循环 event loop </p><h2 id="categories-web"><a href="#categories-web" class="headerlink" title="categories: web"></a>categories: web</h2><p>微任务（<code>microtask</code>）称为 <code>jobs</code> 。包括 <code>process.nextTick</code> ，<code>promise</code> ，<code>Object.observe</code> ，<code>MutationObserver</code>  </p><p>宏任务（<code>macrotask）</code>称为 <code>task</code> 。包括 <code>script</code> ， <code>setTimeout</code> ，<code>setInterval</code> ，<code>setImmediate</code> ，<code>I/O</code> ，<code>UI rendering</code>  </p><h2 id="Event-loop-执行顺序"><a href="#Event-loop-执行顺序" class="headerlink" title="Event loop 执行顺序"></a>Event loop 执行顺序</h2><ol><li>执行同步代码，这属于宏任务</li><li>执行栈为空，查询是否有微任务需要执行</li><li>执行所有微任务</li><li>必要的话渲染 <code>UI</code></li><li>然后开始下一轮 <code>Event loop</code>，执行宏任务中的异步代码  </li></ol><p>很多人有个误区，认为微任务快于宏任务，其实是错误的。因为宏任务中包括了 <code>script</code> ，浏览器会先执行一个宏任务，接下来有异步代码的话就先执行微任务。  </p><p>通过上述的 <code>Event loop</code> 顺序可知，如果宏任务中的异步代码有大量的计算并且需要操作 <code>DOM</code> 的话，为了更快的界面响应，我们可以把操作 <code>DOM</code> 放入微任务中。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;hr&gt;
&lt;p&gt;title: eventLoop&lt;br&gt;date: 2018-07-23 11:18:46&lt;br&gt;tags: 事件循环 event loop &lt;/p&gt;
&lt;h2 id=&quot;categories-web&quot;&gt;&lt;a href=&quot;#categories-web&quot; class=
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>跨域</title>
    <link href="http://yaliixxg.github.io/2018/07/23/kuayu/"/>
    <id>http://yaliixxg.github.io/2018/07/23/kuayu/</id>
    <published>2018-07-23T01:32:02.000Z</published>
    <updated>2018-07-23T02:04:21.324Z</updated>
    
    <content type="html"><![CDATA[<h2 id="什么是同源策略？"><a href="#什么是同源策略？" class="headerlink" title="什么是同源策略？"></a>什么是同源策略？</h2><p>同源策略，它是由Netscape提出的一个著名的安全策略。<br>现在所有支持JavaScript 的浏览器都会使用这个策略。<br>所谓同源是指，域名，协议，端口相同。<br>因为浏览器出于安全考虑，有同源策略。也就是说，如果协议、域名或者端口有一个不同就是跨域，Ajax 请求会失败。<br><a id="more"></a> </p><h2 id="JSONP"><a href="#JSONP" class="headerlink" title="JSONP"></a>JSONP</h2><p><code>JSONP</code> 的原理很简单，就是利用 <code>&lt;script&gt;</code> 标签没有跨域限制的漏洞。通过 <code>&lt;script&gt;</code> 标签指向一个需要访问的地址并提供一个回调函数来接收数据当需要通讯时。  </p><pre><code>&lt;script src=&quot;http://domain/api?param1=a&amp;param2=b&amp;callback=jsonp&quot;&gt;&lt;/script&gt;&lt;script&gt;    function jsonp(data) {        console.log(data)    }&lt;/script&gt;    </code></pre><p><code>JSONP</code> 使用简单且兼容性不错，但是只限于 <code>get</code> 请求。  </p><h2 id="封装JSONP"><a href="#封装JSONP" class="headerlink" title="封装JSONP"></a>封装JSONP</h2><pre><code>function jsonp(url,jsonpCallback,success){    let script = document.creatElement(&quot;script&quot;);    script.src = url;    script.async = true;    script.type = &quot;text/javascript&quot;;    window[jsonpCallback] = function(data){        success &amp; success(data);    };    document.body.appendChild(script);}  jsonp(&quot;http://xxx&quot;,&quot;callback&quot;,function(value) {    console.log(value);});  </code></pre><h2 id="CORS"><a href="#CORS" class="headerlink" title="CORS"></a>CORS</h2><p><code>CORS</code>需要浏览器和后端同时支持。IE 8 和 9 需要通过 XDomainRequest 来实现。</p><p>浏览器会自动进行 <code>CORS</code> 通信，实现CORS通信的关键是后端。只要后端实现了 <code>CORS</code>，就实现了跨域。</p><p>服务端设置 <code>Access-Control-Allow-Origin</code> 就可以开启 <code>CORS</code>。 该属性表示哪些域名可以访问资源，如果设置通配符则表示所有网站都可以访问资源。  </p><h2 id="postMessage"><a href="#postMessage" class="headerlink" title="postMessage"></a>postMessage</h2><p>这种方式通常用于获取嵌入页面中的第三方页面数据。一个页面发送消息，另一个页面判断来源并接收消息  </p><pre><code>// 发送消息端window.parent.postMessage(&apos;message&apos;, &apos;http://test.com&apos;);// 接收消息端var mc = new MessageChannel();mc.addEventListener(&apos;message&apos;, (event) =&gt; {    var origin = event.origin || event.originalEvent.origin;     if (origin === &apos;http://test.com&apos;) {        console.log(&apos;验证通过&apos;)    }});</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;什么是同源策略？&quot;&gt;&lt;a href=&quot;#什么是同源策略？&quot; class=&quot;headerlink&quot; title=&quot;什么是同源策略？&quot;&gt;&lt;/a&gt;什么是同源策略？&lt;/h2&gt;&lt;p&gt;同源策略，它是由Netscape提出的一个著名的安全策略。&lt;br&gt;现在所有支持JavaScript 的浏览器都会使用这个策略。&lt;br&gt;所谓同源是指，域名，协议，端口相同。&lt;br&gt;因为浏览器出于安全考虑，有同源策略。也就是说，如果协议、域名或者端口有一个不同就是跨域，Ajax 请求会失败。&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="web" scheme="http://yaliixxg.github.io/categories/web/"/>
    
    
      <category term="跨域 JSONP" scheme="http://yaliixxg.github.io/tags/%E8%B7%A8%E5%9F%9F-JSONP/"/>
    
  </entry>
  
  <entry>
    <title>created mounted 更新获取DOM问题</title>
    <link href="http://yaliixxg.github.io/2018/07/19/lifecicle/"/>
    <id>http://yaliixxg.github.io/2018/07/19/lifecicle/</id>
    <published>2018-07-19T09:12:05.000Z</published>
    <updated>2018-07-19T09:45:54.633Z</updated>
    
    <content type="html"><![CDATA[<p>口水记录一个问题。 ┓(;´_｀)┏ </p><p>写代码的时候，遇到一个问题，就是在<code>created</code>里面调用接口获取数据，利用<code>v-for</code>渲染<code>DOM</code>后，再在<code>mounted</code>里面调用渲染后的<code>DOM</code>时，一直无法获取到，显示为<code>undefined</code>。<br><a id="more"></a></p><p>按照<code>VUE</code>的生命周期来说  </p><blockquote><ul><li><code>created</code> 组件实例创建完成，属性已绑定，但<code>DOM</code>还未生成，<code>$el</code>属性还不存在。  </li><li><code>mounted</code>模板编译/挂载之后。  </li></ul></blockquote><p>按道理，在<code>mounted</code>里面是可以获取到<code>created</code>阶段渲染的<code>DOM</code>的。后来通过<code>console.log()</code>来进行判断，发现在<code>mounted</code>里面的代码开始执行时，<code>created</code>阶段的<code>DOM</code>渲染还未完成。  </p><p>把<code>mounted</code>改为<code>updated</code>，<code>DOM</code>是可以获取到的，但是由于我的代码中涉及到倒计时等频繁更新<code>DOM</code>的状态，所以放弃了<code>updated</code>的这个方法。  </p><blockquote><ul><li><code>updated</code>  组件更新之后</li></ul></blockquote><p>后来通过查阅文档发现，有一个方法可以解决这种问题，调用<code>$nextTick</code>这个<code>vue</code>的全局方法。即在<code>mounted</code>里面调用此方法，用于<code>DOM</code>加载更新完后进行的一次回调函数性质的操作。  </p><pre><code>mounted(){    this.$nextTick(_=&gt;{        //你的代码部分    })}</code></pre><p>但是很可悲 = = ，我的<code>created</code>里渲染的<code>DOM</code>还是比它要晚执行完，所以获取<code>DOM</code>依然是<code>undefined</code>。  </p><p>最后用了一个简单粗暴的方法解决了此问题。  </p><pre><code>mounted() {    setTimeout(_ =&gt; {    //你的代码部分    }, 1000);}  </code></pre><p> (o°ω°o) </p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;口水记录一个问题。 ┓(;´_｀)┏ &lt;/p&gt;
&lt;p&gt;写代码的时候，遇到一个问题，就是在&lt;code&gt;created&lt;/code&gt;里面调用接口获取数据，利用&lt;code&gt;v-for&lt;/code&gt;渲染&lt;code&gt;DOM&lt;/code&gt;后，再在&lt;code&gt;mounted&lt;/code&gt;里面调用渲染后的&lt;code&gt;DOM&lt;/code&gt;时，一直无法获取到，显示为&lt;code&gt;undefined&lt;/code&gt;。&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="web" scheme="http://yaliixxg.github.io/categories/web/"/>
    
    
      <category term="vue 生命周期" scheme="http://yaliixxg.github.io/tags/vue-%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/"/>
    
  </entry>
  
  <entry>
    <title>Generator知识点</title>
    <link href="http://yaliixxg.github.io/2018/07/17/gntr-SN/"/>
    <id>http://yaliixxg.github.io/2018/07/17/gntr-SN/</id>
    <published>2018-07-17T03:12:05.000Z</published>
    <updated>2018-07-17T06:56:42.809Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Generator"><a href="#Generator" class="headerlink" title="Generator"></a>Generator</h1><p>Generator 函数有多种理解角度。语法上，首先可以把它理解成，Generator 函数是一个状态机，封装了多个内部状态。</p><p>执行 Generator 函数会返回一个遍历器对象，也就是说，Generator 函数除了状态机，还是一个遍历器对象生成函数。返回的遍历器对象，可以依次遍历 Generator 函数内部的每一个状态。  </p><ul><li><p>Generator 函数有两个特征：  </p><ul><li><code>function</code>关键字与函数名之间有一个<code>星号</code></li><li><p>函数体内部使用<code>yield</code>表达式，定义不同的内部状态（<code>yield</code>在英语里的意思就是“产出”）  </p><a id="more"></a><pre><code>function* helloWorldGenerator() {yield &apos;hello&apos;;yield &apos;world&apos;;return &apos;ending&apos;;}var hw = helloWorldGenerator(); hw.next()// { value: &apos;hello&apos;, done: false } value属性就是当前yield表达式的值，done属性为false，表示遍历还没有结束。hw.next()// { value: &apos;world&apos;, done: false }hw.next()// { value: &apos;ending&apos;, done: true }hw.next()// { value: undefined, done: true } done属性为true，表示遍历已经结束。   </code></pre></li></ul></li></ul><p>上面代码定义了一个 Generator 函数<code>helloWorldGenerator</code>，它内部有两个<code>yield</code>表达式（<code>hello</code>和<code>world</code>），即该函数有三个状态：hello，world 和 return 语句（结束执行）。<br>调用方法与普通函数一样，但是调用，函数并不执行，返回一个指向内部状态的指针对象，也就是遍历器对象。<br>必须调用遍历器对象的<code>next</code>方法，使得指针移向下一个状态。内部指针就从函数头部或上一次停下来的地方开始执行，直到遇到下一个<code>yield</code>表达式（或<code>return</code>语句）为止。<br>换言之，Generator 函数是分段执行的，<code>yield</code>表达式是暂停执行的标记，而<code>next</code>方法可以恢复执行。  </p><h2 id="yield-表达式"><a href="#yield-表达式" class="headerlink" title="yield 表达式"></a>yield 表达式</h2><p>由于 Generator 函数返回的遍历器对象，只有调用<code>next</code>方法才会遍历下一个内部状态，所以其实提供了一种可以暂停执行的函数。<code>yield</code>表达式就是暂停标志。因此等于为 JavaScript 提供了手动的“惰性求值”（Lazy Evaluation）的语法功能。<br><code>yield</code>表达式只能用在 Generator 函数里面，用在其他地方都会报错。</p><h2 id="next-方法的参数"><a href="#next-方法的参数" class="headerlink" title="next 方法的参数"></a>next 方法的参数</h2><p><code>yield</code>表达式本身没有返回值，或者说总是返回<code>undefined</code>。<code>next</code>方法可以带一个参数，该参数就会被当作上一个<code>yield</code>表达式的返回值。  </p><pre><code>function* foo(x) {var y = 2 * (yield (x + 1));var z = yield (y / 3);return (x + y + z);}var a = foo(5);a.next() // Object{value:6, done:false}a.next() // Object{value:NaN, done:false}a.next() // Object{value:NaN, done:true}var b = foo(5);b.next() // { value:6, done:false }b.next(12) // { value:8, done:false }b.next(13) // { value:42, done:true }  </code></pre><p>上面代码中，第二次运行<code>next</code>方法的时候不带参数，导致 <code>y</code> 的值等于<code>2 * undefined</code>（即<code>NaN</code>），除以 <code>3</code> 以后还是<code>NaN</code>，因此返回对象的<code>value</code>属性也等于<code>NaN</code>。第三次运行<code>Next</code>方法的时候不带参数，所以<code>z</code>等于<code>undefined</code>，返回对象的<code>value</code>属性等于<code>5 + NaN + undefined</code>，即<code>NaN</code>。</p><p>如果向<code>next</code>方法提供参数，返回结果就完全不一样了。上面代码第一次调用b的<code>next</code>方法时，返回<code>x+1</code>的值<code>6</code>；第二次调用<code>next</code>方法，将上一次<code>yield</code>表达式的值设为<code>12</code>，因此<code>y</code>等于<code>24</code>，返回<code>y / 3</code>的值<code>8</code>；第三次调用<code>next</code>方法，将上一次<code>yield</code>表达式的值设为<code>13</code>，因此z等于<code>13</code>，这时<code>x</code>等于<code>5</code>，<code>y</code>等于<code>24</code>，所以<code>return</code>语句的值等于<code>42</code>。</p><p>注意，由于<code>next</code>方法的参数表示上一个<code>yield</code>表达式的返回值，所以在第一次使用<code>next</code>方法时，传递参数是无效的。V8 引擎直接忽略第一次使用<code>next</code>方法时的参数，只有从第二次使用<code>next</code>方法开始，参数才是有效的。从语义上讲，第一个<code>next</code>方法用来启动遍历器对象，所以不用带有参数。  </p><p><code>next</code>方法的参数，也可以向Generator 函数内部输入值  </p><pre><code>function* dataConsumer() {console.log(&apos;Started&apos;);console.log(`1. ${yield}`);console.log(`2. ${yield}`);return &apos;result&apos;;}let genObj = dataConsumer();genObj.next();// StartedgenObj.next(&apos;a&apos;)// 1. agenObj.next(&apos;b&apos;)// 2. b  </code></pre><h2 id="for…of-循环"><a href="#for…of-循环" class="headerlink" title="for…of 循环"></a>for…of 循环</h2><p><code>for...of</code>循环可以自动遍历 Generator 函数时生成的<code>Iterator</code>对象，且此时不再需要调用<code>next</code>方法。</p><pre><code>function* foo() {yield 1;yield 2;yield 3;yield 4;yield 5;return 6; //return语句返回的，不包括在for...of循环之中}for (let v of foo()) {console.log(v);}// 1 2 3 4 5  </code></pre><p>除了<code>for...of</code>循环以外，扩展运算符（<code>...</code>）、解构赋值和<code>Array.from</code>方法内部调用的，都是遍历器接口。这意味着，它们都可以将 Generator 函数返回的 Iterator 对象，作为参数。 </p><pre><code>function* numbers () {yield 1yield 2return 3yield 4}// 扩展运算符[...numbers()] // [1, 2]// Array.from 方法Array.from(numbers()) // [1, 2]// 解构赋值let [x, y] = numbers();x // 1y // 2// for...of 循环for (let n of numbers()) {console.log(n)}// 1// 2  </code></pre><h2 id="Generator-prototype-throw"><a href="#Generator-prototype-throw" class="headerlink" title="Generator.prototype.throw()"></a>Generator.prototype.throw()</h2><p>Generator 函数返回的遍历器对象，都有一个<code>throw</code>方法，可以在函数体外抛出错误，然后在 Generator 函数体内捕获。 </p><pre><code>var g = function* () {try {    yield;} catch (e) {    console.log(&apos;内部捕获&apos;, e);}};var i = g();i.next();try {i.throw(&apos;a&apos;);i.throw(&apos;b&apos;);} catch (e) {console.log(&apos;外部捕获&apos;, e);}// 内部捕获 a// 外部捕获 b  </code></pre><p>一旦执行了<code>catch</code>，捕捉了错误，Generator 函数就已经结束了，不再执行下去了。  </p><h2 id="Generator-prototype-return"><a href="#Generator-prototype-return" class="headerlink" title="Generator.prototype.return()"></a>Generator.prototype.return()</h2><p>Generator 函数返回的遍历器对象，还有一个<code>return</code>方法，可以返回给定的值，并且终结遍历 Generator 函数。  </p><h2 id="next-、throw-、return-的共同点"><a href="#next-、throw-、return-的共同点" class="headerlink" title="next()、throw()、return() 的共同点"></a>next()、throw()、return() 的共同点</h2><p>本质上是同一件事，可以放在一起理解。它们的作用都是让 Generator 函数恢复执行，并且使用不同的语句替换<code>yield</code>表达式。<br><code>next()</code>是将<code>yield</code>表达式替换成一个值。  </p><pre><code>const g = function* (x, y) {let result = yield x + y;return result;};const gen = g(1, 2);gen.next(); // Object {value: 3, done: false}gen.next(1); // Object {value: 1, done: true}// 相当于将 let result = yield x + y// 替换成 let result = 1;  </code></pre><p><code>throw()</code>是将<code>yield</code>表达式替换成一个<code>throw</code>语句。  </p><pre><code>gen.throw(new Error(&apos;出错了&apos;)); // Uncaught Error: 出错了// 相当于将 let result = yield x + y// 替换成 let result = throw(new Error(&apos;出错了&apos;));  </code></pre><p><code>return()</code>是将<code>yield</code>表达式替换成一个<code>return</code>语句。  </p><pre><code>gen.return(2); // Object {value: 2, done: true}// 相当于将 let result = yield x + y// 替换成 let result = return 2;  </code></pre><h2 id="yield-表达式-1"><a href="#yield-表达式-1" class="headerlink" title="yield* 表达式"></a>yield* 表达式</h2><p>如果在 Generator 函数内部，调用另一个 Generator 函数，默认情况下是没有效果的。<code>yield*</code>表达式，用来在一个 Generator 函数里面执行另一个 Generator 函数。</p><pre><code>function* foo() {yield &apos;a&apos;;yield &apos;b&apos;;}//普通方法调用foo() ==========================function* bar() {yield &apos;x&apos;;foo(); yield &apos;y&apos;;}for (let v of bar()){console.log(v);}// &quot;x&quot;// &quot;y&quot;  //上面foo()的调用是没有效果的//yield*表达式调用 =================================function* bar() {yield &apos;x&apos;;yield* foo();yield &apos;y&apos;;}// 等同于function* bar() {yield &apos;x&apos;;yield &apos;a&apos;;yield &apos;b&apos;;yield &apos;y&apos;;}// 等同于function* bar() {yield &apos;x&apos;;for (let v of foo()) {    yield v;}yield &apos;y&apos;;}for (let v of bar()){console.log(v);}// &quot;x&quot;// &quot;a&quot;// &quot;b&quot;// &quot;y&quot;</code></pre><p>从语法角度看，如果<code>yield</code>表达式后面跟的是一个遍历器对象，需要在yield表达式后面加上星号，表明它返回的是一个遍历器对象。这被称为<code>yield*</code>表达式。  </p><p><code>yield*</code>后面的 Generator 函数（没有return语句时），等同于在 Generator 函数内部，部署一个<code>for...of</code>循环。</p><pre><code>function* concat(iter1, iter2) {yield* iter1;yield* iter2;}// 等同于function* concat(iter1, iter2) {for (var value of iter1) {    yield value;}for (var value of iter2) {    yield value;}}  </code></pre><p>上面代码说明，<code>yield*</code>后面的 Generator 函数（没有<code>return</code>语句时），不过是<code>for...of</code>的一种简写形式，完全可以用后者替代前者。反之，在有<code>return</code>语句时，则需要用<code>var value = yield* iterator</code>的形式获取<code>return</code>语句的值。</p><h4 id="实际上，任何数据结构只要有-Iterator-接口，就可以被yield-遍历。"><a href="#实际上，任何数据结构只要有-Iterator-接口，就可以被yield-遍历。" class="headerlink" title="实际上，任何数据结构只要有 Iterator 接口，就可以被yield*遍历。"></a>实际上，任何数据结构只要有 Iterator 接口，就可以被yield*遍历。</h4><p><code>yield*</code>命令可以很方便地取出嵌套数组的所有成员。</p><pre><code>function* iterTree(tree) {if (Array.isArray(tree)) {    for(let i=0; i &lt; tree.length; i++) {    yield* iterTree(tree[i]);    }} else {    yield tree;}}const tree = [ &apos;a&apos;, [&apos;b&apos;, &apos;c&apos;], [&apos;d&apos;, &apos;e&apos;] ];for(let x of iterTree(tree)) {console.log(x);}// a// b// c// d// e </code></pre><h2 id="Generator-函数的this"><a href="#Generator-函数的this" class="headerlink" title="Generator 函数的this"></a>Generator 函数的this</h2><p>Generator 函数g返回的遍历器<code>obj</code>，是g的实例，而且继承了<code>g.prototype</code>。但是，如果把g当作普通的构造函数，并不会生效，因为g返回的总是遍历器对象，而不是<code>this</code>对象,也不能跟new命令一起用，会报错。  </p><p>下面是一个变通方法。首先，生成一个空对象，使用<code>call</code>方法绑定 Generator 函数内部的this。这样，构造函数调用以后，这个空对象就是 Generator 函数的实例对象了。  </p><pre><code>function* F() {this.a = 1;yield this.b = 2;yield this.c = 3;}var obj = {};var f = F.call(obj);f.next();  // Object {value: 2, done: false}f.next();  // Object {value: 3, done: false}f.next();  // Object {value: undefined, done: true}obj.a // 1obj.b // 2obj.c // 3  </code></pre><p>还有一个办法就是将obj换成<code>F.prototype</code>。</p><pre><code>function* F() {this.a = 1;yield this.b = 2;yield this.c = 3;}var f = F.call(F.prototype);f.next();  // Object {value: 2, done: false}f.next();  // Object {value: 3, done: false}f.next();  // Object {value: undefined, done: true}f.a // 1f.b // 2f.c // 3  </code></pre><p>再将F改成构造函数，就可以对它执行<code>new</code>命令了。</p><pre><code>function* gen() {this.a = 1;yield this.b = 2;yield this.c = 3;}function F() {return gen.call(gen.prototype);}var f = new F();f.next();  // Object {value: 2, done: false}f.next();  // Object {value: 3, done: false}f.next();  // Object {value: undefined, done: true}f.a // 1f.b // 2f.c // 3</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Generator&quot;&gt;&lt;a href=&quot;#Generator&quot; class=&quot;headerlink&quot; title=&quot;Generator&quot;&gt;&lt;/a&gt;Generator&lt;/h1&gt;&lt;p&gt;Generator 函数有多种理解角度。语法上，首先可以把它理解成，Generator 函数是一个状态机，封装了多个内部状态。&lt;/p&gt;
&lt;p&gt;执行 Generator 函数会返回一个遍历器对象，也就是说，Generator 函数除了状态机，还是一个遍历器对象生成函数。返回的遍历器对象，可以依次遍历 Generator 函数内部的每一个状态。  &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;Generator 函数有两个特征：  &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;function&lt;/code&gt;关键字与函数名之间有一个&lt;code&gt;星号&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;函数体内部使用&lt;code&gt;yield&lt;/code&gt;表达式，定义不同的内部状态（&lt;code&gt;yield&lt;/code&gt;在英语里的意思就是“产出”）  &lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;/li&gt;&lt;/ul&gt;
    
    </summary>
    
      <category term="web" scheme="http://yaliixxg.github.io/categories/web/"/>
    
    
      <category term="Generator" scheme="http://yaliixxg.github.io/tags/Generator/"/>
    
  </entry>
  
  <entry>
    <title>《InterviewMap 面试图谱》总结笔记</title>
    <link href="http://yaliixxg.github.io/2018/07/16/interviewMap-SN/"/>
    <id>http://yaliixxg.github.io/2018/07/16/interviewMap-SN/</id>
    <published>2018-07-16T06:12:05.000Z</published>
    <updated>2018-07-17T09:31:26.857Z</updated>
    
    <content type="html"><![CDATA[<h1 id="一、JavaScript"><a href="#一、JavaScript" class="headerlink" title="一、JavaScript"></a>一、JavaScript</h1><h2 id="七种内置类型"><a href="#七种内置类型" class="headerlink" title="七种内置类型"></a>七种内置类型</h2><ul><li>基本类型  <ul><li>null  </li><li>undefined  </li><li>boolean</li><li>number  </li><li>string  </li><li>symbol  </li></ul></li><li>对象(Object)<br>注意：null是基本类型，但是typeof null会显示object <a id="more"></a> <h2 id="类型转换"><a href="#类型转换" class="headerlink" title="类型转换"></a>类型转换</h2><h3 id="对象转基本类型"><a href="#对象转基本类型" class="headerlink" title="对象转基本类型"></a>对象转基本类型</h3>对象在转换基本类型时，首先会调用 valueOf 然后调用 toString。并且这两个方法你是可以重写的。  <h3 id="操作符"><a href="#操作符" class="headerlink" title="操作符"></a>操作符</h3><img src="/2018/07/16/interviewMap-SN/map1.png" alt="map1">  <h3 id="new"><a href="#new" class="headerlink" title="new"></a>new</h3></li><li>新生成了一个对象</li><li>链接到原型</li><li>绑定 this</li><li>返回新对象  </li></ul><p>对于创建一个对象来说，更推荐使用字面量的方式创建对象（无论性能上还是可读性）。因为你使用 new Object() 的方式创建对象需要通过作用域链一层层找到 Object，但是你使用字面量的方式就没这个问题。  </p><p>对于 new 来说，还需要注意下运算符优先级。  </p><pre><code>function Foo() {    return this;}Foo.getName = function () {    console.log(&apos;1&apos;);};Foo.prototype.getName = function () {    console.log(&apos;2&apos;);};new Foo.getName();   // -&gt; 1new Foo().getName(); // -&gt; 2   </code></pre><p>new Foo()的优先级大于 new Foo，所以对于上述代码来说可以这样划分执行顺序  </p><pre><code>new (Foo.getName());   (new Foo()).getName();</code></pre><p>对于第一个函数来说，先执行了 Foo.getName() ，所以结果为 1；对于后者来说，先执行 new Foo() 产生了一个实例，然后通过原型链找到了 Foo 上的 getName 函数，所以结果为 2。  </p><h2 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h2><p>闭包的定义很简单：函数 A 返回了一个函数 B，并且函数 B 中使用了函数 A 的变量，函数 B 就被称为闭包。</p><h2 id="深浅拷贝"><a href="#深浅拷贝" class="headerlink" title="深浅拷贝"></a>深浅拷贝</h2><pre><code>let a = {    age: 1}let b = aa.age = 2console.log(b.age) // 2  </code></pre><p>从上述例子中我们可以发现，如果给一个变量赋值一个对象，那么两者的值会是同一个引用，其中一方改变，另一方也会相应改变。</p><p>通常在开发中我们不希望出现这样的问题，我们可以使用浅拷贝来解决这个问题。  </p><h3 id="浅拷贝"><a href="#浅拷贝" class="headerlink" title="浅拷贝"></a>浅拷贝</h3><h4 id="object-assign-target-source1-source2-方法用于对象的合并，将源对象（-source-）的所有可枚举属性，复制到目标对象（-target-）。如果目标对象与源对象有同名属性，或多个源对象有同名属性，则后面的属性会覆盖前面的属性。"><a href="#object-assign-target-source1-source2-方法用于对象的合并，将源对象（-source-）的所有可枚举属性，复制到目标对象（-target-）。如果目标对象与源对象有同名属性，或多个源对象有同名属性，则后面的属性会覆盖前面的属性。" class="headerlink" title="object.assign(target, source1, source2) 方法用于对象的合并，将源对象（ source ）的所有可枚举属性，复制到目标对象（ target ）。如果目标对象与源对象有同名属性，或多个源对象有同名属性，则后面的属性会覆盖前面的属性。"></a>object.assign(target, source1, source2) 方法用于对象的合并，将源对象（ source ）的所有可枚举属性，复制到目标对象（ target ）。如果目标对象与源对象有同名属性，或多个源对象有同名属性，则后面的属性会覆盖前面的属性。</h4><pre><code>let a = {    age: 1}let b = Object.assign({}, a)a.age = 2console.log(b.age) // 1  </code></pre><h4 id="我们也可以通过展开运算符（…）来解决"><a href="#我们也可以通过展开运算符（…）来解决" class="headerlink" title="我们也可以通过展开运算符（…）来解决"></a>我们也可以通过展开运算符（…）来解决</h4><pre><code>let a = {    age: 1}let b = {...a}a.age = 2console.log(b.age) // 1  </code></pre><h3 id="深拷贝"><a href="#深拷贝" class="headerlink" title="深拷贝"></a>深拷贝</h3><p>如果拷贝的对象里面还包含对象的话，则需要深拷贝来解决。  </p><h4 id="可以通过-JSON-parse-JSON-stringify-object-来解决。"><a href="#可以通过-JSON-parse-JSON-stringify-object-来解决。" class="headerlink" title="可以通过 JSON.parse(JSON.stringify(object)) 来解决。"></a>可以通过 JSON.parse(JSON.stringify(object)) 来解决。</h4><pre><code>let a = {    age: 1,    jobs: {        first: &apos;FE&apos;    }}let b = JSON.parse(JSON.stringify(a))a.jobs.first = &apos;native&apos;console.log(b.jobs.first) // FE  </code></pre><h4 id="如果你所需拷贝的对象含有内置类型并且不包含函数，可以使用-MessageChannel。（具体搜索实例）"><a href="#如果你所需拷贝的对象含有内置类型并且不包含函数，可以使用-MessageChannel。（具体搜索实例）" class="headerlink" title="如果你所需拷贝的对象含有内置类型并且不包含函数，可以使用 MessageChannel。（具体搜索实例）"></a>如果你所需拷贝的对象含有内置类型并且不包含函数，可以使用 MessageChannel。（具体搜索实例）</h4><h2 id="模块化"><a href="#模块化" class="headerlink" title="模块化"></a>模块化</h2><p>ES6 的模块化(在有 Babel 的情况下使用)。  </p><p>CommonJs 是 Node 独有的规范，浏览器中使用就需要用到 Browserify 解析了。  </p><p>AMD 是由 RequireJS 提出的 </p><h4 id="对于-CommonJS-和-ES6-中的模块化的两者区别是："><a href="#对于-CommonJS-和-ES6-中的模块化的两者区别是：" class="headerlink" title="对于 CommonJS 和 ES6 中的模块化的两者区别是："></a>对于 CommonJS 和 ES6 中的模块化的两者区别是：</h4><ul><li><p>前者支持动态导入，也就是 require(${path}/xx.js)，后者目前不支持，但是已有提案</p></li><li><p>前者是同步导入，因为用于服务端，文件都在本地，同步导入即使卡住主线程影响也不大。而后者是异步导入，因为用于浏览器，需要下载文件，如果也采用导入会对渲染有很大影响</p></li><li><p>前者在导出时都是值拷贝，就算导出的值变了，导入的值也不会改变，所以如果想更新值，必须重新导入一次。但是后者采用实时绑定的方式，导入导出的值都指向同一个内存地址，所以导入值会跟随导出值变化</p></li><li><p>后者会编译成 require/exports 来执行的  </p></li></ul><h4 id="AMD-语法"><a href="#AMD-语法" class="headerlink" title="AMD 语法"></a>AMD 语法</h4><p>requireJS定义了一个函数 define，它是全局变量，用来定义模块</p><p>define(id?, dependencies?, factory);</p><ol><li>id：可选参数，用来定义模块的标识，如果没有提供该参数，脚本文件名（去掉拓展名）</li><li>dependencies：是一个当前模块依赖的模块名称数组</li><li><p>factory：工厂方法，模块初始化要执行的函数或对象。如果为函数，它应该只被执行一次。如果是对象，此对象应该为模块的输出值  </p><pre><code>// AMDdefine([&apos;./a&apos;, &apos;./b&apos;], function(a, b) {    a.do()    b.do()})define(function(require, exports, module) {       var a = require(&apos;./a&apos;)      a.doSomething()       var b = require(&apos;./b&apos;)    b.doSomething()})  </code></pre></li></ol><h2 id="防抖"><a href="#防抖" class="headerlink" title="防抖"></a>防抖</h2><h4 id="将多次执行变为最后一次执行"><a href="#将多次执行变为最后一次执行" class="headerlink" title="将多次执行变为最后一次执行"></a>将多次执行变为最后一次执行</h4><blockquote><p>指频繁触发的情况下，只有足够的空闲时间，才执行代码一次。比如生活中的坐公交，就是一定时间内，如果有人陆续刷卡上车，司机就不会开车。只有别人没刷卡了，司机才开车。 </p><ul><li>对于按钮防点击来说的实现：一旦我开始一个定时器，只要我定时器还在，不管你怎么点击都不会执行回调函数。一旦定时器结束并设置为 null，就可以再次点击了。</li><li>对于延时执行函数来说的实现：每次调用防抖动函数都会判断本次调用和之前的时间间隔，如果小于需要的时间间隔，就会重新创建一个定时器，并且定时器的延时为设定时间减去之前的时间间隔。一旦时间到了，就会执行相应的回调函数。  </li></ul></blockquote><h2 id="节流"><a href="#节流" class="headerlink" title="节流"></a>节流</h2><h4 id="将多次执行变成每隔一段时间执行。"><a href="#将多次执行变成每隔一段时间执行。" class="headerlink" title="将多次执行变成每隔一段时间执行。"></a>将多次执行变成每隔一段时间执行。</h4><blockquote><p>指一定时间内js方法只跑一次。比如人的眨眼睛，就是一定时间内眨一次。这是函数节流最形象的解释。  </p></blockquote><h2 id="继承-（详情见ES6阮一峰-class用法、继承）"><a href="#继承-（详情见ES6阮一峰-class用法、继承）" class="headerlink" title="继承 （详情见ES6阮一峰 class用法、继承）"></a>继承 （详情见ES6阮一峰 class用法、继承）</h2><h2 id="call-apply-bind区别"><a href="#call-apply-bind区别" class="headerlink" title="call,apply,bind区别"></a>call,apply,bind区别</h2><p><code>call</code> 和 <code>apply</code> 都是为了解决改变 this 的指向。作用都是相同的，只是传参的方式不同。<br>除了第一个参数外，call 可以接收一个参数列表，apply 只接受一个参数数组。</p><pre><code>let a = {    value: 1}function getValue(name, age) {    console.log(name)    console.log(age)    console.log(this.value)}getValue.call(a, &apos;yck&apos;, &apos;24&apos;)getValue.apply(a, [&apos;yck&apos;, &apos;24&apos;])  </code></pre><p><code>bind</code>和其他两个方法作用也是一致的，只是该方法会返回一个函数。并且我们可以通过 bind 实现柯里化。<br><code>柯里化</code>是指将使用多个参数的函数转换成一系列使用一个参数的函数的技术。</p><h2 id="Promise-实现-（详情见ES6阮一峰）"><a href="#Promise-实现-（详情见ES6阮一峰）" class="headerlink" title="Promise 实现 （详情见ES6阮一峰）"></a>Promise 实现 （详情见ES6阮一峰）</h2><p>可以把 Promise 看成一个状态机。初始是 <code>pending</code> 状态，可以通过函数 <code>resolve</code> 和 <code>reject</code> ，将状态转变为 resolved(已定型) 或者 rejected(已失败) 状态，状态一旦改变就不能再次变化。<br><code>then</code> 函数会返回一个 Promise 实例，并且该返回值是一个新的实例而不是之前的实例。  </p><h2 id="Generator-实现-详情见另一篇博客《Generator知识点杂烩》"><a href="#Generator-实现-详情见另一篇博客《Generator知识点杂烩》" class="headerlink" title="Generator 实现 (详情见另一篇博客《Generator知识点杂烩》)"></a>Generator 实现 (详情见另一篇博客《Generator知识点杂烩》)</h2><h2 id="Map、FlapMap-和-Reduce"><a href="#Map、FlapMap-和-Reduce" class="headerlink" title="Map、FlapMap 和 Reduce"></a>Map、FlapMap 和 Reduce</h2><p><code>Map</code> 作用是生成一个新数组，遍历原数组，将每个元素拿出来做一些变换然后 <code>append</code> 到新的数组中。</p><pre><code>[1,2,3].map((item)=&gt; item + 1)// -&gt; [2,3,4]  </code></pre><p><code>FlapMap</code> 和 <code>map</code> 的作用几乎是相同的，但是对于多维数组来说，会将原数组降维。可以将 <code>FlapMap</code> 看成是 <code>map + flatten</code> ，目前该函数在浏览器中还不支持。  </p><pre><code>[1, [2], 3].flatMap((v) =&gt; v + 1)// -&gt; [2, 3, 4]</code></pre><p><code>Reduce</code> 作用是数组中的值组合起来，最终得到一个值<br>语法：<code>array.reduce(function(total, currentValue, currentIndex, arr), initialValue)</code>  </p><ul><li>total         必需。初始值, 或者计算结束后的返回值。  </li><li>currentValue  必需。当前元素</li><li>currentIndex  可选。当前元素的索引</li><li>arr           可选。当前元素所属的数组对象。  </li><li>initialValue  可选。传递给函数的初始值  </li></ul><p>如果想将一个多维数组彻底的降维，可以这样实现:  </p><pre><code>const flattenDeep = (arr) =&gt; Array.isArray(arr)? arr.reduce( (a, b) =&gt; [...flattenDeep(a), ...flattenDeep(b)] , []): [arr]flattenDeep([1, [[2], [3, [4]], 5]])  </code></pre>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;一、JavaScript&quot;&gt;&lt;a href=&quot;#一、JavaScript&quot; class=&quot;headerlink&quot; title=&quot;一、JavaScript&quot;&gt;&lt;/a&gt;一、JavaScript&lt;/h1&gt;&lt;h2 id=&quot;七种内置类型&quot;&gt;&lt;a href=&quot;#七种内置类型&quot; class=&quot;headerlink&quot; title=&quot;七种内置类型&quot;&gt;&lt;/a&gt;七种内置类型&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;基本类型  &lt;ul&gt;
&lt;li&gt;null  &lt;/li&gt;
&lt;li&gt;undefined  &lt;/li&gt;
&lt;li&gt;boolean&lt;/li&gt;
&lt;li&gt;number  &lt;/li&gt;
&lt;li&gt;string  &lt;/li&gt;
&lt;li&gt;symbol  &lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;对象(Object)&lt;br&gt;注意：null是基本类型，但是typeof null会显示object&lt;/li&gt;&lt;/ul&gt;
    
    </summary>
    
      <category term="web" scheme="http://yaliixxg.github.io/categories/web/"/>
    
    
      <category term="面试" scheme="http://yaliixxg.github.io/tags/%E9%9D%A2%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>《webpack文档》学习笔记</title>
    <link href="http://yaliixxg.github.io/2018/07/13/wbpk-SN/"/>
    <id>http://yaliixxg.github.io/2018/07/13/wbpk-SN/</id>
    <published>2018-07-13T01:18:00.000Z</published>
    <updated>2018-07-13T03:47:47.047Z</updated>
    
    <content type="html"><![CDATA[<h1 id="webpack"><a href="#webpack" class="headerlink" title="webpack"></a>webpack</h1><p>是一个现代 JavaScript 应用程序的静态模块打包器(module bundler)。当 webpack 处理应用程序时，它会递归地构建一个依赖关系图(dependency graph)，其中包含应用程序需要的每个模块，然后将所有这些模块打包成一个或多个 bundle。  </p><ul><li>入口(entry)</li><li>输出(output)</li><li>loader</li><li>插件(plugins)  <a id="more"></a></li></ul><h2 id="入口"><a href="#入口" class="headerlink" title="入口"></a>入口</h2><p>入口起点(entry point)指示 webpack 应该使用哪个模块，来作为构建其内部依赖图的开始。进入入口起点后，webpack 会找出有哪些模块和库是入口起点（直接和间接）依赖的。  </p><h3 id="单个入口简写语法："><a href="#单个入口简写语法：" class="headerlink" title="单个入口简写语法："></a>单个入口简写语法：</h3><p>  webpack.config.js  </p><pre><code>const config = {  entry: {    main: &apos;./path/to/my/entry/file.js&apos;  }};  </code></pre><h3 id="对象语法"><a href="#对象语法" class="headerlink" title="对象语法"></a>对象语法</h3><p> 1.分离应用程序(app)和第三方库(vendor)入口   </p><p>  webpack.config.js  </p><pre><code>const config = { entry: { app: &apos;./src/app.js&apos;, vendors: &apos;./src/vendors.js&apos; }}; </code></pre><p>2.多页面应用程序  </p><p>webpack.config.js  </p><pre><code>const config = { entry: { pageOne: &apos;./src/pageOne/index.js&apos;, pageTwo: &apos;./src/pageTwo/index.js&apos;, pageThree: &apos;./src/pageThree/index.js&apos; }}; </code></pre><p>这是我们告诉webpack需要三个独立分离的依赖图  </p><h2 id="输出"><a href="#输出" class="headerlink" title="输出"></a>输出</h2><p>output 属性告诉 webpack 在哪里输出它所创建的 bundles，以及如何命名这些文件，默认值为 ./dist。基本上，整个应用程序结构，都会被编译到你指定的输出路径的文件夹中。你可以通过在配置中指定一个 output 字段，来配置这些处理过程。  </p><h3 id="用法"><a href="#用法" class="headerlink" title="用法"></a>用法</h3><p>在 webpack 中配置 output 属性的最低要求是，将它的值设置为一个对象，包括以下两点：</p><ul><li>filename 用于输出文件的文件名。</li><li><p>目标输出目录 path 的绝对路径。  </p><p>webpack.config.js  </p><pre><code>const config = {      output: {        filename: &apos;bundle.js&apos;,        path: &apos;/home/proj/public/assets&apos;      }    };module.exports = config;</code></pre></li></ul><p>此配置将一个单独的 bundle.js 文件输出到 /home/proj/public/assets 目录中。  </p><h3 id="多个入口起点"><a href="#多个入口起点" class="headerlink" title="多个入口起点"></a>多个入口起点</h3><pre><code>{    entry:{        app:&apos;./src/app.js&apos;,        search:&apos;./src/search.js&apos;    },    output:{        filename:&apos;[name].js&apos;,        path: __dirname + &apos;/dist&apos;    }}//写入到硬盘：./dist/app.js,./dist/search.js </code></pre><h3 id="高级进阶"><a href="#高级进阶" class="headerlink" title="高级进阶"></a>高级进阶</h3><p>使用CDN和资源hash的复杂示例<br>config.js  </p><pre><code>output:{    path:&apos;home/proj/cdn/assets/[hash]&apos;,    publicPath:&apos;http://cdn.example.com/assets/[hash]/&apos;} </code></pre><p>在编译时不知道最终输出文件的 publicPath 的情况下，publicPath 可以留空，并且在入口起点文件运行时动态设置。如果你在编译时不知道 publicPath，你可以先忽略它，并且在入口起点设置 <strong>webpack_public_path</strong>。  </p><pre><code>__webpack_public_path__ = myRuntimePublicPath// 剩余的应用程序入口</code></pre><h2 id="loader"><a href="#loader" class="headerlink" title="loader"></a>loader</h2><p>loader 用于对模块的源代码进行转换。loader 可以使你在 import 或”加载”模块时预处理文件。因此，loader 类似于其他构建工具中“任务(task)”，并提供了处理前端构建步骤的强大方法。loader 可以将文件从不同的语言（如 TypeScript）转换为 JavaScript，或将内联图像转换为 data URL。loader 甚至允许你直接在 JavaScript 模块中 import CSS文件!  </p><h3 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h3><p>三种使用loader的方式：</p><ul><li>配置（推荐）：在 webpack.config.js 文件中指定 loader。  </li><li>内联：在每个 import 语句中显式指定 loader。（具体看文档）</li><li>CLI：在 shell 命令中指定它们。 （具体看文档）  </li></ul><h3 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h3><p>module.rules 允许你在 webpack 配置中指定多个 loader。 这是展示 loader 的一种简明方式，并且有助于使代码变得简洁。同时让你对各个 loader 有个全局概览：  </p><pre><code>module:{        rules:[            {                test:/\.css$/,                use:[                    {loader:&apos;style-loader&apos;},                    {                        loader:&apos;css-loader&apos;,                        options:{                            modules:true                        }                    }                ]            }        ]    }//loader 能够使用 options 对象进行配置。</code></pre><h2 id="插件"><a href="#插件" class="headerlink" title="插件"></a>插件</h2><p>插件是 webpack 的支柱功能。webpack 自身也是构建于，你在 webpack 配置中用到的相同的插件系统之上！</p><p>插件目的在于解决 loader 无法实现的其他事。  </p><h3 id="用法-1"><a href="#用法-1" class="headerlink" title="用法"></a>用法</h3><p>由于插件可以携带参数/选项，你必须在 webpack 配置中，向 plugins 属性传入 new 实例。  </p><p> webpack.config.js  </p><pre><code>const HtmlWebpackPlugin = require(&apos;html-webpack-plugin&apos;); //通过 npm 安装const webpack = require(&apos;webpack&apos;); //访问内置的插件const path = require(&apos;path&apos;);const config = {  entry: &apos;./path/to/my/entry/file.js&apos;,  output: {    filename: &apos;my-first-webpack.bundle.js&apos;,    path: path.resolve(__dirname, &apos;dist&apos;)  },  module: {    rules: [      {        test: /\.(js|jsx)$/,        use: &apos;babel-loader&apos;      }    ]  },  plugins: [    new webpack.optimize.UglifyJsPlugin(),    new HtmlWebpackPlugin({template: &apos;./src/index.html&apos;})  ]};module.exports = config;</code></pre><h2 id="配置-1"><a href="#配置-1" class="headerlink" title="配置"></a>配置</h2><p>因为 webpack 配置是标准的 Node.js CommonJS 模块，你可以做到以下事情：</p><ul><li>通过 require(…) 导入其他文件</li><li>通过 require(…) 使用 npm 的工具函数</li><li>使用 JavaScript 控制流表达式，例如 ?: 操作符</li><li>对常用值使用常量或变量</li><li>编写并执行函数来生成部分配置  </li></ul><h2 id="模块"><a href="#模块" class="headerlink" title="模块"></a>模块</h2><h3 id="什么是webpack模块"><a href="#什么是webpack模块" class="headerlink" title="什么是webpack模块"></a>什么是webpack模块</h3><ul><li>ES2015 import 语句</li><li>CommonJS require() 语句</li><li>AMD define 和 require 语句</li><li>css/sass/less 文件中的 @import 语句。</li><li>样式(url(…))或 HTML 文件(<code>&lt;img src=...&gt;</code>)中的图片链接(image url)</li></ul><h3 id="优化路径"><a href="#优化路径" class="headerlink" title="优化路径"></a>优化路径</h3><h4 id="1-resolve-extensions"><a href="#1-resolve-extensions" class="headerlink" title="1. resolve.extensions"></a>1. resolve.extensions</h4><p>　　在webpack.base.conf.js中，我们可以看到resolve配置，其中的extengsions是一个数组，如下所示：</p><pre><code>extensions: [&apos;.js&apos;, &apos;.vue&apos;, &apos;.json&apos;],</code></pre><p>　　通过这样的配置，我们在组件中过着路由中应用组件时，就可以更为方便的应用，比如：</p><p>  import Hello from ‘@components/Hello’;<br>　　即Hello.vue这个组件我们不需要添加.vue后缀就可以引用到了，如果不用extensions， 我们就必须要用@components/Hello.vue来引入这个文件。 </p><h4 id="2-resolve-alias"><a href="#2-resolve-alias" class="headerlink" title="2. resolve.alias"></a>2. resolve.alias</h4><p>　　在组件之间相互引用时，可能是下面这样的：</p><pre><code>import Hello from &apos;../src.components/Hello&apos;;  </code></pre><p>　　其中的路径是相对于当前页面的。 但是如果嵌套等更为复杂，那么写起来会比较麻烦。但是如果我们通过这样的配置：</p><pre><code>resolve: {  extensions: [&apos;.js&apos;, &apos;.vue&apos;, &apos;.json&apos;],  alias: {    &apos;vue$&apos;: &apos;vue/dist/vue.esm.js&apos;,    &apos;@pages&apos;: path.join(__dirname, &quot;..&quot;, &quot;src&quot;, &quot;pages&quot;),    &quot;@components&quot;: path.join(__dirname, &quot;..&quot;, &quot;src&quot;, &quot;components&quot;),    // 注意： 静态资源通过src，不能这么设置。    // &quot;@assets&quot;: path.join(__dirname, &quot;..&quot;, &quot;src&quot;, &quot;assets&quot;),  }</code></pre><p>其中vue$表示引入vue，就可以像下面这么写：  </p><pre><code>import Vue from &apos;vue&apos;  </code></pre><p>　　另外，对于@pages和@components我们就可以直接引用了，而省去了一大堆的复杂应用，另外通过@可以消除歧义。如下所示：</p><pre><code>import Hello from &apos;@components/Hello&apos;;import App from &apos;@pages/App&apos;  </code></pre><p>　　值得注意的时： 在webpack.config.js中我们不能使用../ 以及./这种形式的路径方式，而是通过 path.join 和 __dirname 这种形式来表示路径，否则会报错。</p><p>　　另外： 在组件中，我们会引用一些静态文件，即static下的文件， 这时我们就不能用 alias 下的配置了，而必须使用一般的配置方式。  </p><h2 id="构建目标"><a href="#构建目标" class="headerlink" title="构建目标"></a>构建目标</h2><p>因为服务器和浏览器代码都可以用 JavaScript 编写，所以 webpack 提供了多种构建目标(target)，你可以在你的 webpack 配置中设置。  </p><h3 id="用法-2"><a href="#用法-2" class="headerlink" title="用法"></a>用法</h3><p>要设置 target 属性，只需要在你的 webpack 配置中设置 target 的值。<br>webpack.config.js</p><pre><code>module.exports = {  target: &apos;node&apos;};  </code></pre><p>在上面例子中，使用 node webpack 会编译为用于「类 Node.js」环境（使用 Node.js 的 require ，而不是使用任意内置模块（如 fs 或 path）来加载 chunk）。  </p><h3 id="多个Target"><a href="#多个Target" class="headerlink" title="多个Target"></a>多个Target</h3><p>尽管 webpack 不支持向 target 传入多个字符串，你可以通过打包两份分离的配置来创建同构的库：<br>webpack.config.js</p><pre><code>var path = require(&apos;path&apos;);var serverConfig = {  target: &apos;node&apos;,  output: {    path: path.resolve(__dirname, &apos;dist&apos;),    filename: &apos;lib.node.js&apos;  }  //…};var clientConfig = {  target: &apos;web&apos;, // &lt;=== 默认是 &apos;web&apos;，可省略  output: {    path: path.resolve(__dirname, &apos;dist&apos;),    filename: &apos;lib.js&apos;  }  //…};module.exports = [ serverConfig, clientConfig ];</code></pre><p>上面的例子将在你的 dist 文件夹下创建 lib.js 和 lib.node.js 文件。</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;webpack&quot;&gt;&lt;a href=&quot;#webpack&quot; class=&quot;headerlink&quot; title=&quot;webpack&quot;&gt;&lt;/a&gt;webpack&lt;/h1&gt;&lt;p&gt;是一个现代 JavaScript 应用程序的静态模块打包器(module bundler)。当 webpack 处理应用程序时，它会递归地构建一个依赖关系图(dependency graph)，其中包含应用程序需要的每个模块，然后将所有这些模块打包成一个或多个 bundle。  &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;入口(entry)&lt;/li&gt;
&lt;li&gt;输出(output)&lt;/li&gt;
&lt;li&gt;loader&lt;/li&gt;
&lt;li&gt;插件(plugins)&lt;/li&gt;&lt;/ul&gt;
    
    </summary>
    
      <category term="web" scheme="http://yaliixxg.github.io/categories/web/"/>
    
    
      <category term="webpack" scheme="http://yaliixxg.github.io/tags/webpack/"/>
    
  </entry>
  
  <entry>
    <title>《图解HTTP》学习笔记</title>
    <link href="http://yaliixxg.github.io/2018/07/12/h/"/>
    <id>http://yaliixxg.github.io/2018/07/12/h/</id>
    <published>2018-07-12T03:49:00.000Z</published>
    <updated>2018-07-13T07:12:43.816Z</updated>
    
    <content type="html"><![CDATA[<h3 id="坚持-｡◕ˇ∀ˇ◕-HTTP-WebSocket"><a href="#坚持-｡◕ˇ∀ˇ◕-HTTP-WebSocket" class="headerlink" title="坚持 (｡◕ˇ∀ˇ◕) ,HTTP WebSocket"></a>坚持 (｡◕ˇ∀ˇ◕) ,HTTP WebSocket</h3><h1 id="HTTP"><a href="#HTTP" class="headerlink" title="HTTP"></a>HTTP</h1><p>超文本传输协议（超文本转移协议）</p><h3 id="TCP-IP"><a href="#TCP-IP" class="headerlink" title="TCP/IP"></a>TCP/IP</h3><p>互联网相关的各类协议族的总称，协议存在各式各样的内容。从电缆的规格到IP地址的选定方法、双方建立通信的顺序，以及web页面显示需要处理的步骤，等等。<br>按层次分别为：应用层、传输层、网络层、数据链路层。  </p><h4 id="从客户端发送请求到服务端接收请求流程如图："><a href="#从客户端发送请求到服务端接收请求流程如图：" class="headerlink" title="从客户端发送请求到服务端接收请求流程如图："></a>从客户端发送请求到服务端接收请求流程如图：</h4><p><img src="/2018/07/12/h/h2.png" alt="h2"><br><a id="more"></a></p><h3 id="IP"><a href="#IP" class="headerlink" title="IP"></a>IP</h3><p>IP协议的作用是把各种数据包传送给对方。而要确保传送到对方那里，则需要满足各类条件。其中最重要的条件是IP地址和MAC地址（网卡所属的固定地址）<br><img src="/2018/07/12/h/h3.png" alt="h3">  </p><h3 id="TCP"><a href="#TCP" class="headerlink" title="TCP"></a>TCP</h3><p>TCP位于传输层，提供可靠的字节流服务。为了更容易传达大数据把数据分割，确保数据能到达目标。<br>为了准确无误的将数据送达到目标出，采用三次握手策略。<br><img src="/2018/07/12/h/h4.png" alt="h4">  </p><h3 id="DNS"><a href="#DNS" class="headerlink" title="DNS"></a>DNS</h3><p>DNS位于应用层的协议。提供域名到IP地址之间的解析服务。<br><img src="/2018/07/12/h/h5.png" alt="h5">  </p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p><img src="/2018/07/12/h/h6.png" alt="http6">  </p><h3 id="告知服务器意图的HTTP方法"><a href="#告知服务器意图的HTTP方法" class="headerlink" title="告知服务器意图的HTTP方法"></a>告知服务器意图的HTTP方法</h3><p><img src="/2018/07/12/h/h7.png" alt="h7">  </p><h3 id="返回结果的HTTP状态码"><a href="#返回结果的HTTP状态码" class="headerlink" title="返回结果的HTTP状态码"></a>返回结果的HTTP状态码</h3><p><img src="/2018/07/12/h/h8.png" alt="h8">  </p><p>200:OK 表示从客户端发来的请求在服务器端被正常处理了。<br>204:No Content 表示客户端发来的请求处理成功，但是服务端没有资源科返回。一般按在只需要从客户端往服务器发送信息，而对客户端不需要发送新内容的情况下使用。<br>206:Partical Content 表示客户端进行了范围请求，而服务器成功执行了这一部分的GET请求。  </p><p>301:Moved Permanently 永久性重定向。该状态码表示请求的资源已被分配了新的URI，以后应使用资源现在所指的URI。<br>302:Found 临时性重定向。表示请求的资源已被分配了新的URI，希望用户（本次）能使用新的URI访问。<br>303:See Other 表示由于请求对应的资源存折另一个URI，应使用GET方法定向获取请求的资源。<br>304:Not Modified 表示客户端发送附带条件的请求时，服务器端允许请求访问资源，但为满足条件的情况。<br>307:Temporary Redirect 临时性重定向，和302一样。只是它会遵守标准，不会从POST变成GET。  </p><p>400:Bed Request 表示请求报文中存在语法错误。当错误发生时，需修改请求的内容后再次发送请求。<br>401:Unauthorized 表示发送的请求需要通过HTTP认证的认证信息。另外若之前已进行过一次请求，则表示用户认证失败。浏览器初次接收到401响应，会弹出认证用的对话窗口。<br>403:Forbidden 表情对请求资源的访问被服务器拒绝了。<br>404:Not Found 表明服务器上无法找到请求的资源。  </p><p>500:Internal Server Error 表明服务器端在执行请求时发生了错误。也有可能是web应用存在的BUG或某些临时的故障。<br>503:Service Unavailable 表明服务器暂时处于超负载或正在进行停机维护，现在无法处理请求。</p><h3 id="HTTP首部字段一览"><a href="#HTTP首部字段一览" class="headerlink" title="HTTP首部字段一览"></a>HTTP首部字段一览</h3><p><img src="/2018/07/12/h/h9.png" alt="h9"><br><img src="/2018/07/12/h/h10.png" alt="h10"><br><img src="/2018/07/12/h/h11.png" alt="h12"><br><img src="/2018/07/12/h/h12.png" alt="h12">  </p><h3 id="HTTPS"><a href="#HTTPS" class="headerlink" title="HTTPS"></a>HTTPS</h3><ul><li>HTTP的缺点：  <ul><li>通信使用明文（不加密），内容可能会被窃听  </li><li>不验证通信方的身份，因此有可能遭遇伪装</li><li>无法证明报文的额完整性，所以有可能已遭篡改</li></ul></li></ul><p>HTTPS（全称：Hyper Text Transfer Protocol over Secure Socket Layer 超文本传输安全协议），是以安全为目标的HTTP通道，简单讲是HTTP的安全版。即HTTP下加入SSL层（Secure Socket Layer，安全嵌套层）或 TSL（Transport Layer Security，安全层传输协议）的组合使用，HTTPS的安全基础是SSL，因此加密的详细内容就需要SSL。</p><ul><li><p>HTTPS和HTTP的区别<br>超文本传输协议HTTP协议被用于在Web浏览器和网站服务器之间传递信息。HTTP协议以明文方式发送内容，不提供任何方式的数据加密，如果攻击者截取了Web浏览器和网站服务器之间的传输报文，就可以直接读懂其中的信息，因此HTTP协议不适合传输一些敏感信息，比如信用卡号、密码等。<br>为了解决HTTP协议的这一缺陷，需要使用另一种协议：安全套接字层超文本传输协议HTTPS。为了数据传输的安全，HTTPS在HTTP的基础上加入了SSL协议，SSL依靠证书来验证服务器的身份，并为浏览器和服务器之间的通信加密。</p><h4 id="HTTPS和HTTP的区别主要为以下四点："><a href="#HTTPS和HTTP的区别主要为以下四点：" class="headerlink" title="HTTPS和HTTP的区别主要为以下四点："></a>HTTPS和HTTP的区别主要为以下四点：</h4><ul><li>一、https协议需要到ca申请证书，一般免费证书很少，需要交费。</li><li>二、http是超文本传输协议，信息是明文传输，https 则是具有安全性的ssl加密传输协议。</li><li>三、http和https使用的是完全不同的连接方式，用的端口也不一样，前者是80，后者是443。</li><li>四、http的连接很简单，是无状态的；HTTPS协议是由SSL+HTTP协议构建的可进行加密传输、身份认证的网络协议，比http协议安全。  </li></ul><h3 id="HTTPS-HTTP-加密-认证-完整性保护"><a href="#HTTPS-HTTP-加密-认证-完整性保护" class="headerlink" title="HTTPS = HTTP + 加密 + 认证 + 完整性保护"></a>HTTPS = HTTP + 加密 + 认证 + 完整性保护</h3><p>HTTPS采用混合加密机制<br><img src="/2018/07/12/h/h13.png" alt="h13">  </p></li></ul><h1 id="WebSocket"><a href="#WebSocket" class="headerlink" title="WebSocket"></a>WebSocket</h1><p>是HTML5开始提供的一种在单个 TCP 连接上进行全双工通讯的协议.<br>在WebSocket API中，浏览器和服务器只需要做一个握手的动作，然后，浏览器和服务器之间就形成了一条快速通道。两者之间就直接可以数据互相传送。</p><p>浏览器通过 JavaScript 向服务器发出建立 WebSocket 连接的请求，连接建立以后，客户端和服务器端就可以通过 TCP 连接直接交换数据。</p><p>当你获取 Web Socket 连接后，你可以通过 send() 方法来向服务器发送数据，并通过 onmessage 事件来接收服务器返回的数据。  </p><p>在程序设计中，这种设计叫做回调，即：你有信息了再来通知我，而不是我傻乎乎的每次跑来问你。<br>Websocket只需要一次HTTP握手，所以说整个通讯过程是建立在一次连接/状态中，也就避免了HTTP的非状态性，服务端会一直知道你的信息，直到你关闭请求，这样就解决了接线员要反复解析HTTP协议，还要查看identity info的信息。<br>同时由客户主动询问，转换为服务器（推送）有信息的时候就发送（当然客户端还是等主动发送信息过来的。。），没有信息的时候就交给接线员（Nginx），不需要占用本身速度就慢的客服（Handler）了   </p><pre><code>var Socket = new WebSocket(url, [protocol] );  </code></pre><p>以上代码中的第一个参数 url, 指定连接的 URL。第二个参数 protocol 是可选的，指定了可接受的子协议。  </p><h4 id="WebSocket属性"><a href="#WebSocket属性" class="headerlink" title="WebSocket属性"></a>WebSocket属性</h4><ul><li>Socket.readyState（只读属性， readyState 表示连接状态）<ul><li>0 - 表示连接尚未建立。</li><li>1 - 表示连接已建立，可以进行通信。</li><li>2 - 表示连接正在进行关闭。</li><li>3 - 表示连接已经关闭或者连接不能打开。  </li></ul></li><li>Socket.bufferedAmount（只读属性bufferedAmount 已被 send() 放入正在队列中等待传输，但是还没有发出的 UTF-8 文本字节数。）  </li></ul><h4 id="WebSocket-事件"><a href="#WebSocket-事件" class="headerlink" title="WebSocket 事件"></a>WebSocket 事件</h4><p>以下是 WebSocket 对象的相关事件。假定我们使用了以上代码创建了 Socket 对象：  </p><ul><li>open  <ul><li>Socket.onopen    连接建立时触发  </li></ul></li><li>message  <ul><li>Socket.onmessage 客户端接收服务端数据时触发</li></ul></li><li>error  <ul><li>Socket.onerror   通信发生错误时触发</li></ul></li><li>close  <ul><li>Socket.onclose   连接关闭时触发  </li></ul></li></ul><h4 id="WebSocket-方法"><a href="#WebSocket-方法" class="headerlink" title="WebSocket 方法"></a>WebSocket 方法</h4><p>以下是 WebSocket 对象的相关事件。假定我们使用了以上代码创建了 Socket 对象：  </p><ul><li>Socket.send()  使用连接发送数据  </li><li>Socket.close() 关闭连接  </li></ul><h4 id="WebSocket-实例"><a href="#WebSocket-实例" class="headerlink" title="WebSocket 实例"></a>WebSocket 实例</h4><p>目前大部分浏览器支持 WebSocket() 接口，你可以在以下浏览器中尝试实例： Chrome, Mozilla, Opera 和 Safari。  </p><pre><code>&lt;script type=&quot;text/javascript&quot;&gt;        function WebSocketTest()        {           if (&quot;WebSocket&quot; in window)           {              alert(&quot;您的浏览器支持 WebSocket!&quot;);              // 打开一个 web socket              var ws = new WebSocket(&quot;ws://localhost:9998/echo&quot;);              ws.onopen = function()              {                 // Web Socket 已连接上，使用 send() 方法发送数据                 ws.send(&quot;发送数据&quot;);                 alert(&quot;数据发送中...&quot;);              };              ws.onmessage = function (evt)               {                  var received_msg = evt.data;                 alert(&quot;数据已接收...&quot;);              };              ws.onclose = function()              {                  // 关闭 websocket                 alert(&quot;连接已关闭...&quot;);               };           }           else           {              // 浏览器不支持 WebSocket              alert(&quot;您的浏览器不支持 WebSocket!&quot;);           }        } &lt;/script&gt; </code></pre><h5 id="安装pywebsocket"><a href="#安装pywebsocket" class="headerlink" title="安装pywebsocket"></a>安装pywebsocket</h5><p>在执行以上程序前，我们需要创建一个支持 WebSocket 的服务。从 pywebsocket 下载 mod_pywebsocket ,或者使用 git 命令下载：  </p><pre><code>git clone https://github.com/google/pywebsocket.git  </code></pre><p>mod_pywebsocket 需要 python 环境支持</p><p>mod_pywebsocket 是一个 Apache HTTP 的 Web Socket扩展，安装步骤如下：  </p><ul><li>解压下载的文件。  </li><li>进入pywebsocket目录。  </li><li>执行命令：  <pre><code>$ python setup.py build$ sudo python setup.py install  </code></pre></li><li>查看文档说明：  <pre><code>$ pydoc mod_pywebsocket  </code></pre><h4 id="开启服务"><a href="#开启服务" class="headerlink" title="开启服务"></a>开启服务</h4>在 pywebsocket/mod_pywebsocket 目录下执行以下命令：  <pre><code>$ sudo python standalone.py -p 9998 -w ../example/  </code></pre>以上命令会开启一个端口号为 9998 的服务，使用 -w 来设置处理程序 echo_wsh.py 所在的目录。</li></ul><p>现在我们可以在 Chrome 浏览器打开前面创建的 runoob_websocket.html 文件。如果你的浏览器支持 WebSocket(), 点击”运行 WebSocket”，你就可以看到整个流程各个步骤弹出的窗口</p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;坚持-｡◕ˇ∀ˇ◕-HTTP-WebSocket&quot;&gt;&lt;a href=&quot;#坚持-｡◕ˇ∀ˇ◕-HTTP-WebSocket&quot; class=&quot;headerlink&quot; title=&quot;坚持 (｡◕ˇ∀ˇ◕) ,HTTP WebSocket&quot;&gt;&lt;/a&gt;坚持 (｡◕ˇ∀ˇ◕) ,HTTP WebSocket&lt;/h3&gt;&lt;h1 id=&quot;HTTP&quot;&gt;&lt;a href=&quot;#HTTP&quot; class=&quot;headerlink&quot; title=&quot;HTTP&quot;&gt;&lt;/a&gt;HTTP&lt;/h1&gt;&lt;p&gt;超文本传输协议（超文本转移协议）&lt;/p&gt;
&lt;h3 id=&quot;TCP-IP&quot;&gt;&lt;a href=&quot;#TCP-IP&quot; class=&quot;headerlink&quot; title=&quot;TCP/IP&quot;&gt;&lt;/a&gt;TCP/IP&lt;/h3&gt;&lt;p&gt;互联网相关的各类协议族的总称，协议存在各式各样的内容。从电缆的规格到IP地址的选定方法、双方建立通信的顺序，以及web页面显示需要处理的步骤，等等。&lt;br&gt;按层次分别为：应用层、传输层、网络层、数据链路层。  &lt;/p&gt;
&lt;h4 id=&quot;从客户端发送请求到服务端接收请求流程如图：&quot;&gt;&lt;a href=&quot;#从客户端发送请求到服务端接收请求流程如图：&quot; class=&quot;headerlink&quot; title=&quot;从客户端发送请求到服务端接收请求流程如图：&quot;&gt;&lt;/a&gt;从客户端发送请求到服务端接收请求流程如图：&lt;/h4&gt;&lt;p&gt;&lt;img src=&quot;/2018/07/12/h/h2.png&quot; alt=&quot;h2&quot;&gt;&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="web" scheme="http://yaliixxg.github.io/categories/web/"/>
    
    
      <category term="http websocket" scheme="http://yaliixxg.github.io/tags/http-websocket/"/>
    
  </entry>
  
  <entry>
    <title>程序员的技能思考</title>
    <link href="http://yaliixxg.github.io/2018/07/10/20180710think/"/>
    <id>http://yaliixxg.github.io/2018/07/10/20180710think/</id>
    <published>2018-07-10T09:55:01.000Z</published>
    <updated>2018-07-10T10:00:08.501Z</updated>
    
    <content type="html"><![CDATA[<h3 id="程序员的两条腿"><a href="#程序员的两条腿" class="headerlink" title="程序员的两条腿"></a>程序员的两条腿</h3><ul><li>数学</li><li>英语</li></ul><p>除此之外是职业技能<br><a id="more"></a></p><ul><li>学习能力<br>通过多途径的方式快速习得必要知识，这些途径包括搜索引擎，实体书籍，电子文档，论坛提问等。</li><li>编码能力<ul><li>编程语言的掌握<br>理解语言的特性编写清晰高效的代码，命名直观，注释准确。<br>理解语言的实现，能供透过语言的形式了解其背后的原理，从而优化代码，或是触类旁通学习其它语言。<br>理解不同编程范式并在合适的场景下应用，命令式，声明式两大类，前者向计算机描述问题的求解过程 how ，后者向计算机描述问题是什么 what，函数式编程归属于声明式。（过程式，函数式，对象式，并发，逻辑等）</li><li>技术栈的掌握<br>掌握各种框架及工具链解决工程开发问题<br>利用各种框架及工具搭建项目工程<br>了解各类技术的应用场景与实现  </li><li>编程思想的理解<br>抽象<br>模块化、复用<br>分层<br>低耦合高内聚原则<br>SOLID 原则  </li><li>数据结构与算法  </li></ul></li><li>解决问题的能力<ul><li>发现问题<br>调试技巧，经验与直觉</li><li>描述问题<br>恰当的语言描述问题</li><li>解决问题<br>直接解决，求助解决，借助互联网解决</li></ul></li><li>设计与架构能力<ul><li>架构原则</li><li>通用设计模式</li></ul></li><li>沟通表达能力<ul><li>文档编写（PPT，博文）</li><li>语言表达</li></ul></li><li>业务领域知识</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;程序员的两条腿&quot;&gt;&lt;a href=&quot;#程序员的两条腿&quot; class=&quot;headerlink&quot; title=&quot;程序员的两条腿&quot;&gt;&lt;/a&gt;程序员的两条腿&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;数学&lt;/li&gt;
&lt;li&gt;英语&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;除此之外是职业技能&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="web" scheme="http://yaliixxg.github.io/categories/web/"/>
    
    
      <category term="程序员思考" scheme="http://yaliixxg.github.io/tags/%E7%A8%8B%E5%BA%8F%E5%91%98%E6%80%9D%E8%80%83/"/>
    
  </entry>
  
  <entry>
    <title>在vue项目中 如何定义全局变量 全局函数</title>
    <link href="http://yaliixxg.github.io/2018/07/03/global/"/>
    <id>http://yaliixxg.github.io/2018/07/03/global/</id>
    <published>2018-07-03T07:54:36.000Z</published>
    <updated>2018-07-12T03:48:17.492Z</updated>
    
    <content type="html"><![CDATA[<p>定义全局变量<br>原理：<br>设置一个专用的的全局变量模块文件，模块里面定义一些变量初始状态，用export default 暴露出去，在main.js里面使用Vue.prototype挂载到vue实例上面或者在其它地方需要使用时，引入该模块便可。</p><p>全局变量模块文件：<br>Global.vue文件：</p><p><img src="/2018/07/03/global/vue1.png" alt="vue1"></p><h1 id="使用方式1："><a href="#使用方式1：" class="headerlink" title="使用方式1："></a>使用方式1：</h1><p>在需要的地方引用进全局变量模块文件，然后通过文件里面的变量名字获取全局变量参数值。</p><p>在text1.vue组件中使用：</p><p><img src="/2018/07/03/global/vue2.png" alt="vue2"><br><a id="more"></a></p><h1 id="使用方式2："><a href="#使用方式2：" class="headerlink" title="使用方式2："></a>使用方式2：</h1><p>在程序入口的main.js文件里面，将上面那个Global.vue文件挂载到Vue.prototype。</p><pre><code>import global_ from &apos;./components/Global&apos;//引用文件Vue.prototype.GLOBAL = global_//挂载到Vue实例上面</code></pre><p>接着在整个项目中不需要再通过引用Global.vue模块文件，直接通过this就可以直接访问Global文件里面定义的全局变量。</p><p>text2.vue：</p><p><img src="/2018/07/03/global/vue3.png" alt="vue3"></p><p>Vuex也可以设置全局变量：<br>通过vuex来存放全局变量，这里东西比较多，也相对复杂一些，有兴趣的小伙伴们，可自行查阅资料，折腾一波、</p><p>定义全局函数<br>原理<br>新建一个模块文件，然后在main.js里面通过Vue.prototype将函数挂载到Vue实例上面，通过this.函数名，来运行函数。</p><ol><li>在main.js里面直接写函数<br>简单的函数可以直接在main.js里面直接写</li></ol><p>Vue.prototype.changeData = function (){//changeData是函数名<br>  alert(‘执行成功’);<br>}<br>组件中调用：</p><p>this.changeData();//直接通过this运行函数</p><ol start="2"><li>写一个模块文件，挂载到main.js上面。<br>base.js文件，文件位置可以放在跟main.js同一级，方便引用</li></ol><p>exports.install = function (Vue, options) {<br>   Vue.prototype.text1 = function (){//全局函数1<br>    alert(‘执行成功1’);<br>    };<br>    Vue.prototype.text2 = function (){//全局函数2<br>    alert(‘执行成功2’);<br>    };<br>};<br>main.js入口文件：</p><pre><code>import base from &apos;./base&apos;//引用Vue.use(base);//将全局函数当做插件来进行注册</code></pre><p>组件里面调用：</p><pre><code>this.text1();this.text2();</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;定义全局变量&lt;br&gt;原理：&lt;br&gt;设置一个专用的的全局变量模块文件，模块里面定义一些变量初始状态，用export default 暴露出去，在main.js里面使用Vue.prototype挂载到vue实例上面或者在其它地方需要使用时，引入该模块便可。&lt;/p&gt;
&lt;p&gt;全局变量模块文件：&lt;br&gt;Global.vue文件：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/2018/07/03/global/vue1.png&quot; alt=&quot;vue1&quot;&gt;&lt;/p&gt;
&lt;h1 id=&quot;使用方式1：&quot;&gt;&lt;a href=&quot;#使用方式1：&quot; class=&quot;headerlink&quot; title=&quot;使用方式1：&quot;&gt;&lt;/a&gt;使用方式1：&lt;/h1&gt;&lt;p&gt;在需要的地方引用进全局变量模块文件，然后通过文件里面的变量名字获取全局变量参数值。&lt;/p&gt;
&lt;p&gt;在text1.vue组件中使用：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/2018/07/03/global/vue2.png&quot; alt=&quot;vue2&quot;&gt;&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="web" scheme="http://yaliixxg.github.io/categories/web/"/>
    
    
      <category term="vue 全局变量" scheme="http://yaliixxg.github.io/tags/vue-%E5%85%A8%E5%B1%80%E5%8F%98%E9%87%8F/"/>
    
  </entry>
  
  <entry>
    <title>12岁的晴天</title>
    <link href="http://yaliixxg.github.io/2018/07/03/sunny/"/>
    <id>http://yaliixxg.github.io/2018/07/03/sunny/</id>
    <published>2018-07-03T02:30:23.000Z</published>
    <updated>2018-07-10T01:37:53.089Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/2018/07/03/sunny/sunny1.jpg" alt="sunny1"><br><img src="/2018/07/03/sunny/sunny2.jpg" alt="sunny2"></p><p>从前从前有个人爱你很久<br>但偏偏，雨渐渐，把距离吹的好远</p><p>刮风这天<br>我试过握着你手</p><p>还要多久，我才能在你身边<br>等到放晴的那天<br>也许我会比较好一点</p><p>为你翘课的那一天<br>花落的那一天<br>教室的那一间<br>我怎么看不见<br>消失的下雨天<br>我好想再淋一遍</p><p>12岁的晴天<br>但故事的最后，你好像还是说了</p><h1 id="拜。"><a href="#拜。" class="headerlink" title="拜。"></a>拜。</h1>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;img src=&quot;/2018/07/03/sunny/sunny1.jpg&quot; alt=&quot;sunny1&quot;&gt;&lt;br&gt;&lt;img src=&quot;/2018/07/03/sunny/sunny2.jpg&quot; alt=&quot;sunny2&quot;&gt;&lt;/p&gt;
&lt;p&gt;从前从前有个人爱你很久&lt;br&gt;但偏偏，
      
    
    </summary>
    
      <category term="音乐" scheme="http://yaliixxg.github.io/categories/%E9%9F%B3%E4%B9%90/"/>
    
    
      <category term="晴天 周杰伦" scheme="http://yaliixxg.github.io/tags/%E6%99%B4%E5%A4%A9-%E5%91%A8%E6%9D%B0%E4%BC%A6/"/>
    
  </entry>
  
</feed>
