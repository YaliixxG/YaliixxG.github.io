<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>挖坑埋神经病</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yaliixxg.github.io/"/>
  <updated>2018-07-23T02:04:21.324Z</updated>
  <id>http://yaliixxg.github.io/</id>
  
  <author>
    <name>YaliixxG</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>跨域</title>
    <link href="http://yaliixxg.github.io/2018/07/23/kuayu/"/>
    <id>http://yaliixxg.github.io/2018/07/23/kuayu/</id>
    <published>2018-07-23T01:32:02.000Z</published>
    <updated>2018-07-23T02:04:21.324Z</updated>
    
    <content type="html"><![CDATA[<h2 id="什么是同源策略？"><a href="#什么是同源策略？" class="headerlink" title="什么是同源策略？"></a>什么是同源策略？</h2><p>同源策略，它是由Netscape提出的一个著名的安全策略。<br>现在所有支持JavaScript 的浏览器都会使用这个策略。<br>所谓同源是指，域名，协议，端口相同。<br>因为浏览器出于安全考虑，有同源策略。也就是说，如果协议、域名或者端口有一个不同就是跨域，Ajax 请求会失败。<br><a id="more"></a> </p><h2 id="JSONP"><a href="#JSONP" class="headerlink" title="JSONP"></a>JSONP</h2><p><code>JSONP</code> 的原理很简单，就是利用 <code>&lt;script&gt;</code> 标签没有跨域限制的漏洞。通过 <code>&lt;script&gt;</code> 标签指向一个需要访问的地址并提供一个回调函数来接收数据当需要通讯时。  </p><pre><code>&lt;script src=&quot;http://domain/api?param1=a&amp;param2=b&amp;callback=jsonp&quot;&gt;&lt;/script&gt;&lt;script&gt;    function jsonp(data) {        console.log(data)    }&lt;/script&gt;    </code></pre><p><code>JSONP</code> 使用简单且兼容性不错，但是只限于 <code>get</code> 请求。  </p><h2 id="封装JSONP"><a href="#封装JSONP" class="headerlink" title="封装JSONP"></a>封装JSONP</h2><pre><code>function jsonp(url,jsonpCallback,success){    let script = document.creatElement(&quot;script&quot;);    script.src = url;    script.async = true;    script.type = &quot;text/javascript&quot;;    window[jsonpCallback] = function(data){        success &amp; success(data);    };    document.body.appendChild(script);}  jsonp(&quot;http://xxx&quot;,&quot;callback&quot;,function(value) {    console.log(value);});  </code></pre><h2 id="CORS"><a href="#CORS" class="headerlink" title="CORS"></a>CORS</h2><p><code>CORS</code>需要浏览器和后端同时支持。IE 8 和 9 需要通过 XDomainRequest 来实现。</p><p>浏览器会自动进行 <code>CORS</code> 通信，实现CORS通信的关键是后端。只要后端实现了 <code>CORS</code>，就实现了跨域。</p><p>服务端设置 <code>Access-Control-Allow-Origin</code> 就可以开启 <code>CORS</code>。 该属性表示哪些域名可以访问资源，如果设置通配符则表示所有网站都可以访问资源。  </p><h2 id="postMessage"><a href="#postMessage" class="headerlink" title="postMessage"></a>postMessage</h2><p>这种方式通常用于获取嵌入页面中的第三方页面数据。一个页面发送消息，另一个页面判断来源并接收消息  </p><pre><code>// 发送消息端window.parent.postMessage(&apos;message&apos;, &apos;http://test.com&apos;);// 接收消息端var mc = new MessageChannel();mc.addEventListener(&apos;message&apos;, (event) =&gt; {    var origin = event.origin || event.originalEvent.origin;     if (origin === &apos;http://test.com&apos;) {        console.log(&apos;验证通过&apos;)    }});</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;什么是同源策略？&quot;&gt;&lt;a href=&quot;#什么是同源策略？&quot; class=&quot;headerlink&quot; title=&quot;什么是同源策略？&quot;&gt;&lt;/a&gt;什么是同源策略？&lt;/h2&gt;&lt;p&gt;同源策略，它是由Netscape提出的一个著名的安全策略。&lt;br&gt;现在所有支持JavaScript 的浏览器都会使用这个策略。&lt;br&gt;所谓同源是指，域名，协议，端口相同。&lt;br&gt;因为浏览器出于安全考虑，有同源策略。也就是说，如果协议、域名或者端口有一个不同就是跨域，Ajax 请求会失败。&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="web" scheme="http://yaliixxg.github.io/categories/web/"/>
    
    
      <category term="跨域 JSONP" scheme="http://yaliixxg.github.io/tags/%E8%B7%A8%E5%9F%9F-JSONP/"/>
    
  </entry>
  
  <entry>
    <title>created mounted 更新获取DOM问题</title>
    <link href="http://yaliixxg.github.io/2018/07/19/lifecicle/"/>
    <id>http://yaliixxg.github.io/2018/07/19/lifecicle/</id>
    <published>2018-07-19T09:12:05.000Z</published>
    <updated>2018-07-19T09:45:54.633Z</updated>
    
    <content type="html"><![CDATA[<p>口水记录一个问题。 ┓(;´_｀)┏ </p><p>写代码的时候，遇到一个问题，就是在<code>created</code>里面调用接口获取数据，利用<code>v-for</code>渲染<code>DOM</code>后，再在<code>mounted</code>里面调用渲染后的<code>DOM</code>时，一直无法获取到，显示为<code>undefined</code>。<br><a id="more"></a></p><p>按照<code>VUE</code>的生命周期来说  </p><blockquote><ul><li><code>created</code> 组件实例创建完成，属性已绑定，但<code>DOM</code>还未生成，<code>$el</code>属性还不存在。  </li><li><code>mounted</code>模板编译/挂载之后。  </li></ul></blockquote><p>按道理，在<code>mounted</code>里面是可以获取到<code>created</code>阶段渲染的<code>DOM</code>的。后来通过<code>console.log()</code>来进行判断，发现在<code>mounted</code>里面的代码开始执行时，<code>created</code>阶段的<code>DOM</code>渲染还未完成。  </p><p>把<code>mounted</code>改为<code>updated</code>，<code>DOM</code>是可以获取到的，但是由于我的代码中涉及到倒计时等频繁更新<code>DOM</code>的状态，所以放弃了<code>updated</code>的这个方法。  </p><blockquote><ul><li><code>updated</code>  组件更新之后</li></ul></blockquote><p>后来通过查阅文档发现，有一个方法可以解决这种问题，调用<code>$nextTick</code>这个<code>vue</code>的全局方法。即在<code>mounted</code>里面调用此方法，用于<code>DOM</code>加载更新完后进行的一次回调函数性质的操作。  </p><pre><code>mounted(){    this.$nextTick(_=&gt;{        //你的代码部分    })}</code></pre><p>但是很可悲 = = ，我的<code>created</code>里渲染的<code>DOM</code>还是比它要晚执行完，所以获取<code>DOM</code>依然是<code>undefined</code>。  </p><p>最后用了一个简单粗暴的方法解决了此问题。  </p><pre><code>mounted() {    setTimeout(_ =&gt; {    //你的代码部分    }, 1000);}  </code></pre><p> (o°ω°o) </p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;口水记录一个问题。 ┓(;´_｀)┏ &lt;/p&gt;
&lt;p&gt;写代码的时候，遇到一个问题，就是在&lt;code&gt;created&lt;/code&gt;里面调用接口获取数据，利用&lt;code&gt;v-for&lt;/code&gt;渲染&lt;code&gt;DOM&lt;/code&gt;后，再在&lt;code&gt;mounted&lt;/code&gt;里面调用渲染后的&lt;code&gt;DOM&lt;/code&gt;时，一直无法获取到，显示为&lt;code&gt;undefined&lt;/code&gt;。&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="web" scheme="http://yaliixxg.github.io/categories/web/"/>
    
    
      <category term="vue 生命周期" scheme="http://yaliixxg.github.io/tags/vue-%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/"/>
    
  </entry>
  
  <entry>
    <title>Generator知识点</title>
    <link href="http://yaliixxg.github.io/2018/07/17/gntr-SN/"/>
    <id>http://yaliixxg.github.io/2018/07/17/gntr-SN/</id>
    <published>2018-07-17T03:12:05.000Z</published>
    <updated>2018-07-17T06:56:42.809Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Generator"><a href="#Generator" class="headerlink" title="Generator"></a>Generator</h1><p>Generator 函数有多种理解角度。语法上，首先可以把它理解成，Generator 函数是一个状态机，封装了多个内部状态。</p><p>执行 Generator 函数会返回一个遍历器对象，也就是说，Generator 函数除了状态机，还是一个遍历器对象生成函数。返回的遍历器对象，可以依次遍历 Generator 函数内部的每一个状态。  </p><ul><li><p>Generator 函数有两个特征：  </p><ul><li><code>function</code>关键字与函数名之间有一个<code>星号</code></li><li><p>函数体内部使用<code>yield</code>表达式，定义不同的内部状态（<code>yield</code>在英语里的意思就是“产出”）  </p><a id="more"></a><pre><code>function* helloWorldGenerator() {yield &apos;hello&apos;;yield &apos;world&apos;;return &apos;ending&apos;;}var hw = helloWorldGenerator(); hw.next()// { value: &apos;hello&apos;, done: false } value属性就是当前yield表达式的值，done属性为false，表示遍历还没有结束。hw.next()// { value: &apos;world&apos;, done: false }hw.next()// { value: &apos;ending&apos;, done: true }hw.next()// { value: undefined, done: true } done属性为true，表示遍历已经结束。   </code></pre></li></ul></li></ul><p>上面代码定义了一个 Generator 函数<code>helloWorldGenerator</code>，它内部有两个<code>yield</code>表达式（<code>hello</code>和<code>world</code>），即该函数有三个状态：hello，world 和 return 语句（结束执行）。<br>调用方法与普通函数一样，但是调用，函数并不执行，返回一个指向内部状态的指针对象，也就是遍历器对象。<br>必须调用遍历器对象的<code>next</code>方法，使得指针移向下一个状态。内部指针就从函数头部或上一次停下来的地方开始执行，直到遇到下一个<code>yield</code>表达式（或<code>return</code>语句）为止。<br>换言之，Generator 函数是分段执行的，<code>yield</code>表达式是暂停执行的标记，而<code>next</code>方法可以恢复执行。  </p><h2 id="yield-表达式"><a href="#yield-表达式" class="headerlink" title="yield 表达式"></a>yield 表达式</h2><p>由于 Generator 函数返回的遍历器对象，只有调用<code>next</code>方法才会遍历下一个内部状态，所以其实提供了一种可以暂停执行的函数。<code>yield</code>表达式就是暂停标志。因此等于为 JavaScript 提供了手动的“惰性求值”（Lazy Evaluation）的语法功能。<br><code>yield</code>表达式只能用在 Generator 函数里面，用在其他地方都会报错。</p><h2 id="next-方法的参数"><a href="#next-方法的参数" class="headerlink" title="next 方法的参数"></a>next 方法的参数</h2><p><code>yield</code>表达式本身没有返回值，或者说总是返回<code>undefined</code>。<code>next</code>方法可以带一个参数，该参数就会被当作上一个<code>yield</code>表达式的返回值。  </p><pre><code>function* foo(x) {var y = 2 * (yield (x + 1));var z = yield (y / 3);return (x + y + z);}var a = foo(5);a.next() // Object{value:6, done:false}a.next() // Object{value:NaN, done:false}a.next() // Object{value:NaN, done:true}var b = foo(5);b.next() // { value:6, done:false }b.next(12) // { value:8, done:false }b.next(13) // { value:42, done:true }  </code></pre><p>上面代码中，第二次运行<code>next</code>方法的时候不带参数，导致 <code>y</code> 的值等于<code>2 * undefined</code>（即<code>NaN</code>），除以 <code>3</code> 以后还是<code>NaN</code>，因此返回对象的<code>value</code>属性也等于<code>NaN</code>。第三次运行<code>Next</code>方法的时候不带参数，所以<code>z</code>等于<code>undefined</code>，返回对象的<code>value</code>属性等于<code>5 + NaN + undefined</code>，即<code>NaN</code>。</p><p>如果向<code>next</code>方法提供参数，返回结果就完全不一样了。上面代码第一次调用b的<code>next</code>方法时，返回<code>x+1</code>的值<code>6</code>；第二次调用<code>next</code>方法，将上一次<code>yield</code>表达式的值设为<code>12</code>，因此<code>y</code>等于<code>24</code>，返回<code>y / 3</code>的值<code>8</code>；第三次调用<code>next</code>方法，将上一次<code>yield</code>表达式的值设为<code>13</code>，因此z等于<code>13</code>，这时<code>x</code>等于<code>5</code>，<code>y</code>等于<code>24</code>，所以<code>return</code>语句的值等于<code>42</code>。</p><p>注意，由于<code>next</code>方法的参数表示上一个<code>yield</code>表达式的返回值，所以在第一次使用<code>next</code>方法时，传递参数是无效的。V8 引擎直接忽略第一次使用<code>next</code>方法时的参数，只有从第二次使用<code>next</code>方法开始，参数才是有效的。从语义上讲，第一个<code>next</code>方法用来启动遍历器对象，所以不用带有参数。  </p><p><code>next</code>方法的参数，也可以向Generator 函数内部输入值  </p><pre><code>function* dataConsumer() {console.log(&apos;Started&apos;);console.log(`1. ${yield}`);console.log(`2. ${yield}`);return &apos;result&apos;;}let genObj = dataConsumer();genObj.next();// StartedgenObj.next(&apos;a&apos;)// 1. agenObj.next(&apos;b&apos;)// 2. b  </code></pre><h2 id="for…of-循环"><a href="#for…of-循环" class="headerlink" title="for…of 循环"></a>for…of 循环</h2><p><code>for...of</code>循环可以自动遍历 Generator 函数时生成的<code>Iterator</code>对象，且此时不再需要调用<code>next</code>方法。</p><pre><code>function* foo() {yield 1;yield 2;yield 3;yield 4;yield 5;return 6; //return语句返回的，不包括在for...of循环之中}for (let v of foo()) {console.log(v);}// 1 2 3 4 5  </code></pre><p>除了<code>for...of</code>循环以外，扩展运算符（<code>...</code>）、解构赋值和<code>Array.from</code>方法内部调用的，都是遍历器接口。这意味着，它们都可以将 Generator 函数返回的 Iterator 对象，作为参数。 </p><pre><code>function* numbers () {yield 1yield 2return 3yield 4}// 扩展运算符[...numbers()] // [1, 2]// Array.from 方法Array.from(numbers()) // [1, 2]// 解构赋值let [x, y] = numbers();x // 1y // 2// for...of 循环for (let n of numbers()) {console.log(n)}// 1// 2  </code></pre><h2 id="Generator-prototype-throw"><a href="#Generator-prototype-throw" class="headerlink" title="Generator.prototype.throw()"></a>Generator.prototype.throw()</h2><p>Generator 函数返回的遍历器对象，都有一个<code>throw</code>方法，可以在函数体外抛出错误，然后在 Generator 函数体内捕获。 </p><pre><code>var g = function* () {try {    yield;} catch (e) {    console.log(&apos;内部捕获&apos;, e);}};var i = g();i.next();try {i.throw(&apos;a&apos;);i.throw(&apos;b&apos;);} catch (e) {console.log(&apos;外部捕获&apos;, e);}// 内部捕获 a// 外部捕获 b  </code></pre><p>一旦执行了<code>catch</code>，捕捉了错误，Generator 函数就已经结束了，不再执行下去了。  </p><h2 id="Generator-prototype-return"><a href="#Generator-prototype-return" class="headerlink" title="Generator.prototype.return()"></a>Generator.prototype.return()</h2><p>Generator 函数返回的遍历器对象，还有一个<code>return</code>方法，可以返回给定的值，并且终结遍历 Generator 函数。  </p><h2 id="next-、throw-、return-的共同点"><a href="#next-、throw-、return-的共同点" class="headerlink" title="next()、throw()、return() 的共同点"></a>next()、throw()、return() 的共同点</h2><p>本质上是同一件事，可以放在一起理解。它们的作用都是让 Generator 函数恢复执行，并且使用不同的语句替换<code>yield</code>表达式。<br><code>next()</code>是将<code>yield</code>表达式替换成一个值。  </p><pre><code>const g = function* (x, y) {let result = yield x + y;return result;};const gen = g(1, 2);gen.next(); // Object {value: 3, done: false}gen.next(1); // Object {value: 1, done: true}// 相当于将 let result = yield x + y// 替换成 let result = 1;  </code></pre><p><code>throw()</code>是将<code>yield</code>表达式替换成一个<code>throw</code>语句。  </p><pre><code>gen.throw(new Error(&apos;出错了&apos;)); // Uncaught Error: 出错了// 相当于将 let result = yield x + y// 替换成 let result = throw(new Error(&apos;出错了&apos;));  </code></pre><p><code>return()</code>是将<code>yield</code>表达式替换成一个<code>return</code>语句。  </p><pre><code>gen.return(2); // Object {value: 2, done: true}// 相当于将 let result = yield x + y// 替换成 let result = return 2;  </code></pre><h2 id="yield-表达式-1"><a href="#yield-表达式-1" class="headerlink" title="yield* 表达式"></a>yield* 表达式</h2><p>如果在 Generator 函数内部，调用另一个 Generator 函数，默认情况下是没有效果的。<code>yield*</code>表达式，用来在一个 Generator 函数里面执行另一个 Generator 函数。</p><pre><code>function* foo() {yield &apos;a&apos;;yield &apos;b&apos;;}//普通方法调用foo() ==========================function* bar() {yield &apos;x&apos;;foo(); yield &apos;y&apos;;}for (let v of bar()){console.log(v);}// &quot;x&quot;// &quot;y&quot;  //上面foo()的调用是没有效果的//yield*表达式调用 =================================function* bar() {yield &apos;x&apos;;yield* foo();yield &apos;y&apos;;}// 等同于function* bar() {yield &apos;x&apos;;yield &apos;a&apos;;yield &apos;b&apos;;yield &apos;y&apos;;}// 等同于function* bar() {yield &apos;x&apos;;for (let v of foo()) {    yield v;}yield &apos;y&apos;;}for (let v of bar()){console.log(v);}// &quot;x&quot;// &quot;a&quot;// &quot;b&quot;// &quot;y&quot;</code></pre><p>从语法角度看，如果<code>yield</code>表达式后面跟的是一个遍历器对象，需要在yield表达式后面加上星号，表明它返回的是一个遍历器对象。这被称为<code>yield*</code>表达式。  </p><p><code>yield*</code>后面的 Generator 函数（没有return语句时），等同于在 Generator 函数内部，部署一个<code>for...of</code>循环。</p><pre><code>function* concat(iter1, iter2) {yield* iter1;yield* iter2;}// 等同于function* concat(iter1, iter2) {for (var value of iter1) {    yield value;}for (var value of iter2) {    yield value;}}  </code></pre><p>上面代码说明，<code>yield*</code>后面的 Generator 函数（没有<code>return</code>语句时），不过是<code>for...of</code>的一种简写形式，完全可以用后者替代前者。反之，在有<code>return</code>语句时，则需要用<code>var value = yield* iterator</code>的形式获取<code>return</code>语句的值。</p><h4 id="实际上，任何数据结构只要有-Iterator-接口，就可以被yield-遍历。"><a href="#实际上，任何数据结构只要有-Iterator-接口，就可以被yield-遍历。" class="headerlink" title="实际上，任何数据结构只要有 Iterator 接口，就可以被yield*遍历。"></a>实际上，任何数据结构只要有 Iterator 接口，就可以被yield*遍历。</h4><p><code>yield*</code>命令可以很方便地取出嵌套数组的所有成员。</p><pre><code>function* iterTree(tree) {if (Array.isArray(tree)) {    for(let i=0; i &lt; tree.length; i++) {    yield* iterTree(tree[i]);    }} else {    yield tree;}}const tree = [ &apos;a&apos;, [&apos;b&apos;, &apos;c&apos;], [&apos;d&apos;, &apos;e&apos;] ];for(let x of iterTree(tree)) {console.log(x);}// a// b// c// d// e </code></pre><h2 id="Generator-函数的this"><a href="#Generator-函数的this" class="headerlink" title="Generator 函数的this"></a>Generator 函数的this</h2><p>Generator 函数g返回的遍历器<code>obj</code>，是g的实例，而且继承了<code>g.prototype</code>。但是，如果把g当作普通的构造函数，并不会生效，因为g返回的总是遍历器对象，而不是<code>this</code>对象,也不能跟new命令一起用，会报错。  </p><p>下面是一个变通方法。首先，生成一个空对象，使用<code>call</code>方法绑定 Generator 函数内部的this。这样，构造函数调用以后，这个空对象就是 Generator 函数的实例对象了。  </p><pre><code>function* F() {this.a = 1;yield this.b = 2;yield this.c = 3;}var obj = {};var f = F.call(obj);f.next();  // Object {value: 2, done: false}f.next();  // Object {value: 3, done: false}f.next();  // Object {value: undefined, done: true}obj.a // 1obj.b // 2obj.c // 3  </code></pre><p>还有一个办法就是将obj换成<code>F.prototype</code>。</p><pre><code>function* F() {this.a = 1;yield this.b = 2;yield this.c = 3;}var f = F.call(F.prototype);f.next();  // Object {value: 2, done: false}f.next();  // Object {value: 3, done: false}f.next();  // Object {value: undefined, done: true}f.a // 1f.b // 2f.c // 3  </code></pre><p>再将F改成构造函数，就可以对它执行<code>new</code>命令了。</p><pre><code>function* gen() {this.a = 1;yield this.b = 2;yield this.c = 3;}function F() {return gen.call(gen.prototype);}var f = new F();f.next();  // Object {value: 2, done: false}f.next();  // Object {value: 3, done: false}f.next();  // Object {value: undefined, done: true}f.a // 1f.b // 2f.c // 3</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Generator&quot;&gt;&lt;a href=&quot;#Generator&quot; class=&quot;headerlink&quot; title=&quot;Generator&quot;&gt;&lt;/a&gt;Generator&lt;/h1&gt;&lt;p&gt;Generator 函数有多种理解角度。语法上，首先可以把它理解成，Generator 函数是一个状态机，封装了多个内部状态。&lt;/p&gt;
&lt;p&gt;执行 Generator 函数会返回一个遍历器对象，也就是说，Generator 函数除了状态机，还是一个遍历器对象生成函数。返回的遍历器对象，可以依次遍历 Generator 函数内部的每一个状态。  &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;Generator 函数有两个特征：  &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;function&lt;/code&gt;关键字与函数名之间有一个&lt;code&gt;星号&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;函数体内部使用&lt;code&gt;yield&lt;/code&gt;表达式，定义不同的内部状态（&lt;code&gt;yield&lt;/code&gt;在英语里的意思就是“产出”）  &lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;/li&gt;&lt;/ul&gt;
    
    </summary>
    
      <category term="web" scheme="http://yaliixxg.github.io/categories/web/"/>
    
    
      <category term="Generator" scheme="http://yaliixxg.github.io/tags/Generator/"/>
    
  </entry>
  
  <entry>
    <title>《InterviewMap 面试图谱》总结笔记</title>
    <link href="http://yaliixxg.github.io/2018/07/16/interviewMap-SN/"/>
    <id>http://yaliixxg.github.io/2018/07/16/interviewMap-SN/</id>
    <published>2018-07-16T06:12:05.000Z</published>
    <updated>2018-07-17T09:31:26.857Z</updated>
    
    <content type="html"><![CDATA[<h1 id="一、JavaScript"><a href="#一、JavaScript" class="headerlink" title="一、JavaScript"></a>一、JavaScript</h1><h2 id="七种内置类型"><a href="#七种内置类型" class="headerlink" title="七种内置类型"></a>七种内置类型</h2><ul><li>基本类型  <ul><li>null  </li><li>undefined  </li><li>boolean</li><li>number  </li><li>string  </li><li>symbol  </li></ul></li><li>对象(Object)<br>注意：null是基本类型，但是typeof null会显示object <a id="more"></a> <h2 id="类型转换"><a href="#类型转换" class="headerlink" title="类型转换"></a>类型转换</h2><h3 id="对象转基本类型"><a href="#对象转基本类型" class="headerlink" title="对象转基本类型"></a>对象转基本类型</h3>对象在转换基本类型时，首先会调用 valueOf 然后调用 toString。并且这两个方法你是可以重写的。  <h3 id="操作符"><a href="#操作符" class="headerlink" title="操作符"></a>操作符</h3><img src="/2018/07/16/interviewMap-SN/map1.png" alt="map1">  <h3 id="new"><a href="#new" class="headerlink" title="new"></a>new</h3></li><li>新生成了一个对象</li><li>链接到原型</li><li>绑定 this</li><li>返回新对象  </li></ul><p>对于创建一个对象来说，更推荐使用字面量的方式创建对象（无论性能上还是可读性）。因为你使用 new Object() 的方式创建对象需要通过作用域链一层层找到 Object，但是你使用字面量的方式就没这个问题。  </p><p>对于 new 来说，还需要注意下运算符优先级。  </p><pre><code>function Foo() {    return this;}Foo.getName = function () {    console.log(&apos;1&apos;);};Foo.prototype.getName = function () {    console.log(&apos;2&apos;);};new Foo.getName();   // -&gt; 1new Foo().getName(); // -&gt; 2   </code></pre><p>new Foo()的优先级大于 new Foo，所以对于上述代码来说可以这样划分执行顺序  </p><pre><code>new (Foo.getName());   (new Foo()).getName();</code></pre><p>对于第一个函数来说，先执行了 Foo.getName() ，所以结果为 1；对于后者来说，先执行 new Foo() 产生了一个实例，然后通过原型链找到了 Foo 上的 getName 函数，所以结果为 2。  </p><h2 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h2><p>闭包的定义很简单：函数 A 返回了一个函数 B，并且函数 B 中使用了函数 A 的变量，函数 B 就被称为闭包。</p><h2 id="深浅拷贝"><a href="#深浅拷贝" class="headerlink" title="深浅拷贝"></a>深浅拷贝</h2><pre><code>let a = {    age: 1}let b = aa.age = 2console.log(b.age) // 2  </code></pre><p>从上述例子中我们可以发现，如果给一个变量赋值一个对象，那么两者的值会是同一个引用，其中一方改变，另一方也会相应改变。</p><p>通常在开发中我们不希望出现这样的问题，我们可以使用浅拷贝来解决这个问题。  </p><h3 id="浅拷贝"><a href="#浅拷贝" class="headerlink" title="浅拷贝"></a>浅拷贝</h3><h4 id="object-assign-target-source1-source2-方法用于对象的合并，将源对象（-source-）的所有可枚举属性，复制到目标对象（-target-）。如果目标对象与源对象有同名属性，或多个源对象有同名属性，则后面的属性会覆盖前面的属性。"><a href="#object-assign-target-source1-source2-方法用于对象的合并，将源对象（-source-）的所有可枚举属性，复制到目标对象（-target-）。如果目标对象与源对象有同名属性，或多个源对象有同名属性，则后面的属性会覆盖前面的属性。" class="headerlink" title="object.assign(target, source1, source2) 方法用于对象的合并，将源对象（ source ）的所有可枚举属性，复制到目标对象（ target ）。如果目标对象与源对象有同名属性，或多个源对象有同名属性，则后面的属性会覆盖前面的属性。"></a>object.assign(target, source1, source2) 方法用于对象的合并，将源对象（ source ）的所有可枚举属性，复制到目标对象（ target ）。如果目标对象与源对象有同名属性，或多个源对象有同名属性，则后面的属性会覆盖前面的属性。</h4><pre><code>let a = {    age: 1}let b = Object.assign({}, a)a.age = 2console.log(b.age) // 1  </code></pre><h4 id="我们也可以通过展开运算符（…）来解决"><a href="#我们也可以通过展开运算符（…）来解决" class="headerlink" title="我们也可以通过展开运算符（…）来解决"></a>我们也可以通过展开运算符（…）来解决</h4><pre><code>let a = {    age: 1}let b = {...a}a.age = 2console.log(b.age) // 1  </code></pre><h3 id="深拷贝"><a href="#深拷贝" class="headerlink" title="深拷贝"></a>深拷贝</h3><p>如果拷贝的对象里面还包含对象的话，则需要深拷贝来解决。  </p><h4 id="可以通过-JSON-parse-JSON-stringify-object-来解决。"><a href="#可以通过-JSON-parse-JSON-stringify-object-来解决。" class="headerlink" title="可以通过 JSON.parse(JSON.stringify(object)) 来解决。"></a>可以通过 JSON.parse(JSON.stringify(object)) 来解决。</h4><pre><code>let a = {    age: 1,    jobs: {        first: &apos;FE&apos;    }}let b = JSON.parse(JSON.stringify(a))a.jobs.first = &apos;native&apos;console.log(b.jobs.first) // FE  </code></pre><h4 id="如果你所需拷贝的对象含有内置类型并且不包含函数，可以使用-MessageChannel。（具体搜索实例）"><a href="#如果你所需拷贝的对象含有内置类型并且不包含函数，可以使用-MessageChannel。（具体搜索实例）" class="headerlink" title="如果你所需拷贝的对象含有内置类型并且不包含函数，可以使用 MessageChannel。（具体搜索实例）"></a>如果你所需拷贝的对象含有内置类型并且不包含函数，可以使用 MessageChannel。（具体搜索实例）</h4><h2 id="模块化"><a href="#模块化" class="headerlink" title="模块化"></a>模块化</h2><p>ES6 的模块化(在有 Babel 的情况下使用)。  </p><p>CommonJs 是 Node 独有的规范，浏览器中使用就需要用到 Browserify 解析了。  </p><p>AMD 是由 RequireJS 提出的 </p><h4 id="对于-CommonJS-和-ES6-中的模块化的两者区别是："><a href="#对于-CommonJS-和-ES6-中的模块化的两者区别是：" class="headerlink" title="对于 CommonJS 和 ES6 中的模块化的两者区别是："></a>对于 CommonJS 和 ES6 中的模块化的两者区别是：</h4><ul><li><p>前者支持动态导入，也就是 require(${path}/xx.js)，后者目前不支持，但是已有提案</p></li><li><p>前者是同步导入，因为用于服务端，文件都在本地，同步导入即使卡住主线程影响也不大。而后者是异步导入，因为用于浏览器，需要下载文件，如果也采用导入会对渲染有很大影响</p></li><li><p>前者在导出时都是值拷贝，就算导出的值变了，导入的值也不会改变，所以如果想更新值，必须重新导入一次。但是后者采用实时绑定的方式，导入导出的值都指向同一个内存地址，所以导入值会跟随导出值变化</p></li><li><p>后者会编译成 require/exports 来执行的  </p></li></ul><h4 id="AMD-语法"><a href="#AMD-语法" class="headerlink" title="AMD 语法"></a>AMD 语法</h4><p>requireJS定义了一个函数 define，它是全局变量，用来定义模块</p><p>define(id?, dependencies?, factory);</p><ol><li>id：可选参数，用来定义模块的标识，如果没有提供该参数，脚本文件名（去掉拓展名）</li><li>dependencies：是一个当前模块依赖的模块名称数组</li><li><p>factory：工厂方法，模块初始化要执行的函数或对象。如果为函数，它应该只被执行一次。如果是对象，此对象应该为模块的输出值  </p><pre><code>// AMDdefine([&apos;./a&apos;, &apos;./b&apos;], function(a, b) {    a.do()    b.do()})define(function(require, exports, module) {       var a = require(&apos;./a&apos;)      a.doSomething()       var b = require(&apos;./b&apos;)    b.doSomething()})  </code></pre></li></ol><h2 id="防抖"><a href="#防抖" class="headerlink" title="防抖"></a>防抖</h2><h4 id="将多次执行变为最后一次执行"><a href="#将多次执行变为最后一次执行" class="headerlink" title="将多次执行变为最后一次执行"></a>将多次执行变为最后一次执行</h4><blockquote><p>指频繁触发的情况下，只有足够的空闲时间，才执行代码一次。比如生活中的坐公交，就是一定时间内，如果有人陆续刷卡上车，司机就不会开车。只有别人没刷卡了，司机才开车。 </p><ul><li>对于按钮防点击来说的实现：一旦我开始一个定时器，只要我定时器还在，不管你怎么点击都不会执行回调函数。一旦定时器结束并设置为 null，就可以再次点击了。</li><li>对于延时执行函数来说的实现：每次调用防抖动函数都会判断本次调用和之前的时间间隔，如果小于需要的时间间隔，就会重新创建一个定时器，并且定时器的延时为设定时间减去之前的时间间隔。一旦时间到了，就会执行相应的回调函数。  </li></ul></blockquote><h2 id="节流"><a href="#节流" class="headerlink" title="节流"></a>节流</h2><h4 id="将多次执行变成每隔一段时间执行。"><a href="#将多次执行变成每隔一段时间执行。" class="headerlink" title="将多次执行变成每隔一段时间执行。"></a>将多次执行变成每隔一段时间执行。</h4><blockquote><p>指一定时间内js方法只跑一次。比如人的眨眼睛，就是一定时间内眨一次。这是函数节流最形象的解释。  </p></blockquote><h2 id="继承-（详情见ES6阮一峰-class用法、继承）"><a href="#继承-（详情见ES6阮一峰-class用法、继承）" class="headerlink" title="继承 （详情见ES6阮一峰 class用法、继承）"></a>继承 （详情见ES6阮一峰 class用法、继承）</h2><h2 id="call-apply-bind区别"><a href="#call-apply-bind区别" class="headerlink" title="call,apply,bind区别"></a>call,apply,bind区别</h2><p><code>call</code> 和 <code>apply</code> 都是为了解决改变 this 的指向。作用都是相同的，只是传参的方式不同。<br>除了第一个参数外，call 可以接收一个参数列表，apply 只接受一个参数数组。</p><pre><code>let a = {    value: 1}function getValue(name, age) {    console.log(name)    console.log(age)    console.log(this.value)}getValue.call(a, &apos;yck&apos;, &apos;24&apos;)getValue.apply(a, [&apos;yck&apos;, &apos;24&apos;])  </code></pre><p><code>bind</code>和其他两个方法作用也是一致的，只是该方法会返回一个函数。并且我们可以通过 bind 实现柯里化。<br><code>柯里化</code>是指将使用多个参数的函数转换成一系列使用一个参数的函数的技术。</p><h2 id="Promise-实现-（详情见ES6阮一峰）"><a href="#Promise-实现-（详情见ES6阮一峰）" class="headerlink" title="Promise 实现 （详情见ES6阮一峰）"></a>Promise 实现 （详情见ES6阮一峰）</h2><p>可以把 Promise 看成一个状态机。初始是 <code>pending</code> 状态，可以通过函数 <code>resolve</code> 和 <code>reject</code> ，将状态转变为 resolved(已定型) 或者 rejected(已失败) 状态，状态一旦改变就不能再次变化。<br><code>then</code> 函数会返回一个 Promise 实例，并且该返回值是一个新的实例而不是之前的实例。  </p><h2 id="Generator-实现-详情见另一篇博客《Generator知识点杂烩》"><a href="#Generator-实现-详情见另一篇博客《Generator知识点杂烩》" class="headerlink" title="Generator 实现 (详情见另一篇博客《Generator知识点杂烩》)"></a>Generator 实现 (详情见另一篇博客《Generator知识点杂烩》)</h2><h2 id="Map、FlapMap-和-Reduce"><a href="#Map、FlapMap-和-Reduce" class="headerlink" title="Map、FlapMap 和 Reduce"></a>Map、FlapMap 和 Reduce</h2><p><code>Map</code> 作用是生成一个新数组，遍历原数组，将每个元素拿出来做一些变换然后 <code>append</code> 到新的数组中。</p><pre><code>[1,2,3].map((item)=&gt; item + 1)// -&gt; [2,3,4]  </code></pre><p><code>FlapMap</code> 和 <code>map</code> 的作用几乎是相同的，但是对于多维数组来说，会将原数组降维。可以将 <code>FlapMap</code> 看成是 <code>map + flatten</code> ，目前该函数在浏览器中还不支持。  </p><pre><code>[1, [2], 3].flatMap((v) =&gt; v + 1)// -&gt; [2, 3, 4]</code></pre><p><code>Reduce</code> 作用是数组中的值组合起来，最终得到一个值<br>语法：<code>array.reduce(function(total, currentValue, currentIndex, arr), initialValue)</code>  </p><ul><li>total         必需。初始值, 或者计算结束后的返回值。  </li><li>currentValue  必需。当前元素</li><li>currentIndex  可选。当前元素的索引</li><li>arr           可选。当前元素所属的数组对象。  </li><li>initialValue  可选。传递给函数的初始值  </li></ul><p>如果想将一个多维数组彻底的降维，可以这样实现:  </p><pre><code>const flattenDeep = (arr) =&gt; Array.isArray(arr)? arr.reduce( (a, b) =&gt; [...flattenDeep(a), ...flattenDeep(b)] , []): [arr]flattenDeep([1, [[2], [3, [4]], 5]])  </code></pre>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;一、JavaScript&quot;&gt;&lt;a href=&quot;#一、JavaScript&quot; class=&quot;headerlink&quot; title=&quot;一、JavaScript&quot;&gt;&lt;/a&gt;一、JavaScript&lt;/h1&gt;&lt;h2 id=&quot;七种内置类型&quot;&gt;&lt;a href=&quot;#七种内置类型&quot; class=&quot;headerlink&quot; title=&quot;七种内置类型&quot;&gt;&lt;/a&gt;七种内置类型&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;基本类型  &lt;ul&gt;
&lt;li&gt;null  &lt;/li&gt;
&lt;li&gt;undefined  &lt;/li&gt;
&lt;li&gt;boolean&lt;/li&gt;
&lt;li&gt;number  &lt;/li&gt;
&lt;li&gt;string  &lt;/li&gt;
&lt;li&gt;symbol  &lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;对象(Object)&lt;br&gt;注意：null是基本类型，但是typeof null会显示object&lt;/li&gt;&lt;/ul&gt;
    
    </summary>
    
      <category term="web" scheme="http://yaliixxg.github.io/categories/web/"/>
    
    
      <category term="面试" scheme="http://yaliixxg.github.io/tags/%E9%9D%A2%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>《webpack文档》学习笔记</title>
    <link href="http://yaliixxg.github.io/2018/07/13/wbpk-SN/"/>
    <id>http://yaliixxg.github.io/2018/07/13/wbpk-SN/</id>
    <published>2018-07-13T01:18:00.000Z</published>
    <updated>2018-07-13T03:47:47.047Z</updated>
    
    <content type="html"><![CDATA[<h1 id="webpack"><a href="#webpack" class="headerlink" title="webpack"></a>webpack</h1><p>是一个现代 JavaScript 应用程序的静态模块打包器(module bundler)。当 webpack 处理应用程序时，它会递归地构建一个依赖关系图(dependency graph)，其中包含应用程序需要的每个模块，然后将所有这些模块打包成一个或多个 bundle。  </p><ul><li>入口(entry)</li><li>输出(output)</li><li>loader</li><li>插件(plugins)  <a id="more"></a></li></ul><h2 id="入口"><a href="#入口" class="headerlink" title="入口"></a>入口</h2><p>入口起点(entry point)指示 webpack 应该使用哪个模块，来作为构建其内部依赖图的开始。进入入口起点后，webpack 会找出有哪些模块和库是入口起点（直接和间接）依赖的。  </p><h3 id="单个入口简写语法："><a href="#单个入口简写语法：" class="headerlink" title="单个入口简写语法："></a>单个入口简写语法：</h3><p>  webpack.config.js  </p><pre><code>const config = {  entry: {    main: &apos;./path/to/my/entry/file.js&apos;  }};  </code></pre><h3 id="对象语法"><a href="#对象语法" class="headerlink" title="对象语法"></a>对象语法</h3><p> 1.分离应用程序(app)和第三方库(vendor)入口   </p><p>  webpack.config.js  </p><pre><code>const config = { entry: { app: &apos;./src/app.js&apos;, vendors: &apos;./src/vendors.js&apos; }}; </code></pre><p>2.多页面应用程序  </p><p>webpack.config.js  </p><pre><code>const config = { entry: { pageOne: &apos;./src/pageOne/index.js&apos;, pageTwo: &apos;./src/pageTwo/index.js&apos;, pageThree: &apos;./src/pageThree/index.js&apos; }}; </code></pre><p>这是我们告诉webpack需要三个独立分离的依赖图  </p><h2 id="输出"><a href="#输出" class="headerlink" title="输出"></a>输出</h2><p>output 属性告诉 webpack 在哪里输出它所创建的 bundles，以及如何命名这些文件，默认值为 ./dist。基本上，整个应用程序结构，都会被编译到你指定的输出路径的文件夹中。你可以通过在配置中指定一个 output 字段，来配置这些处理过程。  </p><h3 id="用法"><a href="#用法" class="headerlink" title="用法"></a>用法</h3><p>在 webpack 中配置 output 属性的最低要求是，将它的值设置为一个对象，包括以下两点：</p><ul><li>filename 用于输出文件的文件名。</li><li><p>目标输出目录 path 的绝对路径。  </p><p>webpack.config.js  </p><pre><code>const config = {      output: {        filename: &apos;bundle.js&apos;,        path: &apos;/home/proj/public/assets&apos;      }    };module.exports = config;</code></pre></li></ul><p>此配置将一个单独的 bundle.js 文件输出到 /home/proj/public/assets 目录中。  </p><h3 id="多个入口起点"><a href="#多个入口起点" class="headerlink" title="多个入口起点"></a>多个入口起点</h3><pre><code>{    entry:{        app:&apos;./src/app.js&apos;,        search:&apos;./src/search.js&apos;    },    output:{        filename:&apos;[name].js&apos;,        path: __dirname + &apos;/dist&apos;    }}//写入到硬盘：./dist/app.js,./dist/search.js </code></pre><h3 id="高级进阶"><a href="#高级进阶" class="headerlink" title="高级进阶"></a>高级进阶</h3><p>使用CDN和资源hash的复杂示例<br>config.js  </p><pre><code>output:{    path:&apos;home/proj/cdn/assets/[hash]&apos;,    publicPath:&apos;http://cdn.example.com/assets/[hash]/&apos;} </code></pre><p>在编译时不知道最终输出文件的 publicPath 的情况下，publicPath 可以留空，并且在入口起点文件运行时动态设置。如果你在编译时不知道 publicPath，你可以先忽略它，并且在入口起点设置 <strong>webpack_public_path</strong>。  </p><pre><code>__webpack_public_path__ = myRuntimePublicPath// 剩余的应用程序入口</code></pre><h2 id="loader"><a href="#loader" class="headerlink" title="loader"></a>loader</h2><p>loader 用于对模块的源代码进行转换。loader 可以使你在 import 或”加载”模块时预处理文件。因此，loader 类似于其他构建工具中“任务(task)”，并提供了处理前端构建步骤的强大方法。loader 可以将文件从不同的语言（如 TypeScript）转换为 JavaScript，或将内联图像转换为 data URL。loader 甚至允许你直接在 JavaScript 模块中 import CSS文件!  </p><h3 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h3><p>三种使用loader的方式：</p><ul><li>配置（推荐）：在 webpack.config.js 文件中指定 loader。  </li><li>内联：在每个 import 语句中显式指定 loader。（具体看文档）</li><li>CLI：在 shell 命令中指定它们。 （具体看文档）  </li></ul><h3 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h3><p>module.rules 允许你在 webpack 配置中指定多个 loader。 这是展示 loader 的一种简明方式，并且有助于使代码变得简洁。同时让你对各个 loader 有个全局概览：  </p><pre><code>module:{        rules:[            {                test:/\.css$/,                use:[                    {loader:&apos;style-loader&apos;},                    {                        loader:&apos;css-loader&apos;,                        options:{                            modules:true                        }                    }                ]            }        ]    }//loader 能够使用 options 对象进行配置。</code></pre><h2 id="插件"><a href="#插件" class="headerlink" title="插件"></a>插件</h2><p>插件是 webpack 的支柱功能。webpack 自身也是构建于，你在 webpack 配置中用到的相同的插件系统之上！</p><p>插件目的在于解决 loader 无法实现的其他事。  </p><h3 id="用法-1"><a href="#用法-1" class="headerlink" title="用法"></a>用法</h3><p>由于插件可以携带参数/选项，你必须在 webpack 配置中，向 plugins 属性传入 new 实例。  </p><p> webpack.config.js  </p><pre><code>const HtmlWebpackPlugin = require(&apos;html-webpack-plugin&apos;); //通过 npm 安装const webpack = require(&apos;webpack&apos;); //访问内置的插件const path = require(&apos;path&apos;);const config = {  entry: &apos;./path/to/my/entry/file.js&apos;,  output: {    filename: &apos;my-first-webpack.bundle.js&apos;,    path: path.resolve(__dirname, &apos;dist&apos;)  },  module: {    rules: [      {        test: /\.(js|jsx)$/,        use: &apos;babel-loader&apos;      }    ]  },  plugins: [    new webpack.optimize.UglifyJsPlugin(),    new HtmlWebpackPlugin({template: &apos;./src/index.html&apos;})  ]};module.exports = config;</code></pre><h2 id="配置-1"><a href="#配置-1" class="headerlink" title="配置"></a>配置</h2><p>因为 webpack 配置是标准的 Node.js CommonJS 模块，你可以做到以下事情：</p><ul><li>通过 require(…) 导入其他文件</li><li>通过 require(…) 使用 npm 的工具函数</li><li>使用 JavaScript 控制流表达式，例如 ?: 操作符</li><li>对常用值使用常量或变量</li><li>编写并执行函数来生成部分配置  </li></ul><h2 id="模块"><a href="#模块" class="headerlink" title="模块"></a>模块</h2><h3 id="什么是webpack模块"><a href="#什么是webpack模块" class="headerlink" title="什么是webpack模块"></a>什么是webpack模块</h3><ul><li>ES2015 import 语句</li><li>CommonJS require() 语句</li><li>AMD define 和 require 语句</li><li>css/sass/less 文件中的 @import 语句。</li><li>样式(url(…))或 HTML 文件(<code>&lt;img src=...&gt;</code>)中的图片链接(image url)</li></ul><h3 id="优化路径"><a href="#优化路径" class="headerlink" title="优化路径"></a>优化路径</h3><h4 id="1-resolve-extensions"><a href="#1-resolve-extensions" class="headerlink" title="1. resolve.extensions"></a>1. resolve.extensions</h4><p>　　在webpack.base.conf.js中，我们可以看到resolve配置，其中的extengsions是一个数组，如下所示：</p><pre><code>extensions: [&apos;.js&apos;, &apos;.vue&apos;, &apos;.json&apos;],</code></pre><p>　　通过这样的配置，我们在组件中过着路由中应用组件时，就可以更为方便的应用，比如：</p><p>  import Hello from ‘@components/Hello’;<br>　　即Hello.vue这个组件我们不需要添加.vue后缀就可以引用到了，如果不用extensions， 我们就必须要用@components/Hello.vue来引入这个文件。 </p><h4 id="2-resolve-alias"><a href="#2-resolve-alias" class="headerlink" title="2. resolve.alias"></a>2. resolve.alias</h4><p>　　在组件之间相互引用时，可能是下面这样的：</p><pre><code>import Hello from &apos;../src.components/Hello&apos;;  </code></pre><p>　　其中的路径是相对于当前页面的。 但是如果嵌套等更为复杂，那么写起来会比较麻烦。但是如果我们通过这样的配置：</p><pre><code>resolve: {  extensions: [&apos;.js&apos;, &apos;.vue&apos;, &apos;.json&apos;],  alias: {    &apos;vue$&apos;: &apos;vue/dist/vue.esm.js&apos;,    &apos;@pages&apos;: path.join(__dirname, &quot;..&quot;, &quot;src&quot;, &quot;pages&quot;),    &quot;@components&quot;: path.join(__dirname, &quot;..&quot;, &quot;src&quot;, &quot;components&quot;),    // 注意： 静态资源通过src，不能这么设置。    // &quot;@assets&quot;: path.join(__dirname, &quot;..&quot;, &quot;src&quot;, &quot;assets&quot;),  }</code></pre><p>其中vue$表示引入vue，就可以像下面这么写：  </p><pre><code>import Vue from &apos;vue&apos;  </code></pre><p>　　另外，对于@pages和@components我们就可以直接引用了，而省去了一大堆的复杂应用，另外通过@可以消除歧义。如下所示：</p><pre><code>import Hello from &apos;@components/Hello&apos;;import App from &apos;@pages/App&apos;  </code></pre><p>　　值得注意的时： 在webpack.config.js中我们不能使用../ 以及./这种形式的路径方式，而是通过 path.join 和 __dirname 这种形式来表示路径，否则会报错。</p><p>　　另外： 在组件中，我们会引用一些静态文件，即static下的文件， 这时我们就不能用 alias 下的配置了，而必须使用一般的配置方式。  </p><h2 id="构建目标"><a href="#构建目标" class="headerlink" title="构建目标"></a>构建目标</h2><p>因为服务器和浏览器代码都可以用 JavaScript 编写，所以 webpack 提供了多种构建目标(target)，你可以在你的 webpack 配置中设置。  </p><h3 id="用法-2"><a href="#用法-2" class="headerlink" title="用法"></a>用法</h3><p>要设置 target 属性，只需要在你的 webpack 配置中设置 target 的值。<br>webpack.config.js</p><pre><code>module.exports = {  target: &apos;node&apos;};  </code></pre><p>在上面例子中，使用 node webpack 会编译为用于「类 Node.js」环境（使用 Node.js 的 require ，而不是使用任意内置模块（如 fs 或 path）来加载 chunk）。  </p><h3 id="多个Target"><a href="#多个Target" class="headerlink" title="多个Target"></a>多个Target</h3><p>尽管 webpack 不支持向 target 传入多个字符串，你可以通过打包两份分离的配置来创建同构的库：<br>webpack.config.js</p><pre><code>var path = require(&apos;path&apos;);var serverConfig = {  target: &apos;node&apos;,  output: {    path: path.resolve(__dirname, &apos;dist&apos;),    filename: &apos;lib.node.js&apos;  }  //…};var clientConfig = {  target: &apos;web&apos;, // &lt;=== 默认是 &apos;web&apos;，可省略  output: {    path: path.resolve(__dirname, &apos;dist&apos;),    filename: &apos;lib.js&apos;  }  //…};module.exports = [ serverConfig, clientConfig ];</code></pre><p>上面的例子将在你的 dist 文件夹下创建 lib.js 和 lib.node.js 文件。</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;webpack&quot;&gt;&lt;a href=&quot;#webpack&quot; class=&quot;headerlink&quot; title=&quot;webpack&quot;&gt;&lt;/a&gt;webpack&lt;/h1&gt;&lt;p&gt;是一个现代 JavaScript 应用程序的静态模块打包器(module bundler)。当 webpack 处理应用程序时，它会递归地构建一个依赖关系图(dependency graph)，其中包含应用程序需要的每个模块，然后将所有这些模块打包成一个或多个 bundle。  &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;入口(entry)&lt;/li&gt;
&lt;li&gt;输出(output)&lt;/li&gt;
&lt;li&gt;loader&lt;/li&gt;
&lt;li&gt;插件(plugins)&lt;/li&gt;&lt;/ul&gt;
    
    </summary>
    
      <category term="web" scheme="http://yaliixxg.github.io/categories/web/"/>
    
    
      <category term="webpack" scheme="http://yaliixxg.github.io/tags/webpack/"/>
    
  </entry>
  
  <entry>
    <title>《图解HTTP》学习笔记</title>
    <link href="http://yaliixxg.github.io/2018/07/12/h/"/>
    <id>http://yaliixxg.github.io/2018/07/12/h/</id>
    <published>2018-07-12T03:49:00.000Z</published>
    <updated>2018-07-13T07:12:43.816Z</updated>
    
    <content type="html"><![CDATA[<h3 id="坚持-｡◕ˇ∀ˇ◕-HTTP-WebSocket"><a href="#坚持-｡◕ˇ∀ˇ◕-HTTP-WebSocket" class="headerlink" title="坚持 (｡◕ˇ∀ˇ◕) ,HTTP WebSocket"></a>坚持 (｡◕ˇ∀ˇ◕) ,HTTP WebSocket</h3><h1 id="HTTP"><a href="#HTTP" class="headerlink" title="HTTP"></a>HTTP</h1><p>超文本传输协议（超文本转移协议）</p><h3 id="TCP-IP"><a href="#TCP-IP" class="headerlink" title="TCP/IP"></a>TCP/IP</h3><p>互联网相关的各类协议族的总称，协议存在各式各样的内容。从电缆的规格到IP地址的选定方法、双方建立通信的顺序，以及web页面显示需要处理的步骤，等等。<br>按层次分别为：应用层、传输层、网络层、数据链路层。  </p><h4 id="从客户端发送请求到服务端接收请求流程如图："><a href="#从客户端发送请求到服务端接收请求流程如图：" class="headerlink" title="从客户端发送请求到服务端接收请求流程如图："></a>从客户端发送请求到服务端接收请求流程如图：</h4><p><img src="/2018/07/12/h/h2.png" alt="h2"><br><a id="more"></a></p><h3 id="IP"><a href="#IP" class="headerlink" title="IP"></a>IP</h3><p>IP协议的作用是把各种数据包传送给对方。而要确保传送到对方那里，则需要满足各类条件。其中最重要的条件是IP地址和MAC地址（网卡所属的固定地址）<br><img src="/2018/07/12/h/h3.png" alt="h3">  </p><h3 id="TCP"><a href="#TCP" class="headerlink" title="TCP"></a>TCP</h3><p>TCP位于传输层，提供可靠的字节流服务。为了更容易传达大数据把数据分割，确保数据能到达目标。<br>为了准确无误的将数据送达到目标出，采用三次握手策略。<br><img src="/2018/07/12/h/h4.png" alt="h4">  </p><h3 id="DNS"><a href="#DNS" class="headerlink" title="DNS"></a>DNS</h3><p>DNS位于应用层的协议。提供域名到IP地址之间的解析服务。<br><img src="/2018/07/12/h/h5.png" alt="h5">  </p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p><img src="/2018/07/12/h/h6.png" alt="http6">  </p><h3 id="告知服务器意图的HTTP方法"><a href="#告知服务器意图的HTTP方法" class="headerlink" title="告知服务器意图的HTTP方法"></a>告知服务器意图的HTTP方法</h3><p><img src="/2018/07/12/h/h7.png" alt="h7">  </p><h3 id="返回结果的HTTP状态码"><a href="#返回结果的HTTP状态码" class="headerlink" title="返回结果的HTTP状态码"></a>返回结果的HTTP状态码</h3><p><img src="/2018/07/12/h/h8.png" alt="h8">  </p><p>200:OK 表示从客户端发来的请求在服务器端被正常处理了。<br>204:No Content 表示客户端发来的请求处理成功，但是服务端没有资源科返回。一般按在只需要从客户端往服务器发送信息，而对客户端不需要发送新内容的情况下使用。<br>206:Partical Content 表示客户端进行了范围请求，而服务器成功执行了这一部分的GET请求。  </p><p>301:Moved Permanently 永久性重定向。该状态码表示请求的资源已被分配了新的URI，以后应使用资源现在所指的URI。<br>302:Found 临时性重定向。表示请求的资源已被分配了新的URI，希望用户（本次）能使用新的URI访问。<br>303:See Other 表示由于请求对应的资源存折另一个URI，应使用GET方法定向获取请求的资源。<br>304:Not Modified 表示客户端发送附带条件的请求时，服务器端允许请求访问资源，但为满足条件的情况。<br>307:Temporary Redirect 临时性重定向，和302一样。只是它会遵守标准，不会从POST变成GET。  </p><p>400:Bed Request 表示请求报文中存在语法错误。当错误发生时，需修改请求的内容后再次发送请求。<br>401:Unauthorized 表示发送的请求需要通过HTTP认证的认证信息。另外若之前已进行过一次请求，则表示用户认证失败。浏览器初次接收到401响应，会弹出认证用的对话窗口。<br>403:Forbidden 表情对请求资源的访问被服务器拒绝了。<br>404:Not Found 表明服务器上无法找到请求的资源。  </p><p>500:Internal Server Error 表明服务器端在执行请求时发生了错误。也有可能是web应用存在的BUG或某些临时的故障。<br>503:Service Unavailable 表明服务器暂时处于超负载或正在进行停机维护，现在无法处理请求。</p><h3 id="HTTP首部字段一览"><a href="#HTTP首部字段一览" class="headerlink" title="HTTP首部字段一览"></a>HTTP首部字段一览</h3><p><img src="/2018/07/12/h/h9.png" alt="h9"><br><img src="/2018/07/12/h/h10.png" alt="h10"><br><img src="/2018/07/12/h/h11.png" alt="h12"><br><img src="/2018/07/12/h/h12.png" alt="h12">  </p><h3 id="HTTPS"><a href="#HTTPS" class="headerlink" title="HTTPS"></a>HTTPS</h3><ul><li>HTTP的缺点：  <ul><li>通信使用明文（不加密），内容可能会被窃听  </li><li>不验证通信方的身份，因此有可能遭遇伪装</li><li>无法证明报文的额完整性，所以有可能已遭篡改</li></ul></li></ul><p>HTTPS（全称：Hyper Text Transfer Protocol over Secure Socket Layer 超文本传输安全协议），是以安全为目标的HTTP通道，简单讲是HTTP的安全版。即HTTP下加入SSL层（Secure Socket Layer，安全嵌套层）或 TSL（Transport Layer Security，安全层传输协议）的组合使用，HTTPS的安全基础是SSL，因此加密的详细内容就需要SSL。</p><ul><li><p>HTTPS和HTTP的区别<br>超文本传输协议HTTP协议被用于在Web浏览器和网站服务器之间传递信息。HTTP协议以明文方式发送内容，不提供任何方式的数据加密，如果攻击者截取了Web浏览器和网站服务器之间的传输报文，就可以直接读懂其中的信息，因此HTTP协议不适合传输一些敏感信息，比如信用卡号、密码等。<br>为了解决HTTP协议的这一缺陷，需要使用另一种协议：安全套接字层超文本传输协议HTTPS。为了数据传输的安全，HTTPS在HTTP的基础上加入了SSL协议，SSL依靠证书来验证服务器的身份，并为浏览器和服务器之间的通信加密。</p><h4 id="HTTPS和HTTP的区别主要为以下四点："><a href="#HTTPS和HTTP的区别主要为以下四点：" class="headerlink" title="HTTPS和HTTP的区别主要为以下四点："></a>HTTPS和HTTP的区别主要为以下四点：</h4><ul><li>一、https协议需要到ca申请证书，一般免费证书很少，需要交费。</li><li>二、http是超文本传输协议，信息是明文传输，https 则是具有安全性的ssl加密传输协议。</li><li>三、http和https使用的是完全不同的连接方式，用的端口也不一样，前者是80，后者是443。</li><li>四、http的连接很简单，是无状态的；HTTPS协议是由SSL+HTTP协议构建的可进行加密传输、身份认证的网络协议，比http协议安全。  </li></ul><h3 id="HTTPS-HTTP-加密-认证-完整性保护"><a href="#HTTPS-HTTP-加密-认证-完整性保护" class="headerlink" title="HTTPS = HTTP + 加密 + 认证 + 完整性保护"></a>HTTPS = HTTP + 加密 + 认证 + 完整性保护</h3><p>HTTPS采用混合加密机制<br><img src="/2018/07/12/h/h13.png" alt="h13">  </p></li></ul><h1 id="WebSocket"><a href="#WebSocket" class="headerlink" title="WebSocket"></a>WebSocket</h1><p>是HTML5开始提供的一种在单个 TCP 连接上进行全双工通讯的协议.<br>在WebSocket API中，浏览器和服务器只需要做一个握手的动作，然后，浏览器和服务器之间就形成了一条快速通道。两者之间就直接可以数据互相传送。</p><p>浏览器通过 JavaScript 向服务器发出建立 WebSocket 连接的请求，连接建立以后，客户端和服务器端就可以通过 TCP 连接直接交换数据。</p><p>当你获取 Web Socket 连接后，你可以通过 send() 方法来向服务器发送数据，并通过 onmessage 事件来接收服务器返回的数据。  </p><p>在程序设计中，这种设计叫做回调，即：你有信息了再来通知我，而不是我傻乎乎的每次跑来问你。<br>Websocket只需要一次HTTP握手，所以说整个通讯过程是建立在一次连接/状态中，也就避免了HTTP的非状态性，服务端会一直知道你的信息，直到你关闭请求，这样就解决了接线员要反复解析HTTP协议，还要查看identity info的信息。<br>同时由客户主动询问，转换为服务器（推送）有信息的时候就发送（当然客户端还是等主动发送信息过来的。。），没有信息的时候就交给接线员（Nginx），不需要占用本身速度就慢的客服（Handler）了   </p><pre><code>var Socket = new WebSocket(url, [protocol] );  </code></pre><p>以上代码中的第一个参数 url, 指定连接的 URL。第二个参数 protocol 是可选的，指定了可接受的子协议。  </p><h4 id="WebSocket属性"><a href="#WebSocket属性" class="headerlink" title="WebSocket属性"></a>WebSocket属性</h4><ul><li>Socket.readyState（只读属性， readyState 表示连接状态）<ul><li>0 - 表示连接尚未建立。</li><li>1 - 表示连接已建立，可以进行通信。</li><li>2 - 表示连接正在进行关闭。</li><li>3 - 表示连接已经关闭或者连接不能打开。  </li></ul></li><li>Socket.bufferedAmount（只读属性bufferedAmount 已被 send() 放入正在队列中等待传输，但是还没有发出的 UTF-8 文本字节数。）  </li></ul><h4 id="WebSocket-事件"><a href="#WebSocket-事件" class="headerlink" title="WebSocket 事件"></a>WebSocket 事件</h4><p>以下是 WebSocket 对象的相关事件。假定我们使用了以上代码创建了 Socket 对象：  </p><ul><li>open  <ul><li>Socket.onopen    连接建立时触发  </li></ul></li><li>message  <ul><li>Socket.onmessage 客户端接收服务端数据时触发</li></ul></li><li>error  <ul><li>Socket.onerror   通信发生错误时触发</li></ul></li><li>close  <ul><li>Socket.onclose   连接关闭时触发  </li></ul></li></ul><h4 id="WebSocket-方法"><a href="#WebSocket-方法" class="headerlink" title="WebSocket 方法"></a>WebSocket 方法</h4><p>以下是 WebSocket 对象的相关事件。假定我们使用了以上代码创建了 Socket 对象：  </p><ul><li>Socket.send()  使用连接发送数据  </li><li>Socket.close() 关闭连接  </li></ul><h4 id="WebSocket-实例"><a href="#WebSocket-实例" class="headerlink" title="WebSocket 实例"></a>WebSocket 实例</h4><p>目前大部分浏览器支持 WebSocket() 接口，你可以在以下浏览器中尝试实例： Chrome, Mozilla, Opera 和 Safari。  </p><pre><code>&lt;script type=&quot;text/javascript&quot;&gt;        function WebSocketTest()        {           if (&quot;WebSocket&quot; in window)           {              alert(&quot;您的浏览器支持 WebSocket!&quot;);              // 打开一个 web socket              var ws = new WebSocket(&quot;ws://localhost:9998/echo&quot;);              ws.onopen = function()              {                 // Web Socket 已连接上，使用 send() 方法发送数据                 ws.send(&quot;发送数据&quot;);                 alert(&quot;数据发送中...&quot;);              };              ws.onmessage = function (evt)               {                  var received_msg = evt.data;                 alert(&quot;数据已接收...&quot;);              };              ws.onclose = function()              {                  // 关闭 websocket                 alert(&quot;连接已关闭...&quot;);               };           }           else           {              // 浏览器不支持 WebSocket              alert(&quot;您的浏览器不支持 WebSocket!&quot;);           }        } &lt;/script&gt; </code></pre><h5 id="安装pywebsocket"><a href="#安装pywebsocket" class="headerlink" title="安装pywebsocket"></a>安装pywebsocket</h5><p>在执行以上程序前，我们需要创建一个支持 WebSocket 的服务。从 pywebsocket 下载 mod_pywebsocket ,或者使用 git 命令下载：  </p><pre><code>git clone https://github.com/google/pywebsocket.git  </code></pre><p>mod_pywebsocket 需要 python 环境支持</p><p>mod_pywebsocket 是一个 Apache HTTP 的 Web Socket扩展，安装步骤如下：  </p><ul><li>解压下载的文件。  </li><li>进入pywebsocket目录。  </li><li>执行命令：  <pre><code>$ python setup.py build$ sudo python setup.py install  </code></pre></li><li>查看文档说明：  <pre><code>$ pydoc mod_pywebsocket  </code></pre><h4 id="开启服务"><a href="#开启服务" class="headerlink" title="开启服务"></a>开启服务</h4>在 pywebsocket/mod_pywebsocket 目录下执行以下命令：  <pre><code>$ sudo python standalone.py -p 9998 -w ../example/  </code></pre>以上命令会开启一个端口号为 9998 的服务，使用 -w 来设置处理程序 echo_wsh.py 所在的目录。</li></ul><p>现在我们可以在 Chrome 浏览器打开前面创建的 runoob_websocket.html 文件。如果你的浏览器支持 WebSocket(), 点击”运行 WebSocket”，你就可以看到整个流程各个步骤弹出的窗口</p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;坚持-｡◕ˇ∀ˇ◕-HTTP-WebSocket&quot;&gt;&lt;a href=&quot;#坚持-｡◕ˇ∀ˇ◕-HTTP-WebSocket&quot; class=&quot;headerlink&quot; title=&quot;坚持 (｡◕ˇ∀ˇ◕) ,HTTP WebSocket&quot;&gt;&lt;/a&gt;坚持 (｡◕ˇ∀ˇ◕) ,HTTP WebSocket&lt;/h3&gt;&lt;h1 id=&quot;HTTP&quot;&gt;&lt;a href=&quot;#HTTP&quot; class=&quot;headerlink&quot; title=&quot;HTTP&quot;&gt;&lt;/a&gt;HTTP&lt;/h1&gt;&lt;p&gt;超文本传输协议（超文本转移协议）&lt;/p&gt;
&lt;h3 id=&quot;TCP-IP&quot;&gt;&lt;a href=&quot;#TCP-IP&quot; class=&quot;headerlink&quot; title=&quot;TCP/IP&quot;&gt;&lt;/a&gt;TCP/IP&lt;/h3&gt;&lt;p&gt;互联网相关的各类协议族的总称，协议存在各式各样的内容。从电缆的规格到IP地址的选定方法、双方建立通信的顺序，以及web页面显示需要处理的步骤，等等。&lt;br&gt;按层次分别为：应用层、传输层、网络层、数据链路层。  &lt;/p&gt;
&lt;h4 id=&quot;从客户端发送请求到服务端接收请求流程如图：&quot;&gt;&lt;a href=&quot;#从客户端发送请求到服务端接收请求流程如图：&quot; class=&quot;headerlink&quot; title=&quot;从客户端发送请求到服务端接收请求流程如图：&quot;&gt;&lt;/a&gt;从客户端发送请求到服务端接收请求流程如图：&lt;/h4&gt;&lt;p&gt;&lt;img src=&quot;/2018/07/12/h/h2.png&quot; alt=&quot;h2&quot;&gt;&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="web" scheme="http://yaliixxg.github.io/categories/web/"/>
    
    
      <category term="http websocket" scheme="http://yaliixxg.github.io/tags/http-websocket/"/>
    
  </entry>
  
  <entry>
    <title>程序员的技能思考</title>
    <link href="http://yaliixxg.github.io/2018/07/10/20180710think/"/>
    <id>http://yaliixxg.github.io/2018/07/10/20180710think/</id>
    <published>2018-07-10T09:55:01.000Z</published>
    <updated>2018-07-10T10:00:08.501Z</updated>
    
    <content type="html"><![CDATA[<h3 id="程序员的两条腿"><a href="#程序员的两条腿" class="headerlink" title="程序员的两条腿"></a>程序员的两条腿</h3><ul><li>数学</li><li>英语</li></ul><p>除此之外是职业技能<br><a id="more"></a></p><ul><li>学习能力<br>通过多途径的方式快速习得必要知识，这些途径包括搜索引擎，实体书籍，电子文档，论坛提问等。</li><li>编码能力<ul><li>编程语言的掌握<br>理解语言的特性编写清晰高效的代码，命名直观，注释准确。<br>理解语言的实现，能供透过语言的形式了解其背后的原理，从而优化代码，或是触类旁通学习其它语言。<br>理解不同编程范式并在合适的场景下应用，命令式，声明式两大类，前者向计算机描述问题的求解过程 how ，后者向计算机描述问题是什么 what，函数式编程归属于声明式。（过程式，函数式，对象式，并发，逻辑等）</li><li>技术栈的掌握<br>掌握各种框架及工具链解决工程开发问题<br>利用各种框架及工具搭建项目工程<br>了解各类技术的应用场景与实现  </li><li>编程思想的理解<br>抽象<br>模块化、复用<br>分层<br>低耦合高内聚原则<br>SOLID 原则  </li><li>数据结构与算法  </li></ul></li><li>解决问题的能力<ul><li>发现问题<br>调试技巧，经验与直觉</li><li>描述问题<br>恰当的语言描述问题</li><li>解决问题<br>直接解决，求助解决，借助互联网解决</li></ul></li><li>设计与架构能力<ul><li>架构原则</li><li>通用设计模式</li></ul></li><li>沟通表达能力<ul><li>文档编写（PPT，博文）</li><li>语言表达</li></ul></li><li>业务领域知识</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;程序员的两条腿&quot;&gt;&lt;a href=&quot;#程序员的两条腿&quot; class=&quot;headerlink&quot; title=&quot;程序员的两条腿&quot;&gt;&lt;/a&gt;程序员的两条腿&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;数学&lt;/li&gt;
&lt;li&gt;英语&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;除此之外是职业技能&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="web" scheme="http://yaliixxg.github.io/categories/web/"/>
    
    
      <category term="程序员思考" scheme="http://yaliixxg.github.io/tags/%E7%A8%8B%E5%BA%8F%E5%91%98%E6%80%9D%E8%80%83/"/>
    
  </entry>
  
  <entry>
    <title>在vue项目中 如何定义全局变量 全局函数</title>
    <link href="http://yaliixxg.github.io/2018/07/03/global/"/>
    <id>http://yaliixxg.github.io/2018/07/03/global/</id>
    <published>2018-07-03T07:54:36.000Z</published>
    <updated>2018-07-12T03:48:17.492Z</updated>
    
    <content type="html"><![CDATA[<p>定义全局变量<br>原理：<br>设置一个专用的的全局变量模块文件，模块里面定义一些变量初始状态，用export default 暴露出去，在main.js里面使用Vue.prototype挂载到vue实例上面或者在其它地方需要使用时，引入该模块便可。</p><p>全局变量模块文件：<br>Global.vue文件：</p><p><img src="/2018/07/03/global/vue1.png" alt="vue1"></p><h1 id="使用方式1："><a href="#使用方式1：" class="headerlink" title="使用方式1："></a>使用方式1：</h1><p>在需要的地方引用进全局变量模块文件，然后通过文件里面的变量名字获取全局变量参数值。</p><p>在text1.vue组件中使用：</p><p><img src="/2018/07/03/global/vue2.png" alt="vue2"><br><a id="more"></a></p><h1 id="使用方式2："><a href="#使用方式2：" class="headerlink" title="使用方式2："></a>使用方式2：</h1><p>在程序入口的main.js文件里面，将上面那个Global.vue文件挂载到Vue.prototype。</p><pre><code>import global_ from &apos;./components/Global&apos;//引用文件Vue.prototype.GLOBAL = global_//挂载到Vue实例上面</code></pre><p>接着在整个项目中不需要再通过引用Global.vue模块文件，直接通过this就可以直接访问Global文件里面定义的全局变量。</p><p>text2.vue：</p><p><img src="/2018/07/03/global/vue3.png" alt="vue3"></p><p>Vuex也可以设置全局变量：<br>通过vuex来存放全局变量，这里东西比较多，也相对复杂一些，有兴趣的小伙伴们，可自行查阅资料，折腾一波、</p><p>定义全局函数<br>原理<br>新建一个模块文件，然后在main.js里面通过Vue.prototype将函数挂载到Vue实例上面，通过this.函数名，来运行函数。</p><ol><li>在main.js里面直接写函数<br>简单的函数可以直接在main.js里面直接写</li></ol><p>Vue.prototype.changeData = function (){//changeData是函数名<br>  alert(‘执行成功’);<br>}<br>组件中调用：</p><p>this.changeData();//直接通过this运行函数</p><ol start="2"><li>写一个模块文件，挂载到main.js上面。<br>base.js文件，文件位置可以放在跟main.js同一级，方便引用</li></ol><p>exports.install = function (Vue, options) {<br>   Vue.prototype.text1 = function (){//全局函数1<br>    alert(‘执行成功1’);<br>    };<br>    Vue.prototype.text2 = function (){//全局函数2<br>    alert(‘执行成功2’);<br>    };<br>};<br>main.js入口文件：</p><pre><code>import base from &apos;./base&apos;//引用Vue.use(base);//将全局函数当做插件来进行注册</code></pre><p>组件里面调用：</p><pre><code>this.text1();this.text2();</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;定义全局变量&lt;br&gt;原理：&lt;br&gt;设置一个专用的的全局变量模块文件，模块里面定义一些变量初始状态，用export default 暴露出去，在main.js里面使用Vue.prototype挂载到vue实例上面或者在其它地方需要使用时，引入该模块便可。&lt;/p&gt;
&lt;p&gt;全局变量模块文件：&lt;br&gt;Global.vue文件：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/2018/07/03/global/vue1.png&quot; alt=&quot;vue1&quot;&gt;&lt;/p&gt;
&lt;h1 id=&quot;使用方式1：&quot;&gt;&lt;a href=&quot;#使用方式1：&quot; class=&quot;headerlink&quot; title=&quot;使用方式1：&quot;&gt;&lt;/a&gt;使用方式1：&lt;/h1&gt;&lt;p&gt;在需要的地方引用进全局变量模块文件，然后通过文件里面的变量名字获取全局变量参数值。&lt;/p&gt;
&lt;p&gt;在text1.vue组件中使用：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/2018/07/03/global/vue2.png&quot; alt=&quot;vue2&quot;&gt;&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="web" scheme="http://yaliixxg.github.io/categories/web/"/>
    
    
      <category term="vue 全局变量" scheme="http://yaliixxg.github.io/tags/vue-%E5%85%A8%E5%B1%80%E5%8F%98%E9%87%8F/"/>
    
  </entry>
  
  <entry>
    <title>12岁的晴天</title>
    <link href="http://yaliixxg.github.io/2018/07/03/sunny/"/>
    <id>http://yaliixxg.github.io/2018/07/03/sunny/</id>
    <published>2018-07-03T02:30:23.000Z</published>
    <updated>2018-07-10T01:37:53.089Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/2018/07/03/sunny/sunny1.jpg" alt="sunny1"><br><img src="/2018/07/03/sunny/sunny2.jpg" alt="sunny2"></p><p>从前从前有个人爱你很久<br>但偏偏，雨渐渐，把距离吹的好远</p><p>刮风这天<br>我试过握着你手</p><p>还要多久，我才能在你身边<br>等到放晴的那天<br>也许我会比较好一点</p><p>为你翘课的那一天<br>花落的那一天<br>教室的那一间<br>我怎么看不见<br>消失的下雨天<br>我好想再淋一遍</p><p>12岁的晴天<br>但故事的最后，你好像还是说了</p><h1 id="拜。"><a href="#拜。" class="headerlink" title="拜。"></a>拜。</h1>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;img src=&quot;/2018/07/03/sunny/sunny1.jpg&quot; alt=&quot;sunny1&quot;&gt;&lt;br&gt;&lt;img src=&quot;/2018/07/03/sunny/sunny2.jpg&quot; alt=&quot;sunny2&quot;&gt;&lt;/p&gt;
&lt;p&gt;从前从前有个人爱你很久&lt;br&gt;但偏偏，
      
    
    </summary>
    
      <category term="音乐" scheme="http://yaliixxg.github.io/categories/%E9%9F%B3%E4%B9%90/"/>
    
    
      <category term="晴天 周杰伦" scheme="http://yaliixxg.github.io/tags/%E6%99%B4%E5%A4%A9-%E5%91%A8%E6%9D%B0%E4%BC%A6/"/>
    
  </entry>
  
  <entry>
    <title>跨域请求传递cookie问题</title>
    <link href="http://yaliixxg.github.io/2018/06/20/pageaxios/"/>
    <id>http://yaliixxg.github.io/2018/06/20/pageaxios/</id>
    <published>2018-06-20T08:10:34.000Z</published>
    <updated>2018-06-20T08:15:04.021Z</updated>
    
    <content type="html"><![CDATA[<p>问题描述<br>前后端完全分离的项目，前端使用Vue + axios，后端使用SpringMVC，容器为Tomcat。<br>使用CORS协议解决跨域访问数据限制的问题，但是发现客户端的Ajax请求不会自动带上服务器返回的Cookie：JSESSIONID。<br>导致每一个Ajax请求在服务端看来都是一个新的请求，都会在服务端创建新的Session（在响应消息头中设置Set-Cookie：JSESSIONID=xxx）。<br>而在项目中使用了Shiro框架，用户认证信息是放在Session中的，由于客户端不会把JSESSIONID返回给服务器端，因此使用Session策略存放数据的方式不可用。<br><a id="more"></a><br>原因分析<br>实际上，这是浏览器的同源策略导致的问题：不允许JS访问跨域的Cookie。<br>举个例子，现有网站A使用域名a.example.com，网站B使用域名b.example.com，如果希望在2个网站之间共享Cookie（浏览器可以将Cookie发送给服务器），那么在设置的Cookie的时候，必须设置domain为example.com。</p><p>解决方案<br>需要从2个方面解决：<br>1.服务器端使用CROS协议解决跨域访问数据问题时，需要设置响应消息头Access-Control-Allow-Credentials值为“true”。<br>同时，还需要设置响应消息头Access-Control-Allow-Origin值为指定单一域名（注：不能为通配符“*”）。</p><p>@Override<br>public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain)<br>        throws IOException, ServletException {<br>    HttpServletRequest req = (HttpServletRequest)request;<br>    HttpServletResponse resp = (HttpServletResponse)response;</p><pre><code>String origin = req.getHeader(&quot;Origin&quot;);if(origin == null) {    origin = req.getHeader(&quot;Referer&quot;);}resp.setHeader(&quot;Access-Control-Allow-Origin&quot;, origin);            // 允许指定域访问跨域资源resp.setHeader(&quot;Access-Control-Allow-Credentials&quot;, &quot;true&quot;);       // 允许客户端携带跨域cookie，此时origin值不能为“*”，只能为指定单一域名if(RequestMethod.OPTIONS.toString().equals(req.getMethod())) {    String allowMethod = req.getHeader(&quot;Access-Control-Request-Method&quot;);    String allowHeaders = req.getHeader(&quot;Access-Control-Request-Headers&quot;);    resp.setHeader(&quot;Access-Control-Max-Age&quot;, &quot;86400&quot;);            // 浏览器缓存预检请求结果时间,单位:秒    resp.setHeader(&quot;Access-Control-Allow-Methods&quot;, allowMethod);  // 允许浏览器在预检请求成功之后发送的实际请求方法名    resp.setHeader(&quot;Access-Control-Allow-Headers&quot;, allowHeaders); // 允许浏览器发送的请求消息头    return;}chain.doFilter(request, response);</code></pre><p>}<br>2.客户端需要设置Ajax请求属性withCredentials=true，让Ajax请求都带上Cookie。</p><p>对于XMLHttpRequest的Ajax请求</p><p>var xhr = new XMLHttpRequest();<br>xhr.open(‘GET’, url);<br>xhr.withCredentials = true; // 携带跨域cookie<br>xhr.send();</p><p>对于JQuery的Ajax请求</p><p>$.ajax({<br>type: “GET”,<br>url: url,<br>xhrFields: {<br>    withCredentials: true // 携带跨域cookie<br>},<br>processData: false,<br>success: function(data) {<br>    console.log(data);<br>}<br>});</p><p>对于axios的Ajax请求</p><p>axios.defaults.withCredentials=true; // 让ajax携带cookie</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;问题描述&lt;br&gt;前后端完全分离的项目，前端使用Vue + axios，后端使用SpringMVC，容器为Tomcat。&lt;br&gt;使用CORS协议解决跨域访问数据限制的问题，但是发现客户端的Ajax请求不会自动带上服务器返回的Cookie：JSESSIONID。&lt;br&gt;导致每一个Ajax请求在服务端看来都是一个新的请求，都会在服务端创建新的Session（在响应消息头中设置Set-Cookie：JSESSIONID=xxx）。&lt;br&gt;而在项目中使用了Shiro框架，用户认证信息是放在Session中的，由于客户端不会把JSESSIONID返回给服务器端，因此使用Session策略存放数据的方式不可用。&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="web" scheme="http://yaliixxg.github.io/categories/web/"/>
    
    
      <category term="跨域" scheme="http://yaliixxg.github.io/tags/%E8%B7%A8%E5%9F%9F/"/>
    
  </entry>
  
  <entry>
    <title>Summer&#39;s Gone Ft. Jony J (Prod.by PDP)</title>
    <link href="http://yaliixxg.github.io/2018/06/15/summer/"/>
    <id>http://yaliixxg.github.io/2018/06/15/summer/</id>
    <published>2018-06-15T02:37:48.000Z</published>
    <updated>2018-06-15T02:44:27.044Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/2018/06/15/summer/summer.jpg" alt="summer"><br>词与唱：大包子，Jony J</p><p>好沮丧 the Summer’s Gone 气温又降了 不知不觉又添了衣裳<br>仲夏一个单薄的梦 像是纱做的蚊帐 被折叠成秘密封藏<br>Oh no the Summer’s Gone , my life becomes from fresh to dark brown<br>想起那时的夜短昼长 热浪 似乎将我的青春期延长</p><p>等待一场半夜的球赛 左手啤酒右手可乐都加满了冰块<br>冰激凌听话的躺在冷柜 等着触碰我们干燥的唇和胃<br>大口的喝水 一杯又一杯 每当汗流浃背 虚弱又颓废<br>细胞，嗷嗷待哺的张开了嘴 补充了能量继续PLAY DA GAME<br>男孩迫不及待的跳进池塘 假装乘风破浪 水花肆意碰撞<br>水鬼也被逼上了岸 仿佛生的热气驱走了死的严寒<br>天亮得早白天长 不用闹钟我也不会赖床<br>冲凉 柠檬沐浴香<br>裸露的皮肤 汗毛茁壮生长<br>花露水的味道是种安心的清凉<br>蚊虫的叮咬 挠了又挠的瘙痒<br>泄气的大地 苦等着风 稠腻的晌午 人们寻找遮蔽行色匆匆<br>躲在屋里 不用找别的借口<br>你是我的解暑良药我的冰镇樱桃汽酒<br>咽下一口 沿着我的食道四壁<br>湿润粗糙的黏膜 沁入我的心脾<br><a id="more"></a></p><p>说真的时间他就是个小气鬼<br>在半睡半醒之间多想让闹钟闭嘴<br>这种感觉可以去跟fly high媲美<br>我伸手就抓过了桌上的汽水<br>在湿热的午后 好像被下了诅咒<br>我甚至可以闻到自己灵魂里的腐臭<br>这好热 我实在爱死这个季节<br>暴烈的阳光赤裸的晒出这个世界<br>连呼吸都烫口 千万别把冷气放走<br>它塞满整个房间走廊散在每个窗口<br>我打开冰箱 有西瓜和饮料<br>就听着jazz打2k 我欢迎你来领教<br>听窗外有鸟叫 蝉鸣 和小孩哭闹<br>乘凉下棋的老人这一局又是谁输掉<br>b boys b girls还在街上跳舞<br>而夏天的结束也慢慢进入倒数</p><p>我才顾不得这天气的炎热<br>拥着你亲吻你汗湿的颈脖<br>你眼神的闪烁好像星空的斑驳<br>你跳跃的脊背是我心跳的忐忑<br>这热度加速挥发你的香气<br>凉席 留着你形状的汗滴<br>你毛孔微张 浅浅深深的呼吸<br>吱呀的电扇回应着我们的轻声密语<br>不停息的蝉鸣 跃跃欲试的情绪<br>而我一直心急 害怕片刻的分离<br>I wish my summer could last forever<br>get sweaty already we ran wild n wilder</p><p>整个夏日我一直在挥霍 发烫的眼神点燃荷尔蒙和不安的动作<br>阳光刺眼的片刻 美丽就快饱和<br>你给的快乐是我深陷的沼泽<br>但如果你走了 我的夏天就变晦涩<br>我收集六七八月却永远等不来收获<br>或许一夜长大是我唯一的选择<br>但我还妄想 守望夏天的那个我会复活<br>But the summer’s gone<br>My songs are not done<br>The wind blowing will never tell me where did I go wrong</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;/2018/06/15/summer/summer.jpg&quot; alt=&quot;summer&quot;&gt;&lt;br&gt;词与唱：大包子，Jony J&lt;/p&gt;
&lt;p&gt;好沮丧 the Summer’s Gone 气温又降了 不知不觉又添了衣裳&lt;br&gt;仲夏一个单薄的梦 像是纱做的蚊帐 被折叠成秘密封藏&lt;br&gt;Oh no the Summer’s Gone , my life becomes from fresh to dark brown&lt;br&gt;想起那时的夜短昼长 热浪 似乎将我的青春期延长&lt;/p&gt;
&lt;p&gt;等待一场半夜的球赛 左手啤酒右手可乐都加满了冰块&lt;br&gt;冰激凌听话的躺在冷柜 等着触碰我们干燥的唇和胃&lt;br&gt;大口的喝水 一杯又一杯 每当汗流浃背 虚弱又颓废&lt;br&gt;细胞，嗷嗷待哺的张开了嘴 补充了能量继续PLAY DA GAME&lt;br&gt;男孩迫不及待的跳进池塘 假装乘风破浪 水花肆意碰撞&lt;br&gt;水鬼也被逼上了岸 仿佛生的热气驱走了死的严寒&lt;br&gt;天亮得早白天长 不用闹钟我也不会赖床&lt;br&gt;冲凉 柠檬沐浴香&lt;br&gt;裸露的皮肤 汗毛茁壮生长&lt;br&gt;花露水的味道是种安心的清凉&lt;br&gt;蚊虫的叮咬 挠了又挠的瘙痒&lt;br&gt;泄气的大地 苦等着风 稠腻的晌午 人们寻找遮蔽行色匆匆&lt;br&gt;躲在屋里 不用找别的借口&lt;br&gt;你是我的解暑良药我的冰镇樱桃汽酒&lt;br&gt;咽下一口 沿着我的食道四壁&lt;br&gt;湿润粗糙的黏膜 沁入我的心脾&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="音乐" scheme="http://yaliixxg.github.io/categories/%E9%9F%B3%E4%B9%90/"/>
    
    
      <category term="夏天汽水" scheme="http://yaliixxg.github.io/tags/%E5%A4%8F%E5%A4%A9%E6%B1%BD%E6%B0%B4/"/>
    
  </entry>
  
  <entry>
    <title>乱七八糟のweb</title>
    <link href="http://yaliixxg.github.io/2018/06/14/web/"/>
    <id>http://yaliixxg.github.io/2018/06/14/web/</id>
    <published>2018-06-14T09:55:23.000Z</published>
    <updated>2018-07-16T01:32:44.618Z</updated>
    
    <content type="html"><![CDATA[<p>基于vue-cli快速构建：<a href="https://www.jianshu.com/p/2769efeaa10a" target="_blank" rel="noopener">https://www.jianshu.com/p/2769efeaa10a</a></p><p>10分钟学会基本的 Flexbox 布局：<a href="http://www.css88.com/archives/7760" target="_blank" rel="noopener">http://www.css88.com/archives/7760</a></p><p>CSS使用flex处理不同宽度屏幕上的布局：<a href="https://segmentfault.com/q/1010000006991463" target="_blank" rel="noopener">https://segmentfault.com/q/1010000006991463</a></p><a id="more"></a><p>常用代码压缩工具网站：</p><p>1.<a href="https://tool.lu/css/" target="_blank" rel="noopener">https://tool.lu/css/</a>    压缩Css比较方便</p><ol start="2"><li><a href="http://tool.oschina.net/jscompress?type=2" target="_blank" rel="noopener">http://tool.oschina.net/jscompress?type=2</a>  Html,Css,Js都可以压缩。</li></ol><p>3.<a href="http://tool.chinaz.com/Tools/CssFormat.aspx" target="_blank" rel="noopener">http://tool.chinaz.com/Tools/CssFormat.aspx</a>  站长工具，这个就不介绍了，常用。</p><p>软件下载：3D溜溜网</p><p>学会了ES6，就不会写出那样的代码：<a href="https://juejin.im/post/5acb1847f265da237c693362" target="_blank" rel="noopener">https://juejin.im/post/5acb1847f265da237c693362</a></p><p>【基础知识】Flex-弹性布局原来如此简单！！：<a href="https://juejin.im/post/5ac2329b6fb9a028bf057caf" target="_blank" rel="noopener">https://juejin.im/post/5ac2329b6fb9a028bf057caf</a></p><p>postman百度网盘下载：<a href="https://pan.baidu.com/s/1bp1LSGf/?errno=0&amp;errmsg=Auth%20Login%20Sucess&amp;&amp;bduss=&amp;ssnerror=0&amp;traceid=" target="_blank" rel="noopener">https://pan.baidu.com/s/1bp1LSGf/?errno=0&amp;errmsg=Auth%20Login%20Sucess&amp;&amp;bduss=&amp;ssnerror=0&amp;traceid=</a></p><p>ES6:<a href="http://es6.ruanyifeng.com/" target="_blank" rel="noopener">http://es6.ruanyifeng.com/</a></p><p>webpack超详细配置, 使用教程(图文):<a href="https://blog.csdn.net/c_kite/article/details/71279853" target="_blank" rel="noopener">https://blog.csdn.net/c_kite/article/details/71279853</a></p><p>webpack中文文档：<a href="https://www.webpackjs.com/concepts/entry-points/" target="_blank" rel="noopener">https://www.webpackjs.com/concepts/entry-points/</a></p><p>蜂投网git：<a href="http://192.168.52.153:3000/" target="_blank" rel="noopener">http://192.168.52.153:3000/</a></p><p>Vue实现一个移动端屏蔽滑动的遮罩层：<a href="https://www.cnblogs.com/Eden-cola/p/vue-overlayer.html" target="_blank" rel="noopener">https://www.cnblogs.com/Eden-cola/p/vue-overlayer.html</a></p><p>Vue 多页面应用webpack如何设置：<a href="https://segmentfault.com/q/1010000009475223/a-1020000009475360" target="_blank" rel="noopener">https://segmentfault.com/q/1010000009475223/a-1020000009475360</a></p><p>webpack + vue + vueRouter 模块化构建完整项目代码实例 <a href="https://segmentfault.com/a/1190000008602934" target="_blank" rel="noopener">https://segmentfault.com/a/1190000008602934</a></p><p>查看webpack打包的文件是哪些？ <a href="http://localhost:8080/webpack-dev-server" target="_blank" rel="noopener">http://localhost:8080/webpack-dev-server</a></p><p>git如何把本地项目推送到github仓库 <a href="https://jingyan.baidu.com/article/00a07f38757d0482d028dce5.html" target="_blank" rel="noopener">https://jingyan.baidu.com/article/00a07f38757d0482d028dce5.html</a></p><p>github push 提交代码时停止在writing objects怎么办？ git config –global http.postBuffer 524288000</p><p>用webpack打包配置vue文件时，记得要安装一个插件：HtmlWebpackPlugin 用来编译HTML文件</p><p>解决谷歌浏览器限制跨域问题： –args –disable-web-security  –user-data-dir</p><p>gitLab: <a href="http://192.168.56.161:6699/gitlab/" target="_blank" rel="noopener">http://192.168.56.161:6699/gitlab/</a></p><p>监听VUE路由变化，部分数据无法更新？<a href="http://www.cnblogs.com/first-time/p/7067674.html" target="_blank" rel="noopener">http://www.cnblogs.com/first-time/p/7067674.html</a></p><p>日历签到插件：<a href="https://github.com/Arguiwu/calendar" target="_blank" rel="noopener">https://github.com/Arguiwu/calendar</a></p><p>vscode 插件 超级简单 px转换rem :<a href="https://segmentfault.com/a/1190000009572846" target="_blank" rel="noopener">https://segmentfault.com/a/1190000009572846</a></p><p>px和rem 互转 ： <a href="http://pvp.qq.com/act/a20161209story/rempx.htm" target="_blank" rel="noopener">http://pvp.qq.com/act/a20161209story/rempx.htm</a></p><p>React in patterns 中文版<br> 介绍 React 开发的设计模式和技术的免费开源书籍。：<a href="https://github.com/SangKa/react-in-patterns-cn" target="_blank" rel="noopener">https://github.com/SangKa/react-in-patterns-cn</a></p><p>网易的开发规范：<a href="http://res.nie.netease.com/comm/doc/professional/PC%E5%A4%96%E5%8C%85%E9%A1%B5%E9%9D%A2%E5%88%B6%E4%BD%9C%E8%A7%84%E8%8C%83.html" target="_blank" rel="noopener">http://res.nie.netease.com/comm/doc/professional/PC%E5%A4%96%E5%8C%85%E9%A1%B5%E9%9D%A2%E5%88%B6%E4%BD%9C%E8%A7%84%E8%8C%83.html</a><br>十三位时间戳转换: new Date(parseInt((“/Date(“+nS+”)/“).substr(6, 13))).toLocaleDateString()</p><p>移动端点击、触碰随记：<a href="https://toutiao.io/posts/rf760/preview" target="_blank" rel="noopener">https://toutiao.io/posts/rf760/preview</a></p><p>如何在Vue项目中使用vw实现移动端适配：<a href="https://www.w3cplus.com/mobile/vw-layout-in-vue.html" target="_blank" rel="noopener">https://www.w3cplus.com/mobile/vw-layout-in-vue.html</a></p><p>vscode 中 git 的使用 <a href="https://juejin.im/post/5b00474951882542ba08087a" target="_blank" rel="noopener">https://juejin.im/post/5b00474951882542ba08087a</a><br>四月前端知识集锦（每月不可错过的文章集锦）：<a href="https://juejin.im/post/5ae95f17f265da0b93481dec?utm_source=gold_browser_extension" target="_blank" rel="noopener">https://juejin.im/post/5ae95f17f265da0b93481dec?utm_source=gold_browser_extension</a></p><p>javaScript比较两个日期的大小的2种方法：<a href="https://blog.csdn.net/w__yi/article/details/7992604" target="_blank" rel="noopener">https://blog.csdn.net/w__yi/article/details/7992604</a></p><p>熊猫压缩图片 <a href="https://tinypng.com/" target="_blank" rel="noopener">https://tinypng.com/</a></p><p>掘金酱 <a href="http://e.xitu.io/" target="_blank" rel="noopener">http://e.xitu.io/</a></p><p>webpack原理 <a href="https://segmentfault.com/a/1190000015088834" target="_blank" rel="noopener">https://segmentfault.com/a/1190000015088834</a></p><p>各种规范 <a href="https://juejin.im/entry/58b63fdf1b69e6006bfcf8ad" target="_blank" rel="noopener">https://juejin.im/entry/58b63fdf1b69e6006bfcf8ad</a></p><p>hexo博客插件：<a href="https://blog.csdn.net/Hoshea_chx/article/details/78826689" target="_blank" rel="noopener">https://blog.csdn.net/Hoshea_chx/article/details/78826689</a></p><p>next 美化 <a href="https://www.jianshu.com/p/f054333ac9e6" target="_blank" rel="noopener">https://www.jianshu.com/p/f054333ac9e6</a></p><p>知识点杂烩 <a href="https://github.com/qiu-deqing/FE-interview" target="_blank" rel="noopener">https://github.com/qiu-deqing/FE-interview</a></p><p>2018面试点 <a href="https://blog.csdn.net/VhWfR2u02Q/article/details/79765406#t2" target="_blank" rel="noopener">https://blog.csdn.net/VhWfR2u02Q/article/details/79765406#t2</a></p><p>优秀文章合集 <a href="https://juejin.im/post/5b3adfe2e51d4555b17e85df" target="_blank" rel="noopener">https://juejin.im/post/5b3adfe2e51d4555b17e85df</a></p><p>vue-layer <a href="https://cnodejs.org/topic/59707d120c87675e74674693" target="_blank" rel="noopener">https://cnodejs.org/topic/59707d120c87675e74674693</a></p><p>从输入URL到页面加载的过程？如何由一道题完善自己的前端知识体系！  <a href="https://juejin.im/post/5aa5cb846fb9a028e25d2fb1" target="_blank" rel="noopener">https://juejin.im/post/5aa5cb846fb9a028e25d2fb1</a></p><p>vue angular 组件 轮子工厂 <a href="http://www.wheelsfactory.cn/#/home" target="_blank" rel="noopener">http://www.wheelsfactory.cn/#/home</a></p><p>web 前端学习笔记 <a href="https://github.com/CyC2018/Interview-Notebook" target="_blank" rel="noopener">https://github.com/CyC2018/Interview-Notebook</a></p><p>Web组件 由几个单独的技术组成，可以使用现有的Web组件而无需编写代码，只需向HTML页面添加import语句即可  <a href="https://developer.mozilla.org/zh-CN/docs/Web/Web_Components" target="_blank" rel="noopener">https://developer.mozilla.org/zh-CN/docs/Web/Web_Components</a></p><p>面试图谱 <a href="https://yuchengkai.cn/docs/zh/frontend/" target="_blank" rel="noopener">https://yuchengkai.cn/docs/zh/frontend/</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;基于vue-cli快速构建：&lt;a href=&quot;https://www.jianshu.com/p/2769efeaa10a&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://www.jianshu.com/p/2769efeaa10a&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;10分钟学会基本的 Flexbox 布局：&lt;a href=&quot;http://www.css88.com/archives/7760&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;http://www.css88.com/archives/7760&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;CSS使用flex处理不同宽度屏幕上的布局：&lt;a href=&quot;https://segmentfault.com/q/1010000006991463&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://segmentfault.com/q/1010000006991463&lt;/a&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="web" scheme="http://yaliixxg.github.io/categories/web/"/>
    
    
      <category term="web" scheme="http://yaliixxg.github.io/tags/web/"/>
    
  </entry>
  
  <entry>
    <title>Havana</title>
    <link href="http://yaliixxg.github.io/2018/06/14/oh-havana/"/>
    <id>http://yaliixxg.github.io/2018/06/14/oh-havana/</id>
    <published>2018-06-14T02:14:16.000Z</published>
    <updated>2018-06-14T07:19:12.764Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/2018/06/14/oh-havana/Havana.jpg" alt="Havana"><br>Oh, oh, oh, yeah<br>噢~噢~噢~耶~<br>Havana, ooh na-na<br>哈瓦那~哦啦啦<br>Half of my heart is in Havana, na-na-na<br>我的一半心思留在了哈瓦那<br>He took me back to East Atlanta, na-na-na<br>他带我重回东亚特兰大<br>All of my heart is in Havana<br>如今我的心全都属于哈瓦那<br>There’s somethin’ ‘bout his manners<br>犹记得他的一举一动<br><a id="more"></a><br>He didn’t walk up with that “how you doin’?”<br>他并没有过来找我搭讪<br>He said there’s a lot of girls I can do with<br>他说他能驾驭的女孩有很多<br>I knew him forever in a minute<br>但我却对他一见钟情<br>And papa says he got evil in him<br>尽管爸爸也说他不是个好东西<br>He got me feelin’ like…<br>他让我小鹿乱撞<br>Oooh-oooh-ooh, I knew it when I met him<br>噢噢噢~我对他一见钟情<br>I loved him when I left him<br>分别时就已经爱上了他<br>Got me feelin’ like…<br>他让我脸红心跳<br>Oooh-oooh-ooh, and then I had to tell him<br>噢噢噢~但我不得不告诉他：<br>I had to go, oh na-na-na-na-na<br>我不得不走了<br>Havana, ooh na-na<br>再见了，哈瓦那！<br>Half of my heart is in Havana, na-na-na<br>我的一半心思留在了哈瓦那<br>He took me back to East Atlanta, na-na-na<br>他带我重回东亚特兰大<br>All of my heart is in Havana<br>如今我的心全都属于哈瓦那<br>There’s somethin’ ‘bout his manners<br>犹记得他的一举一动<br>Oooh-oooh-ooh, Oooh-oooh-ooh, Oooh-oooh-ooh<br>哦~哦~哦~<br>Oh-na-na-na<br>哦啦啦啦<br>Havana, ooh na-na<br>哈瓦那~哦啦啦<br>Half of my heart is in Havana, na-na-na<br>我的一半心思留在了哈瓦那<br>He took me back to East Atlanta, na-na-na<br>他带我重回东亚特兰大<br>All of my heart is in Havana<br>如今我的心全都属于哈瓦那<br>There’s somethin’ ‘bout his manners<br>犹记得他的一举一动<br>Ooh na-na, Ooh na-na<br>哦啦啦~哦啦啦<br>Oooh-oooh-ooh,<br>哦~哦~哦~<br>Havana, ooh na-na<br>哈瓦那~哦啦啦~<br>Yeah yeah yeah, Havana, ooh na-na<br>耶耶耶，哈瓦那哦啦啦~</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;/2018/06/14/oh-havana/Havana.jpg&quot; alt=&quot;Havana&quot;&gt;&lt;br&gt;Oh, oh, oh, yeah&lt;br&gt;噢~噢~噢~耶~&lt;br&gt;Havana, ooh na-na&lt;br&gt;哈瓦那~哦啦啦&lt;br&gt;Half of my heart is in Havana, na-na-na&lt;br&gt;我的一半心思留在了哈瓦那&lt;br&gt;He took me back to East Atlanta, na-na-na&lt;br&gt;他带我重回东亚特兰大&lt;br&gt;All of my heart is in Havana&lt;br&gt;如今我的心全都属于哈瓦那&lt;br&gt;There’s somethin’ ‘bout his manners&lt;br&gt;犹记得他的一举一动&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="音乐" scheme="http://yaliixxg.github.io/categories/%E9%9F%B3%E4%B9%90/"/>
    
    
      <category term="音乐" scheme="http://yaliixxg.github.io/tags/%E9%9F%B3%E4%B9%90/"/>
    
  </entry>
  
  <entry>
    <title>世界杯要来啦！德国加油！</title>
    <link href="http://yaliixxg.github.io/2018/06/13/Cup/"/>
    <id>http://yaliixxg.github.io/2018/06/13/Cup/</id>
    <published>2018-06-13T03:55:49.000Z</published>
    <updated>2018-06-14T07:20:17.612Z</updated>
    
    <content type="html"><![CDATA[<p>希望俄罗斯世界杯，德国能举起大力神杯~！！！！！</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;希望俄罗斯世界杯，德国能举起大力神杯~！！！！！&lt;/p&gt;

      
    
    </summary>
    
      <category term="哔哔叨叨" scheme="http://yaliixxg.github.io/categories/%E5%93%94%E5%93%94%E5%8F%A8%E5%8F%A8/"/>
    
    
      <category term="世界杯" scheme="http://yaliixxg.github.io/tags/%E4%B8%96%E7%95%8C%E6%9D%AF/"/>
    
  </entry>
  
  <entry>
    <title>First</title>
    <link href="http://yaliixxg.github.io/2018/06/12/20180612/"/>
    <id>http://yaliixxg.github.io/2018/06/12/20180612/</id>
    <published>2018-06-12T09:58:45.000Z</published>
    <updated>2018-06-14T07:20:39.205Z</updated>
    
    <content type="html"><![CDATA[<p>豆豆，哦豆豆，豆豆豆豆</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;豆豆，哦豆豆，豆豆豆豆&lt;/p&gt;

      
    
    </summary>
    
      <category term="哔哔叨叨" scheme="http://yaliixxg.github.io/categories/%E5%93%94%E5%93%94%E5%8F%A8%E5%8F%A8/"/>
    
    
      <category term="自我介绍" scheme="http://yaliixxg.github.io/tags/%E8%87%AA%E6%88%91%E4%BB%8B%E7%BB%8D/"/>
    
  </entry>
  
</feed>
