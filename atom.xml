<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>挖坑埋神经病</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yaliixxg.github.io/"/>
  <updated>2018-07-13T03:14:58.695Z</updated>
  <id>http://yaliixxg.github.io/</id>
  
  <author>
    <name>YaliixxG</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>《webpack文档》学习笔记</title>
    <link href="http://yaliixxg.github.io/2018/07/13/wbpk-SN/"/>
    <id>http://yaliixxg.github.io/2018/07/13/wbpk-SN/</id>
    <published>2018-07-13T01:18:00.000Z</published>
    <updated>2018-07-13T03:14:58.695Z</updated>
    
    <content type="html"><![CDATA[<h1 id="webpack"><a href="#webpack" class="headerlink" title="webpack"></a>webpack</h1><p>是一个现代 JavaScript 应用程序的静态模块打包器(module bundler)。当 webpack 处理应用程序时，它会递归地构建一个依赖关系图(dependency graph)，其中包含应用程序需要的每个模块，然后将所有这些模块打包成一个或多个 bundle。  </p><ul><li>入口(entry)</li><li>输出(output)</li><li>loader</li><li><p>插件(plugins)  </p><a id="more"></a><h2 id="入口"><a href="#入口" class="headerlink" title="入口"></a>入口</h2><p>入口起点(entry point)指示 webpack 应该使用哪个模块，来作为构建其内部依赖图的开始。进入入口起点后，webpack 会找出有哪些模块和库是入口起点（直接和间接）依赖的。  </p><h3 id="单个入口简写语法："><a href="#单个入口简写语法：" class="headerlink" title="单个入口简写语法："></a>单个入口简写语法：</h3><p>webpack.config.js  </p></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">  const config = &#123;</span><br><span class="line">  entry: &#123;</span><br><span class="line">    main: &apos;./path/to/my/entry/file.js&apos;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="对象语法"><a href="#对象语法" class="headerlink" title="对象语法"></a>对象语法</h3><p> 1.分离应用程序(app)和第三方库(vendor)入口   </p><p>  webpack.config.js  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"> const config = &#123;</span><br><span class="line">  entry: &#123;</span><br><span class="line">    app: &apos;./src/app.js&apos;,</span><br><span class="line">    vendors: &apos;./src/vendors.js&apos;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;  </span><br><span class="line">```  </span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">2.多页面应用程序  </span><br><span class="line"></span><br><span class="line">webpack.config.js</span><br></pre></td></tr></table></figure><p>  const config = {<br>  entry: {<br>    pageOne: ‘./src/pageOne/index.js’,<br>    pageTwo: ‘./src/pageTwo/index.js’,<br>    pageThree: ‘./src/pageThree/index.js’<br>  }<br>};<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">这是我们告诉webpack需要三个独立分离的依赖图  </span><br><span class="line"></span><br><span class="line">## 输出  </span><br><span class="line">output 属性告诉 webpack 在哪里输出它所创建的 bundles，以及如何命名这些文件，默认值为 ./dist。基本上，整个应用程序结构，都会被编译到你指定的输出路径的文件夹中。你可以通过在配置中指定一个 output 字段，来配置这些处理过程。  </span><br><span class="line">### 用法</span><br><span class="line">在 webpack 中配置 output 属性的最低要求是，将它的值设置为一个对象，包括以下两点：</span><br><span class="line"></span><br><span class="line">* filename 用于输出文件的文件名。</span><br><span class="line">* 目标输出目录 path 的绝对路径。  </span><br><span class="line"></span><br><span class="line"> webpack.config.js</span><br></pre></td></tr></table></figure></p><p>const config = {<br>  output: {<br>    filename: ‘bundle.js’,<br>    path: ‘/home/proj/public/assets’<br>  }<br>};</p><p>module.exports = config;<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">此配置将一个单独的 bundle.js 文件输出到 /home/proj/public/assets 目录中。  </span><br><span class="line">### 多个入口起点  </span><br><span class="line">```  </span><br><span class="line">&#123;</span><br><span class="line">    entry:&#123;</span><br><span class="line">        app:&apos;./src/app.js&apos;,</span><br><span class="line">        search:&apos;./src/search.js&apos;</span><br><span class="line">    &#125;,</span><br><span class="line">    output:&#123;</span><br><span class="line">        filename:&apos;[name].js&apos;,</span><br><span class="line">        path: __dirname + &apos;/dist&apos;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">//写入到硬盘：./dist/app.js,./dist/search.js </span><br><span class="line">```  </span><br><span class="line">### 高级进阶  </span><br><span class="line">使用CDN和资源hash的复杂示例   </span><br><span class="line">config.js  </span><br><span class="line">```  </span><br><span class="line">output:&#123;</span><br><span class="line">    path:&apos;home/proj/cdn/assets/[hash]&apos;,</span><br><span class="line">    publicPath:&apos;http://cdn.example.com/assets/[hash]/&apos;</span><br><span class="line">&#125; </span><br><span class="line">  ```  </span><br><span class="line">在编译时不知道最终输出文件的 publicPath 的情况下，publicPath 可以留空，并且在入口起点文件运行时动态设置。如果你在编译时不知道 publicPath，你可以先忽略它，并且在入口起点设置 __webpack_public_path__。</span><br></pre></td></tr></table></figure></p><p><strong>webpack_public_path</strong> = myRuntimePublicPath</p><p>// 剩余的应用程序入口<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">## loader  </span><br><span class="line">loader 用于对模块的源代码进行转换。loader 可以使你在 import 或&quot;加载&quot;模块时预处理文件。因此，loader 类似于其他构建工具中“任务(task)”，并提供了处理前端构建步骤的强大方法。loader 可以将文件从不同的语言（如 TypeScript）转换为 JavaScript，或将内联图像转换为 data URL。loader 甚至允许你直接在 JavaScript 模块中 import CSS文件!  </span><br><span class="line">### 使用</span><br><span class="line">三种使用loader的方式：</span><br><span class="line">* 配置（推荐）：在 webpack.config.js 文件中指定 loader。  </span><br><span class="line">* 内联：在每个 import 语句中显式指定 loader。（具体看文档）</span><br><span class="line">* CLI：在 shell 命令中指定它们。 （具体看文档） </span><br><span class="line">### 配置  </span><br><span class="line">module.rules 允许你在 webpack 配置中指定多个 loader。 这是展示 loader 的一种简明方式，并且有助于使代码变得简洁。同时让你对各个 loader 有个全局概览：  </span><br><span class="line">```  </span><br><span class="line">module:&#123;</span><br><span class="line">    rules:[</span><br><span class="line">        &#123;</span><br><span class="line">            test:/\.css$/,</span><br><span class="line">            use:[</span><br><span class="line">                &#123;loader:&apos;style-loader&apos;&#125;,</span><br><span class="line">                &#123;</span><br><span class="line">                    loader:&apos;css-loader&apos;,</span><br><span class="line">                    options:&#123;</span><br><span class="line">                        modules:true</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            ]</span><br><span class="line">        &#125;</span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br><span class="line">//loader 能够使用 options 对象进行配置。</span><br><span class="line">```  </span><br><span class="line">## 插件   </span><br><span class="line">插件是 webpack 的支柱功能。webpack 自身也是构建于，你在 webpack 配置中用到的相同的插件系统之上！</span><br><span class="line"></span><br><span class="line">插件目的在于解决 loader 无法实现的其他事。  </span><br><span class="line">### 用法  </span><br><span class="line">由于插件可以携带参数/选项，你必须在 webpack 配置中，向 plugins 属性传入 new 实例。  </span><br><span class="line"></span><br><span class="line"> webpack.config.js</span><br></pre></td></tr></table></figure></p><p>const HtmlWebpackPlugin = require(‘html-webpack-plugin’); //通过 npm 安装<br>const webpack = require(‘webpack’); //访问内置的插件<br>const path = require(‘path’);</p><p>const config = {<br>  entry: ‘./path/to/my/entry/file.js’,<br>  output: {<br>    filename: ‘my-first-webpack.bundle.js’,<br>    path: path.resolve(__dirname, ‘dist’)<br>  },<br>  module: {<br>    rules: [<br>      {<br>        test: /.(js|jsx)$/,<br>        use: ‘babel-loader’<br>      }<br>    ]<br>  },<br>  plugins: [<br>    new webpack.optimize.UglifyJsPlugin(),<br>    new HtmlWebpackPlugin({template: ‘./src/index.html’})<br>  ]<br>};</p><p>module.exports = config;<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">## 配置  </span><br><span class="line">因为 webpack 配置是标准的 Node.js CommonJS 模块，你可以做到以下事情：</span><br><span class="line">* 通过 require(...) 导入其他文件</span><br><span class="line">* 通过 require(...) 使用 npm 的工具函数</span><br><span class="line">* 使用 JavaScript 控制流表达式，例如 ?: 操作符</span><br><span class="line">* 对常用值使用常量或变量</span><br><span class="line">* 编写并执行函数来生成部分配置  </span><br><span class="line"></span><br><span class="line">## 模块  </span><br><span class="line">### 什么是webpack模块  </span><br><span class="line">* ES2015 import 语句</span><br><span class="line">* CommonJS require() 语句</span><br><span class="line">* AMD define 和 require 语句</span><br><span class="line">* css/sass/less 文件中的 @import 语句。</span><br><span class="line">* 样式(url(...))或 HTML 文件(&lt;img src=...&gt;)中的图片链接(image url)</span><br><span class="line"></span><br><span class="line">### 优化路径  </span><br><span class="line"></span><br><span class="line">#### 1. resolve.extensions </span><br><span class="line">　　在webpack.base.conf.js中，我们可以看到resolve配置，其中的extengsions是一个数组，如下所示：</span><br><span class="line"></span><br><span class="line">    extensions: [&apos;.js&apos;, &apos;.vue&apos;, &apos;.json&apos;],</span><br><span class="line">　　通过这样的配置，我们在组件中过着路由中应用组件时，就可以更为方便的应用，比如：</span><br><span class="line"></span><br><span class="line">  import Hello from &apos;@components/Hello&apos;;</span><br><span class="line">　　即Hello.vue这个组件我们不需要添加.vue后缀就可以引用到了，如果不用extensions， 我们就必须要用@components/Hello.vue来引入这个文件。 </span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">#### 2. resolve.alias</span><br><span class="line">　　在组件之间相互引用时，可能是下面这样的：</span><br><span class="line">```  </span><br><span class="line">    import Hello from &apos;../src.components/Hello&apos;;</span><br></pre></td></tr></table></figure></p><p>　　其中的路径是相对于当前页面的。 但是如果嵌套等更为复杂，那么写起来会比较麻烦。但是如果我们通过这样的配置：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">  resolve: &#123;</span><br><span class="line">    extensions: [&apos;.js&apos;, &apos;.vue&apos;, &apos;.json&apos;],</span><br><span class="line">    alias: &#123;</span><br><span class="line">      &apos;vue$&apos;: &apos;vue/dist/vue.esm.js&apos;,</span><br><span class="line">      &apos;@pages&apos;: path.join(__dirname, &quot;..&quot;, &quot;src&quot;, &quot;pages&quot;),</span><br><span class="line">      &quot;@components&quot;: path.join(__dirname, &quot;..&quot;, &quot;src&quot;, &quot;components&quot;),</span><br><span class="line">      // 注意： 静态资源通过src，不能这么设置。</span><br><span class="line">      // &quot;@assets&quot;: path.join(__dirname, &quot;..&quot;, &quot;src&quot;, &quot;assets&quot;),</span><br><span class="line">    &#125;</span><br><span class="line">```  </span><br><span class="line"></span><br><span class="line">其中vue$表示引入vue，就可以像下面这么写：  </span><br><span class="line">```  </span><br><span class="line">import Vue from &apos;vue&apos;</span><br></pre></td></tr></table></figure><p>　　另外，对于@pages和@components我们就可以直接引用了，而省去了一大堆的复杂应用，另外通过@可以消除歧义。如下所示：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">import Hello from &apos;@components/Hello&apos;;</span><br></pre></td></tr></table></figure></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">import App from &apos;@pages/App&apos;</span><br></pre></td></tr></table></figure><p>　　值得注意的时： 在webpack.config.js中我们不能使用../ 以及./这种形式的路径方式，而是通过 path.join 和 __dirname 这种形式来表示路径，否则会报错。</p><p>　　另外： 在组件中，我们会引用一些静态文件，即static下的文件， 这时我们就不能用 alias 下的配置了，而必须使用一般的配置方式。  </p><h2 id="构建目标"><a href="#构建目标" class="headerlink" title="构建目标"></a>构建目标</h2><p>因为服务器和浏览器代码都可以用 JavaScript 编写，所以 webpack 提供了多种构建目标(target)，你可以在你的 webpack 配置中设置。  </p><h3 id="用法"><a href="#用法" class="headerlink" title="用法"></a>用法</h3><p>要设置 target 属性，只需要在你的 webpack 配置中设置 target 的值。<br>webpack.config.js<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">module.exports = &#123;</span><br><span class="line">  target: &apos;node&apos;</span><br><span class="line">&#125;;  </span><br><span class="line">```  </span><br><span class="line">在上面例子中，使用 node webpack 会编译为用于「类 Node.js」环境（使用 Node.js 的 require ，而不是使用任意内置模块（如 fs 或 path）来加载 chunk）。  </span><br><span class="line"></span><br><span class="line">### 多个Target  </span><br><span class="line">尽管 webpack 不支持向 target 传入多个字符串，你可以通过打包两份分离的配置来创建同构的库：  </span><br><span class="line">webpack.config.js</span><br></pre></td></tr></table></figure></p><p>var path = require(‘path’);<br>var serverConfig = {<br>  target: ‘node’,<br>  output: {<br>    path: path.resolve(__dirname, ‘dist’),<br>    filename: ‘lib.node.js’<br>  }<br>  //…<br>};</p><p>var clientConfig = {<br>  target: ‘web’, // &lt;=== 默认是 ‘web’，可省略<br>  output: {<br>    path: path.resolve(__dirname, ‘dist’),<br>    filename: ‘lib.js’<br>  }<br>  //…<br>};</p><p>module.exports = [ serverConfig, clientConfig ];<br><code>`</code><br>上面的例子将在你的 dist 文件夹下创建 lib.js 和 lib.node.js 文件。</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;webpack&quot;&gt;&lt;a href=&quot;#webpack&quot; class=&quot;headerlink&quot; title=&quot;webpack&quot;&gt;&lt;/a&gt;webpack&lt;/h1&gt;&lt;p&gt;是一个现代 JavaScript 应用程序的静态模块打包器(module bundler)。当 webpack 处理应用程序时，它会递归地构建一个依赖关系图(dependency graph)，其中包含应用程序需要的每个模块，然后将所有这些模块打包成一个或多个 bundle。  &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;入口(entry)&lt;/li&gt;
&lt;li&gt;输出(output)&lt;/li&gt;
&lt;li&gt;loader&lt;/li&gt;
&lt;li&gt;&lt;p&gt;插件(plugins)  &lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;
    
    </summary>
    
      <category term="web" scheme="http://yaliixxg.github.io/categories/web/"/>
    
    
      <category term="webpack" scheme="http://yaliixxg.github.io/tags/webpack/"/>
    
  </entry>
  
  <entry>
    <title>《图解HTTP》学习笔记</title>
    <link href="http://yaliixxg.github.io/2018/07/12/h/"/>
    <id>http://yaliixxg.github.io/2018/07/12/h/</id>
    <published>2018-07-12T03:49:00.000Z</published>
    <updated>2018-07-12T08:40:59.320Z</updated>
    
    <content type="html"><![CDATA[<h3 id="坚持-｡◕ˇ∀ˇ◕"><a href="#坚持-｡◕ˇ∀ˇ◕" class="headerlink" title="坚持 (｡◕ˇ∀ˇ◕)"></a>坚持 (｡◕ˇ∀ˇ◕)</h3><h3 id="HTTP"><a href="#HTTP" class="headerlink" title="HTTP"></a>HTTP</h3><p>超文本传输协议（超文本转移协议）</p><h3 id="TCP-IP"><a href="#TCP-IP" class="headerlink" title="TCP/IP"></a>TCP/IP</h3><p>互联网相关的各类协议族的总称，协议存在各式各样的内容。从电缆的规格到IP地址的选定方法、双方建立通信的顺序，以及web页面显示需要处理的步骤，等等。<br>按层次分别为：应用层、传输层、网络层、数据链路层。  </p><h4 id="从客户端发送请求到服务端接收请求流程如图："><a href="#从客户端发送请求到服务端接收请求流程如图：" class="headerlink" title="从客户端发送请求到服务端接收请求流程如图："></a>从客户端发送请求到服务端接收请求流程如图：</h4><p><img src="/2018/07/12/h/h2.png" alt="h2"><br><a id="more"></a></p><h3 id="IP"><a href="#IP" class="headerlink" title="IP"></a>IP</h3><p>IP协议的作用是把各种数据包传送给对方。而要确保传送到对方那里，则需要满足各类条件。其中最重要的条件是IP地址和MAC地址（网卡所属的固定地址）<br><img src="/2018/07/12/h/h3.png" alt="h3">  </p><h3 id="TCP"><a href="#TCP" class="headerlink" title="TCP"></a>TCP</h3><p>TCP位于传输层，提供可靠的字节流服务。为了更容易传达大数据把数据分割，确保数据能到达目标。<br>为了准确无误的将数据送达到目标出，采用三次握手策略。<br><img src="/2018/07/12/h/h4.png" alt="h4">  </p><h3 id="DNS"><a href="#DNS" class="headerlink" title="DNS"></a>DNS</h3><p>DNS位于应用层的协议。提供域名到IP地址之间的解析服务。<br><img src="/2018/07/12/h/h5.png" alt="h5">  </p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p><img src="/2018/07/12/h/h6.png" alt="http6">  </p><h3 id="告知服务器意图的HTTP方法"><a href="#告知服务器意图的HTTP方法" class="headerlink" title="告知服务器意图的HTTP方法"></a>告知服务器意图的HTTP方法</h3><p><img src="/2018/07/12/h/h7.png" alt="h7">  </p><h3 id="返回结果的HTTP状态码"><a href="#返回结果的HTTP状态码" class="headerlink" title="返回结果的HTTP状态码"></a>返回结果的HTTP状态码</h3><p><img src="/2018/07/12/h/h8.png" alt="h8">  </p><p>200:OK 表示从客户端发来的请求在服务器端被正常处理了。<br>204:No Content 表示客户端发来的请求处理成功，但是服务端没有资源科返回。一般按在只需要从客户端往服务器发送信息，而对客户端不需要发送新内容的情况下使用。<br>206:Partical Content 表示客户端进行了范围请求，而服务器成功执行了这一部分的GET请求。  </p><p>301:Moved Permanently 永久性重定向。该状态码表示请求的资源已被分配了新的URI，以后应使用资源现在所指的URI。<br>302:Found 临时性重定向。表示请求的资源已被分配了新的URI，希望用户（本次）能使用新的URI访问。<br>303:See Other 表示由于请求对应的资源存折另一个URI，应使用GET方法定向获取请求的资源。<br>304:Not Modified 表示客户端发送附带条件的请求时，服务器端允许请求访问资源，但为满足条件的情况。<br>307:Temporary Redirect 临时性重定向，和302一样。只是它会遵守标准，不会从POST变成GET。  </p><p>400:Bed Request 表示请求报文中存在语法错误。当错误发生时，需修改请求的内容后再次发送请求。<br>401:Unauthorized 表示发送的请求需要通过HTTP认证的认证信息。另外若之前已进行过一次请求，则表示用户认证失败。浏览器初次接收到401响应，会弹出认证用的对话窗口。<br>403:Forbidden 表情对请求资源的访问被服务器拒绝了。<br>404:Not Found 表明服务器上无法找到请求的资源。  </p><p>500:Internal Server Error 表明服务器端在执行请求时发生了错误。也有可能是web应用存在的BUG或某些临时的故障。<br>503:Service Unavailable 表明服务器暂时处于超负载或正在进行停机维护，现在无法处理请求。</p><h3 id="HTTP首部字段一览"><a href="#HTTP首部字段一览" class="headerlink" title="HTTP首部字段一览"></a>HTTP首部字段一览</h3><p><img src="/2018/07/12/h/h9.png" alt="h9"><br><img src="/2018/07/12/h/h10.png" alt="h10"><br><img src="/2018/07/12/h/h11.png" alt="h12"><br><img src="/2018/07/12/h/h12.png" alt="h12">  </p><h3 id="HTTPS"><a href="#HTTPS" class="headerlink" title="HTTPS"></a>HTTPS</h3><ul><li>HTTP的缺点：  <ul><li>通信使用明文（不加密），内容可能会被窃听  </li><li>不验证通信方的身份，因此有可能遭遇伪装</li><li>无法证明报文的额完整性，所以有可能已遭篡改</li></ul></li></ul><p>HTTPS（全称：Hyper Text Transfer Protocol over Secure Socket Layer 超文本传输安全协议），是以安全为目标的HTTP通道，简单讲是HTTP的安全版。即HTTP下加入SSL层（Secure Socket Layer，安全嵌套层）或 TSL（Transport Layer Security，安全层传输协议）的组合使用，HTTPS的安全基础是SSL，因此加密的详细内容就需要SSL。</p><ul><li><p>HTTPS和HTTP的区别<br>超文本传输协议HTTP协议被用于在Web浏览器和网站服务器之间传递信息。HTTP协议以明文方式发送内容，不提供任何方式的数据加密，如果攻击者截取了Web浏览器和网站服务器之间的传输报文，就可以直接读懂其中的信息，因此HTTP协议不适合传输一些敏感信息，比如信用卡号、密码等。<br>为了解决HTTP协议的这一缺陷，需要使用另一种协议：安全套接字层超文本传输协议HTTPS。为了数据传输的安全，HTTPS在HTTP的基础上加入了SSL协议，SSL依靠证书来验证服务器的身份，并为浏览器和服务器之间的通信加密。</p><h4 id="HTTPS和HTTP的区别主要为以下四点："><a href="#HTTPS和HTTP的区别主要为以下四点：" class="headerlink" title="HTTPS和HTTP的区别主要为以下四点："></a>HTTPS和HTTP的区别主要为以下四点：</h4><ul><li>一、https协议需要到ca申请证书，一般免费证书很少，需要交费。</li><li>二、http是超文本传输协议，信息是明文传输，https 则是具有安全性的ssl加密传输协议。</li><li>三、http和https使用的是完全不同的连接方式，用的端口也不一样，前者是80，后者是443。</li><li>四、http的连接很简单，是无状态的；HTTPS协议是由SSL+HTTP协议构建的可进行加密传输、身份认证的网络协议，比http协议安全。  </li></ul><h3 id="HTTPS-HTTP-加密-认证-完整性保护"><a href="#HTTPS-HTTP-加密-认证-完整性保护" class="headerlink" title="HTTPS = HTTP + 加密 + 认证 + 完整性保护"></a>HTTPS = HTTP + 加密 + 认证 + 完整性保护</h3><p>HTTPS采用混合加密机制<br><img src="/2018/07/12/h/h13.png" alt="h13"></p></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;坚持-｡◕ˇ∀ˇ◕&quot;&gt;&lt;a href=&quot;#坚持-｡◕ˇ∀ˇ◕&quot; class=&quot;headerlink&quot; title=&quot;坚持 (｡◕ˇ∀ˇ◕)&quot;&gt;&lt;/a&gt;坚持 (｡◕ˇ∀ˇ◕)&lt;/h3&gt;&lt;h3 id=&quot;HTTP&quot;&gt;&lt;a href=&quot;#HTTP&quot; class=&quot;headerlink&quot; title=&quot;HTTP&quot;&gt;&lt;/a&gt;HTTP&lt;/h3&gt;&lt;p&gt;超文本传输协议（超文本转移协议）&lt;/p&gt;
&lt;h3 id=&quot;TCP-IP&quot;&gt;&lt;a href=&quot;#TCP-IP&quot; class=&quot;headerlink&quot; title=&quot;TCP/IP&quot;&gt;&lt;/a&gt;TCP/IP&lt;/h3&gt;&lt;p&gt;互联网相关的各类协议族的总称，协议存在各式各样的内容。从电缆的规格到IP地址的选定方法、双方建立通信的顺序，以及web页面显示需要处理的步骤，等等。&lt;br&gt;按层次分别为：应用层、传输层、网络层、数据链路层。  &lt;/p&gt;
&lt;h4 id=&quot;从客户端发送请求到服务端接收请求流程如图：&quot;&gt;&lt;a href=&quot;#从客户端发送请求到服务端接收请求流程如图：&quot; class=&quot;headerlink&quot; title=&quot;从客户端发送请求到服务端接收请求流程如图：&quot;&gt;&lt;/a&gt;从客户端发送请求到服务端接收请求流程如图：&lt;/h4&gt;&lt;p&gt;&lt;img src=&quot;/2018/07/12/h/h2.png&quot; alt=&quot;h2&quot;&gt;&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="web" scheme="http://yaliixxg.github.io/categories/web/"/>
    
    
      <category term="http" scheme="http://yaliixxg.github.io/tags/http/"/>
    
  </entry>
  
  <entry>
    <title>程序员的技能思考</title>
    <link href="http://yaliixxg.github.io/2018/07/10/20180710think/"/>
    <id>http://yaliixxg.github.io/2018/07/10/20180710think/</id>
    <published>2018-07-10T09:55:01.000Z</published>
    <updated>2018-07-10T10:00:08.501Z</updated>
    
    <content type="html"><![CDATA[<h3 id="程序员的两条腿"><a href="#程序员的两条腿" class="headerlink" title="程序员的两条腿"></a>程序员的两条腿</h3><ul><li>数学</li><li>英语</li></ul><p>除此之外是职业技能<br><a id="more"></a></p><ul><li>学习能力<br>通过多途径的方式快速习得必要知识，这些途径包括搜索引擎，实体书籍，电子文档，论坛提问等。</li><li>编码能力<ul><li>编程语言的掌握<br>理解语言的特性编写清晰高效的代码，命名直观，注释准确。<br>理解语言的实现，能供透过语言的形式了解其背后的原理，从而优化代码，或是触类旁通学习其它语言。<br>理解不同编程范式并在合适的场景下应用，命令式，声明式两大类，前者向计算机描述问题的求解过程 how ，后者向计算机描述问题是什么 what，函数式编程归属于声明式。（过程式，函数式，对象式，并发，逻辑等）</li><li>技术栈的掌握<br>掌握各种框架及工具链解决工程开发问题<br>利用各种框架及工具搭建项目工程<br>了解各类技术的应用场景与实现  </li><li>编程思想的理解<br>抽象<br>模块化、复用<br>分层<br>低耦合高内聚原则<br>SOLID 原则  </li><li>数据结构与算法  </li></ul></li><li>解决问题的能力<ul><li>发现问题<br>调试技巧，经验与直觉</li><li>描述问题<br>恰当的语言描述问题</li><li>解决问题<br>直接解决，求助解决，借助互联网解决</li></ul></li><li>设计与架构能力<ul><li>架构原则</li><li>通用设计模式</li></ul></li><li>沟通表达能力<ul><li>文档编写（PPT，博文）</li><li>语言表达</li></ul></li><li>业务领域知识</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;程序员的两条腿&quot;&gt;&lt;a href=&quot;#程序员的两条腿&quot; class=&quot;headerlink&quot; title=&quot;程序员的两条腿&quot;&gt;&lt;/a&gt;程序员的两条腿&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;数学&lt;/li&gt;
&lt;li&gt;英语&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;除此之外是职业技能&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="web" scheme="http://yaliixxg.github.io/categories/web/"/>
    
    
      <category term="程序员思考" scheme="http://yaliixxg.github.io/tags/%E7%A8%8B%E5%BA%8F%E5%91%98%E6%80%9D%E8%80%83/"/>
    
  </entry>
  
  <entry>
    <title>在vue项目中 如何定义全局变量 全局函数</title>
    <link href="http://yaliixxg.github.io/2018/07/03/global/"/>
    <id>http://yaliixxg.github.io/2018/07/03/global/</id>
    <published>2018-07-03T07:54:36.000Z</published>
    <updated>2018-07-12T03:48:17.492Z</updated>
    
    <content type="html"><![CDATA[<p>定义全局变量<br>原理：<br>设置一个专用的的全局变量模块文件，模块里面定义一些变量初始状态，用export default 暴露出去，在main.js里面使用Vue.prototype挂载到vue实例上面或者在其它地方需要使用时，引入该模块便可。</p><p>全局变量模块文件：<br>Global.vue文件：</p><p><img src="/2018/07/03/global/vue1.png" alt="vue1"></p><h1 id="使用方式1："><a href="#使用方式1：" class="headerlink" title="使用方式1："></a>使用方式1：</h1><p>在需要的地方引用进全局变量模块文件，然后通过文件里面的变量名字获取全局变量参数值。</p><p>在text1.vue组件中使用：</p><p><img src="/2018/07/03/global/vue2.png" alt="vue2"><br><a id="more"></a></p><h1 id="使用方式2："><a href="#使用方式2：" class="headerlink" title="使用方式2："></a>使用方式2：</h1><p>在程序入口的main.js文件里面，将上面那个Global.vue文件挂载到Vue.prototype。</p><pre><code>import global_ from &apos;./components/Global&apos;//引用文件Vue.prototype.GLOBAL = global_//挂载到Vue实例上面</code></pre><p>接着在整个项目中不需要再通过引用Global.vue模块文件，直接通过this就可以直接访问Global文件里面定义的全局变量。</p><p>text2.vue：</p><p><img src="/2018/07/03/global/vue3.png" alt="vue3"></p><p>Vuex也可以设置全局变量：<br>通过vuex来存放全局变量，这里东西比较多，也相对复杂一些，有兴趣的小伙伴们，可自行查阅资料，折腾一波、</p><p>定义全局函数<br>原理<br>新建一个模块文件，然后在main.js里面通过Vue.prototype将函数挂载到Vue实例上面，通过this.函数名，来运行函数。</p><ol><li>在main.js里面直接写函数<br>简单的函数可以直接在main.js里面直接写</li></ol><p>Vue.prototype.changeData = function (){//changeData是函数名<br>  alert(‘执行成功’);<br>}<br>组件中调用：</p><p>this.changeData();//直接通过this运行函数</p><ol start="2"><li>写一个模块文件，挂载到main.js上面。<br>base.js文件，文件位置可以放在跟main.js同一级，方便引用</li></ol><p>exports.install = function (Vue, options) {<br>   Vue.prototype.text1 = function (){//全局函数1<br>    alert(‘执行成功1’);<br>    };<br>    Vue.prototype.text2 = function (){//全局函数2<br>    alert(‘执行成功2’);<br>    };<br>};<br>main.js入口文件：</p><pre><code>import base from &apos;./base&apos;//引用Vue.use(base);//将全局函数当做插件来进行注册</code></pre><p>组件里面调用：</p><pre><code>this.text1();this.text2();</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;定义全局变量&lt;br&gt;原理：&lt;br&gt;设置一个专用的的全局变量模块文件，模块里面定义一些变量初始状态，用export default 暴露出去，在main.js里面使用Vue.prototype挂载到vue实例上面或者在其它地方需要使用时，引入该模块便可。&lt;/p&gt;
&lt;p&gt;全局变量模块文件：&lt;br&gt;Global.vue文件：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/2018/07/03/global/vue1.png&quot; alt=&quot;vue1&quot;&gt;&lt;/p&gt;
&lt;h1 id=&quot;使用方式1：&quot;&gt;&lt;a href=&quot;#使用方式1：&quot; class=&quot;headerlink&quot; title=&quot;使用方式1：&quot;&gt;&lt;/a&gt;使用方式1：&lt;/h1&gt;&lt;p&gt;在需要的地方引用进全局变量模块文件，然后通过文件里面的变量名字获取全局变量参数值。&lt;/p&gt;
&lt;p&gt;在text1.vue组件中使用：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/2018/07/03/global/vue2.png&quot; alt=&quot;vue2&quot;&gt;&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="web" scheme="http://yaliixxg.github.io/categories/web/"/>
    
    
      <category term="vue 全局变量" scheme="http://yaliixxg.github.io/tags/vue-%E5%85%A8%E5%B1%80%E5%8F%98%E9%87%8F/"/>
    
  </entry>
  
  <entry>
    <title>12岁的晴天</title>
    <link href="http://yaliixxg.github.io/2018/07/03/sunny/"/>
    <id>http://yaliixxg.github.io/2018/07/03/sunny/</id>
    <published>2018-07-03T02:30:23.000Z</published>
    <updated>2018-07-10T01:37:53.089Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/2018/07/03/sunny/sunny1.jpg" alt="sunny1"><br><img src="/2018/07/03/sunny/sunny2.jpg" alt="sunny2"></p><p>从前从前有个人爱你很久<br>但偏偏，雨渐渐，把距离吹的好远</p><p>刮风这天<br>我试过握着你手</p><p>还要多久，我才能在你身边<br>等到放晴的那天<br>也许我会比较好一点</p><p>为你翘课的那一天<br>花落的那一天<br>教室的那一间<br>我怎么看不见<br>消失的下雨天<br>我好想再淋一遍</p><p>12岁的晴天<br>但故事的最后，你好像还是说了</p><h1 id="拜。"><a href="#拜。" class="headerlink" title="拜。"></a>拜。</h1>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;img src=&quot;/2018/07/03/sunny/sunny1.jpg&quot; alt=&quot;sunny1&quot;&gt;&lt;br&gt;&lt;img src=&quot;/2018/07/03/sunny/sunny2.jpg&quot; alt=&quot;sunny2&quot;&gt;&lt;/p&gt;
&lt;p&gt;从前从前有个人爱你很久&lt;br&gt;但偏偏，
      
    
    </summary>
    
      <category term="音乐" scheme="http://yaliixxg.github.io/categories/%E9%9F%B3%E4%B9%90/"/>
    
    
      <category term="晴天 周杰伦" scheme="http://yaliixxg.github.io/tags/%E6%99%B4%E5%A4%A9-%E5%91%A8%E6%9D%B0%E4%BC%A6/"/>
    
  </entry>
  
  <entry>
    <title>跨域请求传递cookie问题</title>
    <link href="http://yaliixxg.github.io/2018/06/20/pageaxios/"/>
    <id>http://yaliixxg.github.io/2018/06/20/pageaxios/</id>
    <published>2018-06-20T08:10:34.000Z</published>
    <updated>2018-06-20T08:15:04.021Z</updated>
    
    <content type="html"><![CDATA[<p>问题描述<br>前后端完全分离的项目，前端使用Vue + axios，后端使用SpringMVC，容器为Tomcat。<br>使用CORS协议解决跨域访问数据限制的问题，但是发现客户端的Ajax请求不会自动带上服务器返回的Cookie：JSESSIONID。<br>导致每一个Ajax请求在服务端看来都是一个新的请求，都会在服务端创建新的Session（在响应消息头中设置Set-Cookie：JSESSIONID=xxx）。<br>而在项目中使用了Shiro框架，用户认证信息是放在Session中的，由于客户端不会把JSESSIONID返回给服务器端，因此使用Session策略存放数据的方式不可用。<br><a id="more"></a><br>原因分析<br>实际上，这是浏览器的同源策略导致的问题：不允许JS访问跨域的Cookie。<br>举个例子，现有网站A使用域名a.example.com，网站B使用域名b.example.com，如果希望在2个网站之间共享Cookie（浏览器可以将Cookie发送给服务器），那么在设置的Cookie的时候，必须设置domain为example.com。</p><p>解决方案<br>需要从2个方面解决：<br>1.服务器端使用CROS协议解决跨域访问数据问题时，需要设置响应消息头Access-Control-Allow-Credentials值为“true”。<br>同时，还需要设置响应消息头Access-Control-Allow-Origin值为指定单一域名（注：不能为通配符“*”）。</p><p>@Override<br>public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain)<br>        throws IOException, ServletException {<br>    HttpServletRequest req = (HttpServletRequest)request;<br>    HttpServletResponse resp = (HttpServletResponse)response;</p><pre><code>String origin = req.getHeader(&quot;Origin&quot;);if(origin == null) {    origin = req.getHeader(&quot;Referer&quot;);}resp.setHeader(&quot;Access-Control-Allow-Origin&quot;, origin);            // 允许指定域访问跨域资源resp.setHeader(&quot;Access-Control-Allow-Credentials&quot;, &quot;true&quot;);       // 允许客户端携带跨域cookie，此时origin值不能为“*”，只能为指定单一域名if(RequestMethod.OPTIONS.toString().equals(req.getMethod())) {    String allowMethod = req.getHeader(&quot;Access-Control-Request-Method&quot;);    String allowHeaders = req.getHeader(&quot;Access-Control-Request-Headers&quot;);    resp.setHeader(&quot;Access-Control-Max-Age&quot;, &quot;86400&quot;);            // 浏览器缓存预检请求结果时间,单位:秒    resp.setHeader(&quot;Access-Control-Allow-Methods&quot;, allowMethod);  // 允许浏览器在预检请求成功之后发送的实际请求方法名    resp.setHeader(&quot;Access-Control-Allow-Headers&quot;, allowHeaders); // 允许浏览器发送的请求消息头    return;}chain.doFilter(request, response);</code></pre><p>}<br>2.客户端需要设置Ajax请求属性withCredentials=true，让Ajax请求都带上Cookie。</p><p>对于XMLHttpRequest的Ajax请求</p><p>var xhr = new XMLHttpRequest();<br>xhr.open(‘GET’, url);<br>xhr.withCredentials = true; // 携带跨域cookie<br>xhr.send();</p><p>对于JQuery的Ajax请求</p><p>$.ajax({<br>type: “GET”,<br>url: url,<br>xhrFields: {<br>    withCredentials: true // 携带跨域cookie<br>},<br>processData: false,<br>success: function(data) {<br>    console.log(data);<br>}<br>});</p><p>对于axios的Ajax请求</p><p>axios.defaults.withCredentials=true; // 让ajax携带cookie</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;问题描述&lt;br&gt;前后端完全分离的项目，前端使用Vue + axios，后端使用SpringMVC，容器为Tomcat。&lt;br&gt;使用CORS协议解决跨域访问数据限制的问题，但是发现客户端的Ajax请求不会自动带上服务器返回的Cookie：JSESSIONID。&lt;br&gt;导致每一个Ajax请求在服务端看来都是一个新的请求，都会在服务端创建新的Session（在响应消息头中设置Set-Cookie：JSESSIONID=xxx）。&lt;br&gt;而在项目中使用了Shiro框架，用户认证信息是放在Session中的，由于客户端不会把JSESSIONID返回给服务器端，因此使用Session策略存放数据的方式不可用。&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="web" scheme="http://yaliixxg.github.io/categories/web/"/>
    
    
      <category term="跨域" scheme="http://yaliixxg.github.io/tags/%E8%B7%A8%E5%9F%9F/"/>
    
  </entry>
  
  <entry>
    <title>Summer&#39;s Gone Ft. Jony J (Prod.by PDP)</title>
    <link href="http://yaliixxg.github.io/2018/06/15/summer/"/>
    <id>http://yaliixxg.github.io/2018/06/15/summer/</id>
    <published>2018-06-15T02:37:48.000Z</published>
    <updated>2018-06-15T02:44:27.044Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/2018/06/15/summer/summer.jpg" alt="summer"><br>词与唱：大包子，Jony J</p><p>好沮丧 the Summer’s Gone 气温又降了 不知不觉又添了衣裳<br>仲夏一个单薄的梦 像是纱做的蚊帐 被折叠成秘密封藏<br>Oh no the Summer’s Gone , my life becomes from fresh to dark brown<br>想起那时的夜短昼长 热浪 似乎将我的青春期延长</p><p>等待一场半夜的球赛 左手啤酒右手可乐都加满了冰块<br>冰激凌听话的躺在冷柜 等着触碰我们干燥的唇和胃<br>大口的喝水 一杯又一杯 每当汗流浃背 虚弱又颓废<br>细胞，嗷嗷待哺的张开了嘴 补充了能量继续PLAY DA GAME<br>男孩迫不及待的跳进池塘 假装乘风破浪 水花肆意碰撞<br>水鬼也被逼上了岸 仿佛生的热气驱走了死的严寒<br>天亮得早白天长 不用闹钟我也不会赖床<br>冲凉 柠檬沐浴香<br>裸露的皮肤 汗毛茁壮生长<br>花露水的味道是种安心的清凉<br>蚊虫的叮咬 挠了又挠的瘙痒<br>泄气的大地 苦等着风 稠腻的晌午 人们寻找遮蔽行色匆匆<br>躲在屋里 不用找别的借口<br>你是我的解暑良药我的冰镇樱桃汽酒<br>咽下一口 沿着我的食道四壁<br>湿润粗糙的黏膜 沁入我的心脾<br><a id="more"></a></p><p>说真的时间他就是个小气鬼<br>在半睡半醒之间多想让闹钟闭嘴<br>这种感觉可以去跟fly high媲美<br>我伸手就抓过了桌上的汽水<br>在湿热的午后 好像被下了诅咒<br>我甚至可以闻到自己灵魂里的腐臭<br>这好热 我实在爱死这个季节<br>暴烈的阳光赤裸的晒出这个世界<br>连呼吸都烫口 千万别把冷气放走<br>它塞满整个房间走廊散在每个窗口<br>我打开冰箱 有西瓜和饮料<br>就听着jazz打2k 我欢迎你来领教<br>听窗外有鸟叫 蝉鸣 和小孩哭闹<br>乘凉下棋的老人这一局又是谁输掉<br>b boys b girls还在街上跳舞<br>而夏天的结束也慢慢进入倒数</p><p>我才顾不得这天气的炎热<br>拥着你亲吻你汗湿的颈脖<br>你眼神的闪烁好像星空的斑驳<br>你跳跃的脊背是我心跳的忐忑<br>这热度加速挥发你的香气<br>凉席 留着你形状的汗滴<br>你毛孔微张 浅浅深深的呼吸<br>吱呀的电扇回应着我们的轻声密语<br>不停息的蝉鸣 跃跃欲试的情绪<br>而我一直心急 害怕片刻的分离<br>I wish my summer could last forever<br>get sweaty already we ran wild n wilder</p><p>整个夏日我一直在挥霍 发烫的眼神点燃荷尔蒙和不安的动作<br>阳光刺眼的片刻 美丽就快饱和<br>你给的快乐是我深陷的沼泽<br>但如果你走了 我的夏天就变晦涩<br>我收集六七八月却永远等不来收获<br>或许一夜长大是我唯一的选择<br>但我还妄想 守望夏天的那个我会复活<br>But the summer’s gone<br>My songs are not done<br>The wind blowing will never tell me where did I go wrong</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;/2018/06/15/summer/summer.jpg&quot; alt=&quot;summer&quot;&gt;&lt;br&gt;词与唱：大包子，Jony J&lt;/p&gt;
&lt;p&gt;好沮丧 the Summer’s Gone 气温又降了 不知不觉又添了衣裳&lt;br&gt;仲夏一个单薄的梦 像是纱做的蚊帐 被折叠成秘密封藏&lt;br&gt;Oh no the Summer’s Gone , my life becomes from fresh to dark brown&lt;br&gt;想起那时的夜短昼长 热浪 似乎将我的青春期延长&lt;/p&gt;
&lt;p&gt;等待一场半夜的球赛 左手啤酒右手可乐都加满了冰块&lt;br&gt;冰激凌听话的躺在冷柜 等着触碰我们干燥的唇和胃&lt;br&gt;大口的喝水 一杯又一杯 每当汗流浃背 虚弱又颓废&lt;br&gt;细胞，嗷嗷待哺的张开了嘴 补充了能量继续PLAY DA GAME&lt;br&gt;男孩迫不及待的跳进池塘 假装乘风破浪 水花肆意碰撞&lt;br&gt;水鬼也被逼上了岸 仿佛生的热气驱走了死的严寒&lt;br&gt;天亮得早白天长 不用闹钟我也不会赖床&lt;br&gt;冲凉 柠檬沐浴香&lt;br&gt;裸露的皮肤 汗毛茁壮生长&lt;br&gt;花露水的味道是种安心的清凉&lt;br&gt;蚊虫的叮咬 挠了又挠的瘙痒&lt;br&gt;泄气的大地 苦等着风 稠腻的晌午 人们寻找遮蔽行色匆匆&lt;br&gt;躲在屋里 不用找别的借口&lt;br&gt;你是我的解暑良药我的冰镇樱桃汽酒&lt;br&gt;咽下一口 沿着我的食道四壁&lt;br&gt;湿润粗糙的黏膜 沁入我的心脾&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="音乐" scheme="http://yaliixxg.github.io/categories/%E9%9F%B3%E4%B9%90/"/>
    
    
      <category term="夏天汽水" scheme="http://yaliixxg.github.io/tags/%E5%A4%8F%E5%A4%A9%E6%B1%BD%E6%B0%B4/"/>
    
  </entry>
  
  <entry>
    <title>乱七八糟のweb</title>
    <link href="http://yaliixxg.github.io/2018/06/14/web/"/>
    <id>http://yaliixxg.github.io/2018/06/14/web/</id>
    <published>2018-06-14T09:55:23.000Z</published>
    <updated>2018-07-12T01:45:45.939Z</updated>
    
    <content type="html"><![CDATA[<p>基于vue-cli快速构建：<a href="https://www.jianshu.com/p/2769efeaa10a" target="_blank" rel="noopener">https://www.jianshu.com/p/2769efeaa10a</a></p><p>10分钟学会基本的 Flexbox 布局：<a href="http://www.css88.com/archives/7760" target="_blank" rel="noopener">http://www.css88.com/archives/7760</a></p><p>CSS使用flex处理不同宽度屏幕上的布局：<a href="https://segmentfault.com/q/1010000006991463" target="_blank" rel="noopener">https://segmentfault.com/q/1010000006991463</a></p><a id="more"></a><p>常用代码压缩工具网站：</p><p>1.<a href="https://tool.lu/css/" target="_blank" rel="noopener">https://tool.lu/css/</a>    压缩Css比较方便</p><ol start="2"><li><a href="http://tool.oschina.net/jscompress?type=2" target="_blank" rel="noopener">http://tool.oschina.net/jscompress?type=2</a>  Html,Css,Js都可以压缩。</li></ol><p>3.<a href="http://tool.chinaz.com/Tools/CssFormat.aspx" target="_blank" rel="noopener">http://tool.chinaz.com/Tools/CssFormat.aspx</a>  站长工具，这个就不介绍了，常用。</p><p>软件下载：3D溜溜网</p><p>学会了ES6，就不会写出那样的代码：<a href="https://juejin.im/post/5acb1847f265da237c693362" target="_blank" rel="noopener">https://juejin.im/post/5acb1847f265da237c693362</a></p><p>【基础知识】Flex-弹性布局原来如此简单！！：<a href="https://juejin.im/post/5ac2329b6fb9a028bf057caf" target="_blank" rel="noopener">https://juejin.im/post/5ac2329b6fb9a028bf057caf</a></p><p>postman百度网盘下载：<a href="https://pan.baidu.com/s/1bp1LSGf/?errno=0&amp;errmsg=Auth%20Login%20Sucess&amp;&amp;bduss=&amp;ssnerror=0&amp;traceid=" target="_blank" rel="noopener">https://pan.baidu.com/s/1bp1LSGf/?errno=0&amp;errmsg=Auth%20Login%20Sucess&amp;&amp;bduss=&amp;ssnerror=0&amp;traceid=</a></p><p>ES6:<a href="http://es6.ruanyifeng.com/" target="_blank" rel="noopener">http://es6.ruanyifeng.com/</a></p><p>webpack超详细配置, 使用教程(图文):<a href="https://blog.csdn.net/c_kite/article/details/71279853" target="_blank" rel="noopener">https://blog.csdn.net/c_kite/article/details/71279853</a></p><p>webpack中文文档：<a href="https://www.webpackjs.com/concepts/entry-points/" target="_blank" rel="noopener">https://www.webpackjs.com/concepts/entry-points/</a></p><p>蜂投网git：<a href="http://192.168.52.153:3000/" target="_blank" rel="noopener">http://192.168.52.153:3000/</a></p><p>Vue实现一个移动端屏蔽滑动的遮罩层：<a href="https://www.cnblogs.com/Eden-cola/p/vue-overlayer.html" target="_blank" rel="noopener">https://www.cnblogs.com/Eden-cola/p/vue-overlayer.html</a></p><p>Vue 多页面应用webpack如何设置：<a href="https://segmentfault.com/q/1010000009475223/a-1020000009475360" target="_blank" rel="noopener">https://segmentfault.com/q/1010000009475223/a-1020000009475360</a></p><p>webpack + vue + vueRouter 模块化构建完整项目代码实例 <a href="https://segmentfault.com/a/1190000008602934" target="_blank" rel="noopener">https://segmentfault.com/a/1190000008602934</a></p><p>查看webpack打包的文件是哪些？ <a href="http://localhost:8080/webpack-dev-server" target="_blank" rel="noopener">http://localhost:8080/webpack-dev-server</a></p><p>git如何把本地项目推送到github仓库 <a href="https://jingyan.baidu.com/article/00a07f38757d0482d028dce5.html" target="_blank" rel="noopener">https://jingyan.baidu.com/article/00a07f38757d0482d028dce5.html</a></p><p>github push 提交代码时停止在writing objects怎么办？ git config –global http.postBuffer 524288000</p><p>用webpack打包配置vue文件时，记得要安装一个插件：HtmlWebpackPlugin 用来编译HTML文件</p><p>解决谷歌浏览器限制跨域问题： –args –disable-web-security  –user-data-dir</p><p>gitLab: <a href="http://192.168.56.161:6699/gitlab/" target="_blank" rel="noopener">http://192.168.56.161:6699/gitlab/</a></p><p>监听VUE路由变化，部分数据无法更新？<a href="http://www.cnblogs.com/first-time/p/7067674.html" target="_blank" rel="noopener">http://www.cnblogs.com/first-time/p/7067674.html</a></p><p>日历签到插件：<a href="https://github.com/Arguiwu/calendar" target="_blank" rel="noopener">https://github.com/Arguiwu/calendar</a></p><p>vscode 插件 超级简单 px转换rem :<a href="https://segmentfault.com/a/1190000009572846" target="_blank" rel="noopener">https://segmentfault.com/a/1190000009572846</a></p><p>px和rem 互转 ： <a href="http://pvp.qq.com/act/a20161209story/rempx.htm" target="_blank" rel="noopener">http://pvp.qq.com/act/a20161209story/rempx.htm</a></p><p>React in patterns 中文版<br> 介绍 React 开发的设计模式和技术的免费开源书籍。：<a href="https://github.com/SangKa/react-in-patterns-cn" target="_blank" rel="noopener">https://github.com/SangKa/react-in-patterns-cn</a></p><p>网易的开发规范：<a href="http://res.nie.netease.com/comm/doc/professional/PC%E5%A4%96%E5%8C%85%E9%A1%B5%E9%9D%A2%E5%88%B6%E4%BD%9C%E8%A7%84%E8%8C%83.html" target="_blank" rel="noopener">http://res.nie.netease.com/comm/doc/professional/PC%E5%A4%96%E5%8C%85%E9%A1%B5%E9%9D%A2%E5%88%B6%E4%BD%9C%E8%A7%84%E8%8C%83.html</a><br>十三位时间戳转换: new Date(parseInt((“/Date(“+nS+”)/“).substr(6, 13))).toLocaleDateString()</p><p>移动端点击、触碰随记：<a href="https://toutiao.io/posts/rf760/preview" target="_blank" rel="noopener">https://toutiao.io/posts/rf760/preview</a></p><p>如何在Vue项目中使用vw实现移动端适配：<a href="https://www.w3cplus.com/mobile/vw-layout-in-vue.html" target="_blank" rel="noopener">https://www.w3cplus.com/mobile/vw-layout-in-vue.html</a></p><p>vscode 中 git 的使用 <a href="https://juejin.im/post/5b00474951882542ba08087a" target="_blank" rel="noopener">https://juejin.im/post/5b00474951882542ba08087a</a><br>四月前端知识集锦（每月不可错过的文章集锦）：<a href="https://juejin.im/post/5ae95f17f265da0b93481dec?utm_source=gold_browser_extension" target="_blank" rel="noopener">https://juejin.im/post/5ae95f17f265da0b93481dec?utm_source=gold_browser_extension</a></p><p>javaScript比较两个日期的大小的2种方法：<a href="https://blog.csdn.net/w__yi/article/details/7992604" target="_blank" rel="noopener">https://blog.csdn.net/w__yi/article/details/7992604</a></p><p>熊猫压缩图片 <a href="https://tinypng.com/" target="_blank" rel="noopener">https://tinypng.com/</a></p><p>掘金酱 <a href="http://e.xitu.io/" target="_blank" rel="noopener">http://e.xitu.io/</a></p><p>webpack原理 <a href="https://segmentfault.com/a/1190000015088834" target="_blank" rel="noopener">https://segmentfault.com/a/1190000015088834</a></p><p>各种规范 <a href="https://juejin.im/entry/58b63fdf1b69e6006bfcf8ad" target="_blank" rel="noopener">https://juejin.im/entry/58b63fdf1b69e6006bfcf8ad</a></p><p>hexo博客插件：<a href="https://blog.csdn.net/Hoshea_chx/article/details/78826689" target="_blank" rel="noopener">https://blog.csdn.net/Hoshea_chx/article/details/78826689</a></p><p>next 美化 <a href="https://www.jianshu.com/p/f054333ac9e6" target="_blank" rel="noopener">https://www.jianshu.com/p/f054333ac9e6</a></p><p>知识点杂烩 <a href="https://github.com/qiu-deqing/FE-interview" target="_blank" rel="noopener">https://github.com/qiu-deqing/FE-interview</a></p><p>2018面试点 <a href="https://blog.csdn.net/VhWfR2u02Q/article/details/79765406#t2" target="_blank" rel="noopener">https://blog.csdn.net/VhWfR2u02Q/article/details/79765406#t2</a></p><p>优秀文章合集 <a href="https://juejin.im/post/5b3adfe2e51d4555b17e85df" target="_blank" rel="noopener">https://juejin.im/post/5b3adfe2e51d4555b17e85df</a></p><p>vue-layer <a href="https://cnodejs.org/topic/59707d120c87675e74674693" target="_blank" rel="noopener">https://cnodejs.org/topic/59707d120c87675e74674693</a></p><p>从输入URL到页面加载的过程？如何由一道题完善自己的前端知识体系！  <a href="https://juejin.im/post/5aa5cb846fb9a028e25d2fb1" target="_blank" rel="noopener">https://juejin.im/post/5aa5cb846fb9a028e25d2fb1</a></p><p>vue angular 组件 轮子工厂 <a href="http://www.wheelsfactory.cn/#/home" target="_blank" rel="noopener">http://www.wheelsfactory.cn/#/home</a></p><p>web 前端学习笔记 <a href="https://github.com/CyC2018/Interview-Notebook" target="_blank" rel="noopener">https://github.com/CyC2018/Interview-Notebook</a></p><p>Web组件 由几个单独的技术组成，可以使用现有的Web组件而无需编写代码，只需向HTML页面添加import语句即可  <a href="https://developer.mozilla.org/zh-CN/docs/Web/Web_Components" target="_blank" rel="noopener">https://developer.mozilla.org/zh-CN/docs/Web/Web_Components</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;基于vue-cli快速构建：&lt;a href=&quot;https://www.jianshu.com/p/2769efeaa10a&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://www.jianshu.com/p/2769efeaa10a&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;10分钟学会基本的 Flexbox 布局：&lt;a href=&quot;http://www.css88.com/archives/7760&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;http://www.css88.com/archives/7760&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;CSS使用flex处理不同宽度屏幕上的布局：&lt;a href=&quot;https://segmentfault.com/q/1010000006991463&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://segmentfault.com/q/1010000006991463&lt;/a&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="web" scheme="http://yaliixxg.github.io/categories/web/"/>
    
    
      <category term="web" scheme="http://yaliixxg.github.io/tags/web/"/>
    
  </entry>
  
  <entry>
    <title>Havana</title>
    <link href="http://yaliixxg.github.io/2018/06/14/oh-havana/"/>
    <id>http://yaliixxg.github.io/2018/06/14/oh-havana/</id>
    <published>2018-06-14T02:14:16.000Z</published>
    <updated>2018-06-14T07:19:12.764Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/2018/06/14/oh-havana/Havana.jpg" alt="Havana"><br>Oh, oh, oh, yeah<br>噢~噢~噢~耶~<br>Havana, ooh na-na<br>哈瓦那~哦啦啦<br>Half of my heart is in Havana, na-na-na<br>我的一半心思留在了哈瓦那<br>He took me back to East Atlanta, na-na-na<br>他带我重回东亚特兰大<br>All of my heart is in Havana<br>如今我的心全都属于哈瓦那<br>There’s somethin’ ‘bout his manners<br>犹记得他的一举一动<br><a id="more"></a><br>He didn’t walk up with that “how you doin’?”<br>他并没有过来找我搭讪<br>He said there’s a lot of girls I can do with<br>他说他能驾驭的女孩有很多<br>I knew him forever in a minute<br>但我却对他一见钟情<br>And papa says he got evil in him<br>尽管爸爸也说他不是个好东西<br>He got me feelin’ like…<br>他让我小鹿乱撞<br>Oooh-oooh-ooh, I knew it when I met him<br>噢噢噢~我对他一见钟情<br>I loved him when I left him<br>分别时就已经爱上了他<br>Got me feelin’ like…<br>他让我脸红心跳<br>Oooh-oooh-ooh, and then I had to tell him<br>噢噢噢~但我不得不告诉他：<br>I had to go, oh na-na-na-na-na<br>我不得不走了<br>Havana, ooh na-na<br>再见了，哈瓦那！<br>Half of my heart is in Havana, na-na-na<br>我的一半心思留在了哈瓦那<br>He took me back to East Atlanta, na-na-na<br>他带我重回东亚特兰大<br>All of my heart is in Havana<br>如今我的心全都属于哈瓦那<br>There’s somethin’ ‘bout his manners<br>犹记得他的一举一动<br>Oooh-oooh-ooh, Oooh-oooh-ooh, Oooh-oooh-ooh<br>哦~哦~哦~<br>Oh-na-na-na<br>哦啦啦啦<br>Havana, ooh na-na<br>哈瓦那~哦啦啦<br>Half of my heart is in Havana, na-na-na<br>我的一半心思留在了哈瓦那<br>He took me back to East Atlanta, na-na-na<br>他带我重回东亚特兰大<br>All of my heart is in Havana<br>如今我的心全都属于哈瓦那<br>There’s somethin’ ‘bout his manners<br>犹记得他的一举一动<br>Ooh na-na, Ooh na-na<br>哦啦啦~哦啦啦<br>Oooh-oooh-ooh,<br>哦~哦~哦~<br>Havana, ooh na-na<br>哈瓦那~哦啦啦~<br>Yeah yeah yeah, Havana, ooh na-na<br>耶耶耶，哈瓦那哦啦啦~</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;/2018/06/14/oh-havana/Havana.jpg&quot; alt=&quot;Havana&quot;&gt;&lt;br&gt;Oh, oh, oh, yeah&lt;br&gt;噢~噢~噢~耶~&lt;br&gt;Havana, ooh na-na&lt;br&gt;哈瓦那~哦啦啦&lt;br&gt;Half of my heart is in Havana, na-na-na&lt;br&gt;我的一半心思留在了哈瓦那&lt;br&gt;He took me back to East Atlanta, na-na-na&lt;br&gt;他带我重回东亚特兰大&lt;br&gt;All of my heart is in Havana&lt;br&gt;如今我的心全都属于哈瓦那&lt;br&gt;There’s somethin’ ‘bout his manners&lt;br&gt;犹记得他的一举一动&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="音乐" scheme="http://yaliixxg.github.io/categories/%E9%9F%B3%E4%B9%90/"/>
    
    
      <category term="音乐" scheme="http://yaliixxg.github.io/tags/%E9%9F%B3%E4%B9%90/"/>
    
  </entry>
  
  <entry>
    <title>世界杯要来啦！德国加油！</title>
    <link href="http://yaliixxg.github.io/2018/06/13/Cup/"/>
    <id>http://yaliixxg.github.io/2018/06/13/Cup/</id>
    <published>2018-06-13T03:55:49.000Z</published>
    <updated>2018-06-14T07:20:17.612Z</updated>
    
    <content type="html"><![CDATA[<p>希望俄罗斯世界杯，德国能举起大力神杯~！！！！！</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;希望俄罗斯世界杯，德国能举起大力神杯~！！！！！&lt;/p&gt;

      
    
    </summary>
    
      <category term="哔哔叨叨" scheme="http://yaliixxg.github.io/categories/%E5%93%94%E5%93%94%E5%8F%A8%E5%8F%A8/"/>
    
    
      <category term="世界杯" scheme="http://yaliixxg.github.io/tags/%E4%B8%96%E7%95%8C%E6%9D%AF/"/>
    
  </entry>
  
  <entry>
    <title>First</title>
    <link href="http://yaliixxg.github.io/2018/06/12/20180612/"/>
    <id>http://yaliixxg.github.io/2018/06/12/20180612/</id>
    <published>2018-06-12T09:58:45.000Z</published>
    <updated>2018-06-14T07:20:39.205Z</updated>
    
    <content type="html"><![CDATA[<p>豆豆，哦豆豆，豆豆豆豆</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;豆豆，哦豆豆，豆豆豆豆&lt;/p&gt;

      
    
    </summary>
    
      <category term="哔哔叨叨" scheme="http://yaliixxg.github.io/categories/%E5%93%94%E5%93%94%E5%8F%A8%E5%8F%A8/"/>
    
    
      <category term="自我介绍" scheme="http://yaliixxg.github.io/tags/%E8%87%AA%E6%88%91%E4%BB%8B%E7%BB%8D/"/>
    
  </entry>
  
</feed>
